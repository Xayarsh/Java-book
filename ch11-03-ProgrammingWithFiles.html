<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Programming with Files - Introduction to Programming Using Java</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

<link rel="stylesheet" href="code-class.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html" >Introduction to Programming Using Java</a></li><li class="chapter-item expanded affix "><a href="preface.html">Preface</a></li><li class="chapter-item expanded "><a href="ch01-00-Overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-FetchExecuteCycle.html"><strong aria-hidden="true">1.1.</strong> Fetch and Execute Cycle</a></li><li class="chapter-item expanded "><a href="ch01-02-AsynchronousEvents.html"><strong aria-hidden="true">1.2.</strong> Asynchronous Events</a></li><li class="chapter-item expanded "><a href="ch01-03-JavaVirtualMachine.html"><strong aria-hidden="true">1.3.</strong> The Java Virtual Machine</a></li><li class="chapter-item expanded "><a href="ch01-04-FundamentalBuildingBlocks.html"><strong aria-hidden="true">1.4.</strong> Fundamentals</a></li><li class="chapter-item expanded "><a href="ch01-05-OOP.html"><strong aria-hidden="true">1.5.</strong> Object Oriented Programming</a></li><li class="chapter-item expanded "><a href="ch01-06-ModernUserInterface.html"><strong aria-hidden="true">1.6.</strong> Modern User Interface</a></li><li class="chapter-item expanded "><a href="ch01-07-InternetAndBeyond.html"><strong aria-hidden="true">1.7.</strong> Internet and Beyond</a></li><li class="chapter-item expanded "><a href="ch01-08-Quiz.html"><strong aria-hidden="true">1.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-NameAndThings.html"><strong aria-hidden="true">2.</strong> Name and Things</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-BasicJavaApplication.html"><strong aria-hidden="true">2.1.</strong> Basic Java Application</a></li><li class="chapter-item expanded "><a href="ch02-02-VariablesAndTypes.html"><strong aria-hidden="true">2.2.</strong> Variables and Types</a></li><li class="chapter-item expanded "><a href="ch02-03-ObjectsAndSubroutines.html"><strong aria-hidden="true">2.3.</strong> Objects and Subroutines</a></li><li class="chapter-item expanded "><a href="ch02-04-TextInputAndOutput.html"><strong aria-hidden="true">2.4.</strong> Text Input and Output</a></li><li class="chapter-item expanded "><a href="ch02-05-DetailsOfExpressions.html"><strong aria-hidden="true">2.5.</strong> Details of Expressions</a></li><li class="chapter-item expanded "><a href="ch02-06-ProgrammingEnvironments.html"><strong aria-hidden="true">2.6.</strong> Programming and Environments</a></li><li class="chapter-item expanded "><a href="ch02-07-Exercises.html"><strong aria-hidden="true">2.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch02-08-Quiz.html"><strong aria-hidden="true">2.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-Control.html"><strong aria-hidden="true">3.</strong> Control</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-BlocksLoopsBranches.html"><strong aria-hidden="true">3.1.</strong> Blocks, Loops and Branches</a></li><li class="chapter-item expanded "><a href="ch03-02-AlgorithmDevelopment.html"><strong aria-hidden="true">3.2.</strong> Algorithm Development</a></li><li class="chapter-item expanded "><a href="ch03-03-While.html"><strong aria-hidden="true">3.3.</strong> while and do...while</a></li><li class="chapter-item expanded "><a href="ch03-04-For.html"><strong aria-hidden="true">3.4.</strong> The for statement</a></li><li class="chapter-item expanded "><a href="ch03-05-If.html"><strong aria-hidden="true">3.5.</strong> The If Statement</a></li><li class="chapter-item expanded "><a href="ch03-06-Switch.html"><strong aria-hidden="true">3.6.</strong> The Switch Statement</a></li><li class="chapter-item expanded "><a href="ch03-07-ExceptionsTryCatch.html"><strong aria-hidden="true">3.7.</strong> Exceptions and try...catch</a></li><li class="chapter-item expanded "><a href="ch03-08-Arrays.html"><strong aria-hidden="true">3.8.</strong> Arrays: An Introduction</a></li><li class="chapter-item expanded "><a href="ch03-09-GUI.html"><strong aria-hidden="true">3.9.</strong> GUI: An Introduction</a></li><li class="chapter-item expanded "><a href="ch03-10-Exercises.html"><strong aria-hidden="true">3.10.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch03-11-Quiz.html"><strong aria-hidden="true">3.11.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-Subroutines.html"><strong aria-hidden="true">4.</strong> Subroutines</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-BlackBoxes.html"><strong aria-hidden="true">4.1.</strong> Black Boxes</a></li><li class="chapter-item expanded "><a href="ch04-02-StaticSubroutines.html"><strong aria-hidden="true">4.2.</strong> Static Subroutines and Variables</a></li><li class="chapter-item expanded "><a href="ch04-03-Parameters.html"><strong aria-hidden="true">4.3.</strong> Parameters</a></li><li class="chapter-item expanded "><a href="ch04-04-ReturnValues.html"><strong aria-hidden="true">4.4.</strong> Return Values</a></li><li class="chapter-item expanded "><a href="ch04-05-Lambda.html"><strong aria-hidden="true">4.5.</strong> Lambda Expressions</a></li><li class="chapter-item expanded "><a href="ch04-06-APIPackagesModulesJavadoc.html"><strong aria-hidden="true">4.6.</strong> API, Packages, Modules and Javadoc</a></li><li class="chapter-item expanded "><a href="ch04-07-MoreOnProgramDesign.html"><strong aria-hidden="true">4.7.</strong> More on Program Design</a></li><li class="chapter-item expanded "><a href="ch04-08-TruthAboutDeclarations.html"><strong aria-hidden="true">4.8.</strong> Truth about Declarations</a></li><li class="chapter-item expanded "><a href="ch04-09-Exercises.html"><strong aria-hidden="true">4.9.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch04-10-Quiz.html"><strong aria-hidden="true">4.10.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-ObjectsClasses.html"><strong aria-hidden="true">5.</strong> Objects and Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-ObjectsAndInstanceMethods.html"><strong aria-hidden="true">5.1.</strong> Objects and Instance Methods</a></li><li class="chapter-item expanded "><a href="ch05-02-ConstructorObjectInit.html"><strong aria-hidden="true">5.2.</strong> Constructor and Object Initialization</a></li><li class="chapter-item expanded "><a href="ch05-03-ProgrammingWithObjects.html"><strong aria-hidden="true">5.3.</strong> Programming with Objects</a></li><li class="chapter-item expanded "><a href="ch05-04-AnExample.html"><strong aria-hidden="true">5.4.</strong> An Example</a></li><li class="chapter-item expanded "><a href="ch05-05-InheritanceAndPolymorphism.html"><strong aria-hidden="true">5.5.</strong> Inheritance and Polymorphism</a></li><li class="chapter-item expanded "><a href="ch05-06-thisandsuper.html"><strong aria-hidden="true">5.6.</strong> this and super</a></li><li class="chapter-item expanded "><a href="ch05-07-Interfaces.html"><strong aria-hidden="true">5.7.</strong> Interfaces</a></li><li class="chapter-item expanded "><a href="ch05-08-NestedClasses.html"><strong aria-hidden="true">5.8.</strong> Nested Classes</a></li><li class="chapter-item expanded "><a href="ch05-09-Exercises.html"><strong aria-hidden="true">5.9.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch05-10-Quiz.html"><strong aria-hidden="true">5.10.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-GUIProgramming.html"><strong aria-hidden="true">6.</strong> Introduction to GUI Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-BasicJavaFXApp.html"><strong aria-hidden="true">6.1.</strong> A Basic JavaFX Application</a></li><li class="chapter-item expanded "><a href="ch06-02-BasicClasses.html"><strong aria-hidden="true">6.2.</strong> Basic Classes</a></li><li class="chapter-item expanded "><a href="ch06-03-BasicEvents.html"><strong aria-hidden="true">6.3.</strong> Basic Events</a></li><li class="chapter-item expanded "><a href="ch06-04-BasicControls.html"><strong aria-hidden="true">6.4.</strong> Basic Controls</a></li><li class="chapter-item expanded "><a href="ch06-05-BasicLayout.html"><strong aria-hidden="true">6.5.</strong> Basic Layout</a></li><li class="chapter-item expanded "><a href="ch06-06-CompetePrograms.html"><strong aria-hidden="true">6.6.</strong> Complete Programs</a></li><li class="chapter-item expanded "><a href="ch06-07-Exercises.html"><strong aria-hidden="true">6.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch06-08-Quiz.html"><strong aria-hidden="true">6.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-ArraysArraylistsRecords.html"><strong aria-hidden="true">7.</strong> Arrays, ArrayLists and Records</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-ArrayDetails.html"><strong aria-hidden="true">7.1.</strong> Array Details</a></li><li class="chapter-item expanded "><a href="ch07-02-ArrayProcessing.html"><strong aria-hidden="true">7.2.</strong> Array Processing</a></li><li class="chapter-item expanded "><a href="ch07-03-ArrayLists.html"><strong aria-hidden="true">7.3.</strong> ArrayLists</a></li><li class="chapter-item expanded "><a href="ch07-04-Records.html"><strong aria-hidden="true">7.4.</strong> Records</a></li><li class="chapter-item expanded "><a href="ch07-05-SearchingAndSorting.html"><strong aria-hidden="true">7.5.</strong> Searching and Sorting</a></li><li class="chapter-item expanded "><a href="ch07-06-2DArrays.html"><strong aria-hidden="true">7.6.</strong> 2D Arrays</a></li><li class="chapter-item expanded "><a href="ch07-07-Exercises.html"><strong aria-hidden="true">7.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch07-08-Quiz.html"><strong aria-hidden="true">7.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-CorrectnessRobustnessEfficiency.html"><strong aria-hidden="true">8.</strong> Correctness, Robustness, Efficiency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-IntroductionCorrectnessandRobustness.html"><strong aria-hidden="true">8.1.</strong> Introduction to Correctness and Robustness</a></li><li class="chapter-item expanded "><a href="ch08-02-WritingCorrectPrograms.html"><strong aria-hidden="true">8.2.</strong> Writing Correct Programs</a></li><li class="chapter-item expanded "><a href="ch08-03-ExceptionsAndtrycatch.html"><strong aria-hidden="true">8.3.</strong> Exceptions and try..catch</a></li><li class="chapter-item expanded "><a href="ch08-04-AssertionsAnnotations.html"><strong aria-hidden="true">8.4.</strong> Assertions and Annotations</a></li><li class="chapter-item expanded "><a href="ch08-05-AnalysisofAlgorithms.html"><strong aria-hidden="true">8.5.</strong> Analysis of Algorithms</a></li><li class="chapter-item expanded "><a href="ch08-06-Exercises.html"><strong aria-hidden="true">8.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch08-07-Quiz.html"><strong aria-hidden="true">8.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-LinkedDataStructuresRecursion.html"><strong aria-hidden="true">9.</strong> Linked Data Structures and Recursion</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-Recursion.html"><strong aria-hidden="true">9.1.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="ch09-02-LinkedDataStructures.html"><strong aria-hidden="true">9.2.</strong> Linked Data Structures</a></li><li class="chapter-item expanded "><a href="ch09-03-StacksQueuesADTs.html"><strong aria-hidden="true">9.3.</strong> Stacks, Queues and ADTs</a></li><li class="chapter-item expanded "><a href="ch09-04-BinaryTrees.html"><strong aria-hidden="true">9.4.</strong> Binary Trees</a></li><li class="chapter-item expanded "><a href="ch09-05-SimpleRecursiveDescentParser.html"><strong aria-hidden="true">9.5.</strong> A Simple Recursive Descent Parser</a></li><li class="chapter-item expanded "><a href="ch09-06-Exercises.html"><strong aria-hidden="true">9.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch09-07-Quiz.html"><strong aria-hidden="true">9.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-GenericProgrammingandCollectionClasses.html"><strong aria-hidden="true">10.</strong> Generic Programmingand Collection Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-GenericProgramming.html"><strong aria-hidden="true">10.1.</strong> Generic Programming</a></li><li class="chapter-item expanded "><a href="ch10-02-ListsandSets.html"><strong aria-hidden="true">10.2.</strong> Lists and Sets</a></li><li class="chapter-item expanded "><a href="ch10-03-Maps.html"><strong aria-hidden="true">10.3.</strong> Maps</a></li><li class="chapter-item expanded "><a href="ch10-04-JCF.html"><strong aria-hidden="true">10.4.</strong> Programming with the JCF</a></li><li class="chapter-item expanded "><a href="ch10-05-WritingGenericClassesandMethods.html"><strong aria-hidden="true">10.5.</strong> Writing Generic Classes and Methods</a></li><li class="chapter-item expanded "><a href="ch10-06-StreamAPI.html"><strong aria-hidden="true">10.6.</strong> Stream APIs</a></li><li class="chapter-item expanded "><a href="ch10-07-Exercises.html"><strong aria-hidden="true">10.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch10-08-Quiz.html"><strong aria-hidden="true">10.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-IOStreamsFilesNetworking.html"><strong aria-hidden="true">11.</strong> I/O Streams, Files, and Networking</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-IOStreamsReadersAndWriters.html"><strong aria-hidden="true">11.1.</strong> I/O Streams, Readers, and Writers</a></li><li class="chapter-item expanded "><a href="ch11-02-Files.html"><strong aria-hidden="true">11.2.</strong> Files</a></li><li class="chapter-item expanded "><a class="active" href="ch11-03-ProgrammingWithFiles.html"><strong aria-hidden="true">11.3.</strong> Programming With Files</a></li><li class="chapter-item expanded "><a href="ch11-04-Networking.html"><strong aria-hidden="true">11.4.</strong> Networking</a></li><li class="chapter-item expanded "><a href="ch11-05-XML.html"><strong aria-hidden="true">11.5.</strong> A Brief Introduction to XML</a></li><li class="chapter-item expanded "><a href="ch11-06-Exercises.html"><strong aria-hidden="true">11.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch11-07-Quiz.html"><strong aria-hidden="true">11.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-ThreadsandMultiprocessing.html"><strong aria-hidden="true">12.</strong> Threads and Multiprocessing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-IntroductiontoThreads.html"><strong aria-hidden="true">12.1.</strong> Introduction to Threads</a></li><li class="chapter-item expanded "><a href="ch12-02-ProgrammingwithThreads.html"><strong aria-hidden="true">12.2.</strong> Programming with Threads</a></li><li class="chapter-item expanded "><a href="ch12-03-ThreadsandParallelProcessing.html"><strong aria-hidden="true">12.3.</strong> Threads and Networking</a></li><li class="chapter-item expanded "><a href="ch12-04-ThreadsandNetworking.html"><strong aria-hidden="true">12.4.</strong> Threads and Networking</a></li><li class="chapter-item expanded "><a href="ch12-05-NetworkProgrammingExample.html"><strong aria-hidden="true">12.5.</strong> Network Programming Example</a></li><li class="chapter-item expanded "><a href="ch12-06-Exercises.html"><strong aria-hidden="true">12.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch12-07-Quiz.html"><strong aria-hidden="true">12.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-GUIProgrammingContinued.html"><strong aria-hidden="true">13.</strong> GUI Programming Continued</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-PropertiesandBindings.html"><strong aria-hidden="true">13.1.</strong> Properties and Bindings</a></li><li class="chapter-item expanded "><a href="ch13-02-FancierGraphics.html"><strong aria-hidden="true">13.2.</strong> Fancier Graphics</a></li><li class="chapter-item expanded "><a href="ch13-03-ComplexComponentsandMVC.html"><strong aria-hidden="true">13.3.</strong> Complex Components and MVC</a></li><li class="chapter-item expanded "><a href="ch13-04-MostlyWindowsandDialogs.html"><strong aria-hidden="true">13.4.</strong> Mostly Windows and Dialogs</a></li><li class="chapter-item expanded "><a href="ch13-05-FinishingTouches.html"><strong aria-hidden="true">13.5.</strong> Finishing Touches</a></li><li class="chapter-item expanded "><a href="ch13-06-Exercises.html"><strong aria-hidden="true">13.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch13-07-Quiz.html"><strong aria-hidden="true">13.7.</strong> Quiz</a></li></ol><li class="chapter-item expanded "><a href="appendix-00.html"> Appendix</a></li><li class="chapter-item expanded "><a href="glossary-00.html"> Glossary</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="Java">Java</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Introduction to Programming Using Java</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Xayarsh/Java-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Programming with Files"><a class="header" href="#Programming with Files">Programming with Files</a></h2>
                        <p>
                            In this section, we look at several programming
                            examples that work with files, using the techniques that were
                            introduced in <a href="ch11-01-IOStreamsReadersAndWriters.html">Section&nbsp;11.1</a> and <a href="ch11-02-Files.html">Section&nbsp;11.2</a>.</p>



                        <h3 id="Copying a File"><a class="header" href="#Copying a File">Copying a File</a></h3>

                        <p>As a first example, we look at a simple command-line program
                            that can make a copy of a file.
                            Copying a file is a pretty common operation, and every operating
                            system already has a command for doing it. However, it is still instructive
                            to look at a Java program that does the same thing. Many file operations are
                            similar to copying a file, except that the data from the input file is
                            processed in some way before it is written to the output file. All such
                            operations can be done by programs with the same general form.
                            <a href="ch04-03-Parameters.html">Subsection&nbsp;4.3.6</a> included a program for copying text files
                            using <span class="classname">TextIO</span>.  The example in this section will
                            work for any file.</p>


                        <p>Since the program should be able to copy any file, we can't assume that the
                            data in the file is in human-readable form. So, we have to use the byte streams,
                            <span class="classname">InputStream</span> and <span class="classname">OutputStream</span>,
                            to operate on the file.  The program simply copies all the
                            data from the <span class="classname">InputStream</span> to the <span class="classname">OutputStream</span>, one byte at a
                            time. If <span class="code">source</span> is the variable that refers to the
                            <span class="classname">InputStream</span>, then the function <span class="code">source.read()</span> can be used to
                            read one byte. This function returns the value -1 when all the bytes in the
                            input file have been read. Similarly, if <span class="code">copy</span> refers to the
                            <span class="classname">OutputStream</span>, then <span class="code">copy.write(b)</span> writes one byte to the
                            output file. So, the heart of the program is a simple <span class="code">while</span> loop. As
                            usual, the I/O operations can throw exceptions, so this must be done in a
                            <span class="code">try..catch</span> statement:</p>


                        <pre><code class="java">while(true) {
   int data = source.read();
   if (data &lt; 0)
      break;
   copy.write(data);
}</code></pre>


                        <p>The file-copy command in an operating system such as UNIX uses
                            command line arguments to specify the names of the files. For example, the user
                            might say "<span class="code">copy original.dat backup.dat</span>" to copy an existing file,
                            <span class="code">original.dat</span>, to a file named <span class="code">backup.dat</span>. Command-line
                            arguments can also be used in Java programs. The command line arguments are
                            stored in the array of strings, <span class="code">args</span>, which is a parameter to the
                            <span class="code">main()</span> routine. The program can retrieve the command-line arguments
                            from this array. (See <a href="ch04-03-Parameters.html">Subsection&nbsp;4.3.6</a>.)
                            For example, if the program is named <span class="code">CopyFile</span> and if
                            the user runs the program with the command</p>


                        <pre><code class="java">java CopyFile work.dat oldwork.dat</code></pre>


                        <p>then in the program, <span class="code">args[0]</span> will be the string
                            <span class="code">"work.dat"</span> and <span class="code">args[1]</span> will be the string
                            <span class="code">"oldwork.dat"</span>. The value of <span class="code">args.length</span> tells the program how
                            many command-line arguments were specified by the user.</p>


                        <p>The program <span class="sourceref"><a href="./source/chapter11/CopyFile.java">CopyFile.java</a></span> gets the names of the files from the
                            command-line arguments. It prints an error message and exits if the file names
                            are not specified. To add a little interest, there are two ways to use the
                            program. The command line can simply specify the two file names. In that case,
                            if the output file already exists, the program will print an error message and
                            end. This is to make sure that the user won't accidently overwrite an important
                            file. However, if the command line has three arguments, then the first argument
                            must be "<span class="code">-f</span>" while the second and third arguments are file names. The
                            <span class="code">-f</span> is a <span class="newword">command-line option</span>, which is
                            meant to modify the behavior of the program. The program interprets the
                            <span class="code">-f</span> to mean that it's OK to overwrite an existing program. (The "f"
                            stands for "force," since it forces the file to be copied in spite of what
                            would otherwise have been considered an error.) You can see in the source code
                            how the command line arguments are interpreted by the program:</p>


                        <pre><code class="java">import java.io.*;

/**
 *  Makes a copy of a file.  The original file and the name of the
 *  copy must be given as command-line arguments.  In addition, the
 *  first command-line argument can be "-f"; if present, the program
 *  will overwrite an existing file; if not, the program will report
 *  an error and end if the output file already exists.  The number
 *  of bytes that are copied is reported.
 */
public class CopyFile {

   public static void main(String[] args) {

      String sourceName;   // Name of the source file,
                           //    as specified on the command line.
      String copyName;     // Name of the copy,
                           //    as specified on the command line.
      InputStream source;  // Stream for reading from the source file.
      OutputStream copy;   // Stream for writing the copy.
      boolean force;  // This is set to true if the "-f" option
                      //    is specified on the command line.
      int byteCount;  // Number of bytes copied from the source file.

      /* Get file names from the command line and check for the
         presence of the -f option.  If the command line is not one
         of the two possible legal forms, print an error message and
         end this program. */

      if (args.length == 3 &amp;&amp; args[0].equalsIgnoreCase("-f")) {
         sourceName = args[1];
         copyName = args[2];
         force = true;
      }
      else if (args.length == 2) {
         sourceName = args[0];
         copyName = args[1];
         force = false;
      }
      else {
         System.out.println(
                 "Usage:  java CopyFile &lt;source-file&gt; &lt;copy-name&gt;");
         System.out.println(
                 "    or  java CopyFile -f &lt;source-file&gt; &lt;copy-name&gt;");
         return;
      }

      /* Create the input stream.  If an error occurs, end the program. */

      try {
         source = new FileInputStream(sourceName);
      }
      catch (FileNotFoundException e) {
         System.out.println("Can't find file \"" + sourceName + "\".");
         return;
      }

      /* If the output file already exists and the -f option was not
         specified, print an error message and end the program. */

      File file = new File(copyName);
      if (file.exists() &amp;&amp; force == false) {
          System.out.println(
               "Output file exists.  Use the -f option to replace it.");
          return;
      }

      /* Create the output stream.  If an error occurs, end the program. */

      try {
         copy = new FileOutputStream(copyName);
      }
      catch (IOException e) {
         System.out.println("Can't open output file \"" + copyName + "\".");
         return;
      }

      /* Copy one byte at a time from the input stream to the output
         stream, ending when the read() method returns -1 (which is
         the signal that the end of the stream has been reached).  If any
         error occurs, print an error message.  Also print a message if
         the file has been copied successfully.  */

      byteCount = 0;

      try {
         while (true) {
            int data = source.read();
            if (data &lt; 0)
               break;
            copy.write(data);
            byteCount++;
         }
         source.close();
         copy.close();
         System.out.println("Successfully copied " + byteCount + " bytes.");
      }
      catch (Exception e) {
         System.out.println("Error occurred while copying.  "
                                   + byteCount + " bytes copied.");
         System.out.println("Error: " + e);
      }

   }  // end main()


} // end class CopyFile</code></pre>


                        <p>It is actually quite inefficient to copy one byte at a time.  Efficiency could
                            be improved by using alternative versions of the <span class="code">read()</span> and
                            <span class="code">write()</span> methods that read and write multiple bytes (see the
                            API for details).  Alternatively, the input and output streams could
                            be wrapped in objects of type <span class="classname">BufferedInputStream</span>
                            and <span class="classname">BufferedOutputStream</span> which automatically read
                            data from and write data to files in larger blocks.  This would require changing only
                            the two lines in the program that create the streams.  For example, the
                            input stream could be created using</p>


                        <pre><code class="java">source = new BufferedInputStream(new FileInputStream(sourceName));</code></pre>


                        <p>The buffered stream would then be used in exactly the same way as the
                            unbuffered stream.</p>


                        <p>There is also a sample program <span class="sourceref"><a href="./source/chapter11/CopyFileAsResources.java">CopyFileAsResources.java</a></span> that
                            does the same thing as <span class="code">CopyFile</span> but uses the resource pattern in a
                            <span class="code">try..catch</span> statement to make sure that the streams are closed in
                            all cases.  See the discussion at the end of <a href="ch08-03-ExceptionsAndtrycatch.html">Subsection&nbsp;8.3.2</a>)</p>

                        
                        <h3 id="Persistent Data"><a class="header" href="#Persistent Data">Persistent Data</a></h3>
                      

                        <p>Once a program ends, any data that was stored in variables and objects in
                            the program is gone.  In many cases, it would be useful to have some of that
                            data stick around so that it will be available when the program is run again.
                            The problem is, how to make the data <span class="newword">persistent</span> between
                            runs of the program?  The answer, of course, is to store the data in a file
                            (or, for some applications, in a database&mdash;but the data in a
                            database is itself stored in files).</p>


                        <p>Consider a "phone book" program that allows the user to keep track of
                            a list of names and associated phone numbers.  The program would make no sense
                            at all if the user had to create the whole list from scratch each time
                            the program is run.  It would make more sense to think of the phone book
                            as a persistent collection of data, and to think of the program as an
                            interface to that collection of data.  The program would allow the user
                            to look up names in the phone book and to add new entries.  Any changes
                            that are made should be preserved after the program ends.</p>


                        <p>The sample program <span class="sourceref"><a href="./source/chapter11/PhoneDirectoryFileDemo.java">PhoneDirectoryFileDemo.java</a></span> is
                            a very simple implementation of this idea.  It is meant only as an
                            example of file use; the phone book that it implements is a "toy" version
                            that is <b>not</b> meant to be taken seriously.  This program stores the phone
                            book data in a file named "<span class="code">.phone_book_demo</span>" in the user's
                            home directory.  To find the user's home directory, it uses the
                            <span class="code">System.getProperty()</span> method that was mentioned in
                            <a href="ch11-02-Files.html">Subsection&nbsp;11.2.2</a>.  When the program starts, it checks whether
                            the file already exists.  If the file exists, it should contain the user's
                            phone book, which was saved in a previous run of the program; in that case,
                            the data from the file is read and entered into a <span class="classname">TreeMap</span>
                            named <span class="code">phoneBook</span>
                            that represents the phone book while the program is running.
                            (See <a href="ch10-03-Maps.html">Subsection&nbsp;10.3.1</a>.)
                            In order to store the phone book in a file, some decision must be
                            made about how the data in the phone book will be represented. For
                            this example, I chose a simple representation in which each line of
                            the file contains one entry consisting of a name and the associated
                            phone number.  A percent sign (<span class="code">'%'</span>) separates the name
                            from the number.  The following code at the beginning of the program
                            will read the phone book data file, if it exists and has the correct
                            format:</p>


                        <pre><code class="java">File userHomeDirectory = new File( System.getProperty("user.home") );
File dataFile = new File( userHomeDirectory, ".phone_book_data" );
        // A file named .phone_book_data in the user's home directory.

if ( ! dataFile.exists() ) {
   System.out.println("No phone book data file found.  A new one");
   System.out.println("will be created, if you add any entries.");
   System.out.println("File name:  " + dataFile.getAbsolutePath());
}
else {
   System.out.println("Reading phone book data...");
   try( Scanner scanner = new Scanner(dataFile) ) {
      while (scanner.hasNextLine()) {
             // Read one line from the file, containing one name/number pair.
         String phoneEntry = scanner.nextLine();
         int separatorPosition = phoneEntry.indexOf('%');
         if (separatorPosition == -1)
            throw new IOException("File is not a phonebook data file.");
         name = phoneEntry.substring(0, separatorPosition);
         number = phoneEntry.substring(separatorPosition+1);
         phoneBook.put(name,number);
      }
   }
   catch (IOException e) {
      System.out.println("Error in phone book data file.");
      System.out.println("File name:  " + dataFile.getAbsolutePath());
      System.out.println("This program cannot continue.");
      System.exit(1);
   }
}</code></pre>


                        <p>The program then lets the user do various things with the phone book,
                            including making modifications.  Any changes that are made are made
                            only to the <span class="classname">TreeMap</span> that holds the data.
                            When the program ends, the phone book data is written to the file
                            (if any changes have been made while the program was running),
                            using the following code:</p>


                        <pre><code class="java">if (changed) {
   System.out.println("Saving phone directory changes to file " +
         dataFile.getAbsolutePath() + " ...");
   PrintWriter out;
   try {
      out = new PrintWriter( new FileWriter(dataFile) );
   }
   catch (IOException e) {
      System.out.println("ERROR: Can't open data file for output.");
      return;
   }
   for ( Map.Entry&lt;String,String&gt; entry : phoneBook.entrySet() )
      out.println(entry.getKey() + "%" + entry.getValue() );
   out.flush();
   out.close();
   if (out.checkError())
      System.out.println("ERROR: Some error occurred while writing data file.");
   else
      System.out.println("Done.");
}</code></pre>


                        <p>The net effect of this is that all the data, including the changes,
                            will be there the next time the program is run.  I've shown you all the
                            file-handling code from the program.  If you would like to see the rest
                            of the program, see the <span class="sourceref"><a href="./source/chapter11/PhoneDirectoryFileDemo.java">source code</a></span>.</p>
                        

                        <h3 id="Storing Objects in Files"><a class="header" href="#Storing Objects in Files">Storing Objects in Files</a></h3>

                        <p>Whenever data is stored in files, some definite format must be adopted for
                            representing the data.  As long as the output routine that writes the data
                            and the input routine that reads the data use the same format, the files
                            will be usable.  However, as usual, correctness is not the end of the story.
                            The representation that is used for data in files should also be robust.
                            (See <a href="ch08-01-IntroductionCorrectnessandRobustness.html">Section&nbsp;8.1</a>.)  To see what this means, we will look
                            at several different ways of representing the same data.  This example
                            builds on the example <span class="sourceref"><a href="./source/chapter7/SimplePaint2.java">SimplePaint2.java</a></span> from
                            <a href="ch07-03-ArrayLists.html">Subsection&nbsp;7.3.3</a>.  (You might want to run it now to remind yourself
                            of what it can do.)  In that program, the user can use the
                            mouse to draw simple sketches.  Now, we will add file input/output capabilities
                            to that program.  This will allow the user to save a sketch to a file and later read
                            the sketch back from the file into the program so that the user can continue
                            to work on the sketch.  The basic requirement is that all relevant data
                            about the sketch must be saved in the file, so that the sketch can be
                            exactly restored when the file is read by the program.</p>



                        <p>The new version of the program can be found in the source code
                            file <span class="sourceref"><a href="./source/chapter11/SimplePaintWithFiles.java">SimplePaintWithFiles.java</a></span>.  A "File" menu
                            has been added to the new version.  It implements "Save" and
                            "Open" commands for writing program data to a file and reading
                            saved data back into the program.</p>


                        <p>The data for a sketch consists of the background color of the picture
                            and a list of the curves that were drawn by the user.  A curve consists of
                            a list of <span class="classname">Point2Ds</span>.
                            A <span class="classname">Point2D</span>,
                            <span class="code">pt</span>, has instance methods <span class="code">pt.getX()</span> and <span class="code">pt.getY()</span>
                            that return the coordinates of a point in the xy-plane as values of type <span class="ptype">double</span>.  Each curve can be a different color.  Furthermore, a curve can be "symmetric," which
                            means that in addition to the curve itself, the horizontal and vertical reflections
                            of the curve are also drawn.  The data for each
                            curve are stored in an object of type <span class="classname">CurveData</span>, which
                            is defined in the program as:</p>


                        <pre><code class="java">/**
 * An object of type CurveData represents the data required to redraw one
 * of the curves that have been sketched by the user.
 */
private static class CurveData {
   Color color;  // The color of the curve.
   boolean symmetric;  // Are horizontal and vertical reflections also drawn?
   ArrayList&lt;Point2D&gt; points;  // The points on the curve.
}</code></pre>


                        <p>Then, a list of type <span class="atype">ArrayList&lt;CurveData&gt;</span> is used to hold
                            data for all of the curves that the user has drawn.</p>


                        <p>Let's think about how the data for a sketch could be saved to a text file.
                            The basic idea is that all data necessary to reconstitute
                            a sketch must be saved to the output file in some definite format.  The method
                            that reads the file must follow exactly the same format as it reads the data,
                            and it must use the data to rebuild the data structures that represent the sketch
                            while the program is running.</p>


                        <p>When writing character data, all of the data has to be expressed, ultimately, in terms of simple
                            data values such as strings and primitive type values.  A color, for example,
                            can be expressed in terms of three numbers giving the red, green, and blue
                            components of the color.  The first (not very good) idea that comes to mind might be to
                            just dump all the necessary data, in some definite order, into the file.
                            Suppose that <span class="code">out</span> is a <span class="classname">PrintWriter</span> that
                            is used to write to the file.  We could then say:</p>


                        <pre><code class="java">out.println( backgroundColor.getRed() ); // Write background color to file.
out.println( backgroundColor.getGreen() );
out.println( backgroundColor.getBlue() );

out.println( curves.size() );       // Write the number of curves.

for ( CurveData curve : curves ) {  // For each curve, write...
   out.println( curve.color.getRed() );      // the color of the curve
   out.println( curve.color.getGreen() );
   out.println( curve.color.getBlue() );
   out.println( curve.symmetric ? 0 : 1 );   // the curve's symmetry property
   out.println( curve.points.size() );       // the number of points on curve
   for ( Point2D pt : curve.points ) {       // the coordinates of each point
      out.println( pt.getX() );
      out.println( pt.getY() );
   }
}</code></pre>


                        <p>This works in the sense that the file-reading method can read the
                            data and rebuild the data structures.  Suppose that the input method uses
                            a <span class="classname">Scanner</span> named <span class="code">scanner</span> to read
                            the data file.  Then it could say:</p>


                        <pre><code class="java">Color newBackgroundColor;                // Read the background Color.
double red = scanner.nextDouble();
double green = scanner.nextDouble();
double blue = scanner.nextDouble();
newBackgroundColor = Color.color(red,green,blue);

ArrayList&lt;CurveData&gt; newCurves = new ArrayList&lt;&gt;();

int curveCount = scanner.nextInt();      // The number of curves to be read.
for (int i = 0; i &lt; curveCount; i++) {
   CurveData curve = new CurveData();
   double r = scanner.nextDouble();            // Read the curve's color.
   double g = scanner.nextDouble();
   double b = scanner.nextDouble();
   curve.color = Color.color(r,g,b);
   int symmetryCode = scanner.nextInt(); // Read the curve's symmetry property.
   curve.symmetric = (symmetryCode == 1);
   curveData.points = new ArrayList&lt;&gt;();
   int pointCount = scanner.nextInt();  // The number of points on this curve.
   for (int j = 0; j &lt; pointCount; j++) {
      int x = scanner.nextDouble();        // Read the coordinates of the point.
      int y = scanner.nextDouble();
      curveData.points.add(new Point2D(x,y));
   }
   newCurves.add(curve);
}

curves = newCurves;                     // Install the new data structures.
backgroundColor = newBackgroundColor;</code></pre>



                        <p>Note how every piece of data that was written by the output method is
                            read, in the same order, by the input method.  While this does work, the
                            data file is just a long string of numbers.  It doesn't make much more sense
                            to a human reader than a binary-format file would.  Furthermore, it is still
                            fragile in the sense that any small change made to the data representation
                            in the program, such as adding a new property to curves, will render the
                            data file useless (unless you happen to remember exactly which version of
                            the program created the file).</p>


                        <p>So, I decided to use a more complex, more meaningful data
                            format for the text files created by my program.  Instead of just
                            writing numbers, I add <b>words</b> to say what the numbers mean.
                            Here is a short but complete data file for the program; just by
                            looking at it, you can probably tell what is going on:</p>


                        <pre><code class="java">SimplePaintWithFiles 1.0
background 0.4 0.4 0.5

startcurve
  color 1 1 1
  symmetry true
  coords 10 10
  coords 200 250
  coords 300 10
endcurve

startcurve
  color 0 1 1
  symmetry false
  coords 10 400
  coords 590 400
endcurve</code></pre>


                        <p>The first line of the file identifies the program that created the
                            data file; when the user selects a file to be opened, the program can check
                            the first word in the file as a simple test to make sure the file
                            is of the correct type.  The first line also contains a version number,
                            1.0.  If the file format changes in a later version of the program, a
                            higher version number would be used; if the program sees a version number
                            of 1.2 in a file, but the program only understands version 1.0, the
                            program can explain to the user that a newer version of the program is
                            needed to read the data file.</p>


                        <p>The second line of the file specifies the background color of the
                            picture.  The three numbers specify the red, green, and blue components
                            of the color.  The word "background" at the beginning of the line makes
                            the meaning clear.  The remainder of the file consists of data for the
                            curves that appear in the picture.  The data for each curve is clearly
                            marked with "startcurve" and "endcurve."  The data consists of the color
                            and symmetry properties of the curve and the xy-coordinates of each
                            point on the curve.  Again, the meaning is clear.  Files in this format
                            can easily be created or edited by hand.  In fact, the data file shown
                            above was actually created in a text editor rather than by the program.
                            Furthermore, it's easy to extend the format to allow for additional options.
                            Future versions of the program could add a "thickness" property to the
                            curves to make it possible to have curves with differing line widths.
                            Shapes such as rectangles and ovals could easily be added.</p>


                        <p>Outputting data in this format is easy.  Suppose that <span class="code">out</span>
                            is a <span class="classname">PrintWriter</span> that is being used to write
                            the sketch data to a file.  Then the output is be done with:</p>


                        <pre><code class="java">out.println("SimplePaintWithFiles 1.0"); // Version number.
out.println( "background " + backgroundColor.getRed() + " " +
        backgroundColor.getGreen() + " " + backgroundColor.getBlue() );
for ( CurveData curve : curves ) {
    out.println();
    out.println("startcurve");
    out.println("  color " + curve.color.getRed() + " " +
            curve.color.getGreen() + " " + curve.color.getBlue() );
    out.println( "  symmetry " + curve.symmetric );
    for ( Point2D pt : curve.points )
        out.println( "  coords " + pt.getX() + " " + pt.getY() );
    out.println("endcurve");
}</code></pre>


                        <p>In the program, this code is used in a <span class="code">doSave()</span> method that
                            is similar to the one
                            that is presented in <a href="ch11-02-Files.html">Subsection&nbsp;11.2.3</a>.  The method
                            uses a file dialog box to allow the user to select the output file.</p>


                        <p>Reading the data is somewhat harder, since the input routine has to
                            deal with all the extra words in the data.  In my input routine,
                            I decided to allow some variation in the order in which the data occurs in the
                            file.  For example, the background color can be specified at
                            the end of the file, instead of at the beginning.  It can
                            even be left out altogether, in which case white will be used
                            as the default background color.  This is possible because
                            each item of data is labeled with a word that describes its
                            meaning; the labels can be used to drive the processing of
                            the input.  Here is the complete method from <span class="sourceref"><a href="./source/chapter11/SimplePaintWithFiles.java">SimplePaintWithFiles.java</a></span>
                            that reads data files created by the <span class="code">doSave()</span> method.  It uses a
                            <span class="classname">Scanner</span> to read items from the file:</p>



                        <pre><code class="java">private void doOpen() {
    FileChooser fileDialog = new FileChooser();
    fileDialog.setTitle("Select File to be Opened");
    fileDialog.setInitialFileName(null);  // No file is initially selected.
    if (editFile == null)
        fileDialog.setInitialDirectory(new File(System.getProperty("user.home")));
    else
        fileDialog.setInitialDirectory(editFile.getParentFile());
    File selectedFile = fileDialog.showOpenDialog(window);
    if (selectedFile == null)
        return;  // User canceled.
    Scanner scanner;
    try {
        scanner = new Scanner( selectedFile );
    }
    catch (Exception e) {
        Alert errorAlert = new Alert(Alert.AlertType.ERROR,
                "Sorry, but an error occurred\nwhile trying to open the file.");
        errorAlert.showAndWait();
        return;
    }
    try {
        String programName = scanner.next();
        if ( ! programName.equals("SimplePaintWithFiles") )
            throw new IOException("File is not a SimplePaintWithFiles data file.");
        double version = scanner.nextDouble();
        if (version &gt; 1.0)
            throw new IOException("File requires a newer version of SimplePaintWithFiles.");
        Color newBackgroundColor = Color.WHITE;
        ArrayList&lt;CurveData&gt; newCurves = new ArrayList&lt;CurveData&gt;();
        while (scanner.hasNext()) {
            String itemName = scanner.next();
            if (itemName.equalsIgnoreCase("background")) {
                double red = scanner.nextDouble();
                double green = scanner.nextDouble();
                double blue = scanner.nextDouble();
                newBackgroundColor = Color.color(red,green,blue);
            }
            else if (itemName.equalsIgnoreCase("startcurve")) {
                CurveData curve = new CurveData();
                curve.color = Color.BLACK;
                curve.symmetric = false;
                curve.points = new ArrayList&lt;Point2D&gt;();
                itemName = scanner.next();
                while ( ! itemName.equalsIgnoreCase("endcurve") ) {
                    if (itemName.equalsIgnoreCase("color")) {
                        double r = scanner.nextDouble();
                        double g = scanner.nextDouble();
                        double b = scanner.nextDouble();
                        curve.color = Color.color(r,g,b);
                    }
                    else if (itemName.equalsIgnoreCase("symmetry")) {
                        curve.symmetric = scanner.nextBoolean();
                    }
                    else if (itemName.equalsIgnoreCase("coords")) {
                        double x = scanner.nextDouble();
                        double y = scanner.nextDouble();
                        curve.points.add( new Point2D(x,y) );
                    }
                    else {
                        throw new Exception("Unknown term in input.");
                    }
                    itemName = scanner.next();
                }
                newCurves.add(curve);
            }
            else {
                throw new Exception("Unknown term in input.");
            }
        }
        scanner.close();
        backgroundColor = newBackgroundColor;
        curves = newCurves;
        redraw();
        editFile = selectedFile;
        window.setTitle("SimplePaint: " + editFile.getName());
    }
    catch (Exception e) {
        Alert errorAlert = new Alert(Alert.AlertType.ERROR,
                "Sorry, but an error occurred while\ntrying to read the data:\n"
                        + e);
        errorAlert.showAndWait();
    }
}</code></pre>




                        <p>The main reason for this long discussion of file formats has been to
                            get you to think about the problem of representing complex data in a form suitable
                            for storing the data in a file.  The same problem arises when data must
                            be transmitted over a network.  There is no one correct solution to the
                            problem, but some solutions are certainly better than others.  In
                            <a href="ch11-05-XML.html">Section&nbsp;11.5</a>, we will look at one solution to the data
                            representation problem that has become increasingly common.</p>





                        <p>In addition to being able to save sketch data in  text form,
                            <span class="code">SimplePaintWithFiles</span> can also save the
                            picture itself as an image file that could be, for example, printed
                            or put on a web page.  This is a preview of image-handling techniques
                            that will be covered in <a href="ch13-02-FancierGraphics.html">Subsection&nbsp;13.2.6</a>, and it uses
                            techniques that I have not yet covered.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch11-02-Files.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch11-04-Networking.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch11-02-Files.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch11-04-Networking.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </body>
</html>
