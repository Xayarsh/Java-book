<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Threads and Networking - Introduction to Programming Using Java</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

<link rel="stylesheet" href="code-class.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html" >Introduction to Programming Using Java</a></li><li class="chapter-item expanded affix "><a href="preface.html">Preface</a></li><li class="chapter-item expanded "><a href="ch01-00-Overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-FetchExecuteCycle.html"><strong aria-hidden="true">1.1.</strong> Fetch and Execute Cycle</a></li><li class="chapter-item expanded "><a href="ch01-02-AsynchronousEvents.html"><strong aria-hidden="true">1.2.</strong> Asynchronous Events</a></li><li class="chapter-item expanded "><a href="ch01-03-JavaVirtualMachine.html"><strong aria-hidden="true">1.3.</strong> The Java Virtual Machine</a></li><li class="chapter-item expanded "><a href="ch01-04-FundamentalBuildingBlocks.html"><strong aria-hidden="true">1.4.</strong> Fundamentals</a></li><li class="chapter-item expanded "><a href="ch01-05-OOP.html"><strong aria-hidden="true">1.5.</strong> Object Oriented Programming</a></li><li class="chapter-item expanded "><a href="ch01-06-ModernUserInterface.html"><strong aria-hidden="true">1.6.</strong> Modern User Interface</a></li><li class="chapter-item expanded "><a href="ch01-07-InternetAndBeyond.html"><strong aria-hidden="true">1.7.</strong> Internet and Beyond</a></li><li class="chapter-item expanded "><a href="ch01-08-Quiz.html"><strong aria-hidden="true">1.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-NameAndThings.html"><strong aria-hidden="true">2.</strong> Name and Things</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-BasicJavaApplication.html"><strong aria-hidden="true">2.1.</strong> Basic Java Application</a></li><li class="chapter-item expanded "><a href="ch02-02-VariablesAndTypes.html"><strong aria-hidden="true">2.2.</strong> Variables and Types</a></li><li class="chapter-item expanded "><a href="ch02-03-ObjectsAndSubroutines.html"><strong aria-hidden="true">2.3.</strong> Objects and Subroutines</a></li><li class="chapter-item expanded "><a href="ch02-04-TextInputAndOutput.html"><strong aria-hidden="true">2.4.</strong> Text Input and Output</a></li><li class="chapter-item expanded "><a href="ch02-05-DetailsOfExpressions.html"><strong aria-hidden="true">2.5.</strong> Details of Expressions</a></li><li class="chapter-item expanded "><a href="ch02-06-ProgrammingEnvironments.html"><strong aria-hidden="true">2.6.</strong> Programming and Environments</a></li><li class="chapter-item expanded "><a href="ch02-07-Exercises.html"><strong aria-hidden="true">2.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch02-08-Quiz.html"><strong aria-hidden="true">2.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-Control.html"><strong aria-hidden="true">3.</strong> Control</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-BlocksLoopsBranches.html"><strong aria-hidden="true">3.1.</strong> Blocks, Loops and Branches</a></li><li class="chapter-item expanded "><a href="ch03-02-AlgorithmDevelopment.html"><strong aria-hidden="true">3.2.</strong> Algorithm Development</a></li><li class="chapter-item expanded "><a href="ch03-03-While.html"><strong aria-hidden="true">3.3.</strong> while and do...while</a></li><li class="chapter-item expanded "><a href="ch03-04-For.html"><strong aria-hidden="true">3.4.</strong> The for statement</a></li><li class="chapter-item expanded "><a href="ch03-05-If.html"><strong aria-hidden="true">3.5.</strong> The If Statement</a></li><li class="chapter-item expanded "><a href="ch03-06-Switch.html"><strong aria-hidden="true">3.6.</strong> The Switch Statement</a></li><li class="chapter-item expanded "><a href="ch03-07-ExceptionsTryCatch.html"><strong aria-hidden="true">3.7.</strong> Exceptions and try...catch</a></li><li class="chapter-item expanded "><a href="ch03-08-Arrays.html"><strong aria-hidden="true">3.8.</strong> Arrays: An Introduction</a></li><li class="chapter-item expanded "><a href="ch03-09-GUI.html"><strong aria-hidden="true">3.9.</strong> GUI: An Introduction</a></li><li class="chapter-item expanded "><a href="ch03-10-Exercises.html"><strong aria-hidden="true">3.10.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch03-11-Quiz.html"><strong aria-hidden="true">3.11.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-Subroutines.html"><strong aria-hidden="true">4.</strong> Subroutines</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-BlackBoxes.html"><strong aria-hidden="true">4.1.</strong> Black Boxes</a></li><li class="chapter-item expanded "><a href="ch04-02-StaticSubroutines.html"><strong aria-hidden="true">4.2.</strong> Static Subroutines and Variables</a></li><li class="chapter-item expanded "><a href="ch04-03-Parameters.html"><strong aria-hidden="true">4.3.</strong> Parameters</a></li><li class="chapter-item expanded "><a href="ch04-04-ReturnValues.html"><strong aria-hidden="true">4.4.</strong> Return Values</a></li><li class="chapter-item expanded "><a href="ch04-05-Lambda.html"><strong aria-hidden="true">4.5.</strong> Lambda Expressions</a></li><li class="chapter-item expanded "><a href="ch04-06-APIPackagesModulesJavadoc.html"><strong aria-hidden="true">4.6.</strong> API, Packages, Modules and Javadoc</a></li><li class="chapter-item expanded "><a href="ch04-07-MoreOnProgramDesign.html"><strong aria-hidden="true">4.7.</strong> More on Program Design</a></li><li class="chapter-item expanded "><a href="ch04-08-TruthAboutDeclarations.html"><strong aria-hidden="true">4.8.</strong> Truth about Declarations</a></li><li class="chapter-item expanded "><a href="ch04-09-Exercises.html"><strong aria-hidden="true">4.9.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch04-10-Quiz.html"><strong aria-hidden="true">4.10.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-ObjectsClasses.html"><strong aria-hidden="true">5.</strong> Objects and Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-ObjectsAndInstanceMethods.html"><strong aria-hidden="true">5.1.</strong> Objects and Instance Methods</a></li><li class="chapter-item expanded "><a href="ch05-02-ConstructorObjectInit.html"><strong aria-hidden="true">5.2.</strong> Constructor and Object Initialization</a></li><li class="chapter-item expanded "><a href="ch05-03-ProgrammingWithObjects.html"><strong aria-hidden="true">5.3.</strong> Programming with Objects</a></li><li class="chapter-item expanded "><a href="ch05-04-AnExample.html"><strong aria-hidden="true">5.4.</strong> An Example</a></li><li class="chapter-item expanded "><a href="ch05-05-InheritanceAndPolymorphism.html"><strong aria-hidden="true">5.5.</strong> Inheritance and Polymorphism</a></li><li class="chapter-item expanded "><a href="ch05-06-thisandsuper.html"><strong aria-hidden="true">5.6.</strong> this and super</a></li><li class="chapter-item expanded "><a href="ch05-07-Interfaces.html"><strong aria-hidden="true">5.7.</strong> Interfaces</a></li><li class="chapter-item expanded "><a href="ch05-08-NestedClasses.html"><strong aria-hidden="true">5.8.</strong> Nested Classes</a></li><li class="chapter-item expanded "><a href="ch05-09-Exercises.html"><strong aria-hidden="true">5.9.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch05-10-Quiz.html"><strong aria-hidden="true">5.10.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-GUIProgramming.html"><strong aria-hidden="true">6.</strong> Introduction to GUI Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-BasicJavaFXApp.html"><strong aria-hidden="true">6.1.</strong> A Basic JavaFX Application</a></li><li class="chapter-item expanded "><a href="ch06-02-BasicClasses.html"><strong aria-hidden="true">6.2.</strong> Basic Classes</a></li><li class="chapter-item expanded "><a href="ch06-03-BasicEvents.html"><strong aria-hidden="true">6.3.</strong> Basic Events</a></li><li class="chapter-item expanded "><a href="ch06-04-BasicControls.html"><strong aria-hidden="true">6.4.</strong> Basic Controls</a></li><li class="chapter-item expanded "><a href="ch06-05-BasicLayout.html"><strong aria-hidden="true">6.5.</strong> Basic Layout</a></li><li class="chapter-item expanded "><a href="ch06-06-CompetePrograms.html"><strong aria-hidden="true">6.6.</strong> Complete Programs</a></li><li class="chapter-item expanded "><a href="ch06-07-Exercises.html"><strong aria-hidden="true">6.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch06-08-Quiz.html"><strong aria-hidden="true">6.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-ArraysArraylistsRecords.html"><strong aria-hidden="true">7.</strong> Arrays, ArrayLists and Records</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-ArrayDetails.html"><strong aria-hidden="true">7.1.</strong> Array Details</a></li><li class="chapter-item expanded "><a href="ch07-02-ArrayProcessing.html"><strong aria-hidden="true">7.2.</strong> Array Processing</a></li><li class="chapter-item expanded "><a href="ch07-03-ArrayLists.html"><strong aria-hidden="true">7.3.</strong> ArrayLists</a></li><li class="chapter-item expanded "><a href="ch07-04-Records.html"><strong aria-hidden="true">7.4.</strong> Records</a></li><li class="chapter-item expanded "><a href="ch07-05-SearchingAndSorting.html"><strong aria-hidden="true">7.5.</strong> Searching and Sorting</a></li><li class="chapter-item expanded "><a href="ch07-06-2DArrays.html"><strong aria-hidden="true">7.6.</strong> 2D Arrays</a></li><li class="chapter-item expanded "><a href="ch07-07-Exercises.html"><strong aria-hidden="true">7.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch07-08-Quiz.html"><strong aria-hidden="true">7.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-CorrectnessRobustnessEfficiency.html"><strong aria-hidden="true">8.</strong> Correctness, Robustness, Efficiency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-IntroductionCorrectnessandRobustness.html"><strong aria-hidden="true">8.1.</strong> Introduction to Correctness and Robustness</a></li><li class="chapter-item expanded "><a href="ch08-02-WritingCorrectPrograms.html"><strong aria-hidden="true">8.2.</strong> Writing Correct Programs</a></li><li class="chapter-item expanded "><a href="ch08-03-ExceptionsAndtrycatch.html"><strong aria-hidden="true">8.3.</strong> Exceptions and try..catch</a></li><li class="chapter-item expanded "><a href="ch08-04-AssertionsAnnotations.html"><strong aria-hidden="true">8.4.</strong> Assertions and Annotations</a></li><li class="chapter-item expanded "><a href="ch08-05-AnalysisofAlgorithms.html"><strong aria-hidden="true">8.5.</strong> Analysis of Algorithms</a></li><li class="chapter-item expanded "><a href="ch08-06-Exercises.html"><strong aria-hidden="true">8.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch08-07-Quiz.html"><strong aria-hidden="true">8.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-LinkedDataStructuresRecursion.html"><strong aria-hidden="true">9.</strong> Linked Data Structures and Recursion</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-Recursion.html"><strong aria-hidden="true">9.1.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="ch09-02-LinkedDataStructures.html"><strong aria-hidden="true">9.2.</strong> Linked Data Structures</a></li><li class="chapter-item expanded "><a href="ch09-03-StacksQueuesADTs.html"><strong aria-hidden="true">9.3.</strong> Stacks, Queues and ADTs</a></li><li class="chapter-item expanded "><a href="ch09-04-BinaryTrees.html"><strong aria-hidden="true">9.4.</strong> Binary Trees</a></li><li class="chapter-item expanded "><a href="ch09-05-SimpleRecursiveDescentParser.html"><strong aria-hidden="true">9.5.</strong> A Simple Recursive Descent Parser</a></li><li class="chapter-item expanded "><a href="ch09-06-Exercises.html"><strong aria-hidden="true">9.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch09-07-Quiz.html"><strong aria-hidden="true">9.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-GenericProgrammingandCollectionClasses.html"><strong aria-hidden="true">10.</strong> Generic Programmingand Collection Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-GenericProgramming.html"><strong aria-hidden="true">10.1.</strong> Generic Programming</a></li><li class="chapter-item expanded "><a href="ch10-02-ListsandSets.html"><strong aria-hidden="true">10.2.</strong> Lists and Sets</a></li><li class="chapter-item expanded "><a href="ch10-03-Maps.html"><strong aria-hidden="true">10.3.</strong> Maps</a></li><li class="chapter-item expanded "><a href="ch10-04-JCF.html"><strong aria-hidden="true">10.4.</strong> Programming with the JCF</a></li><li class="chapter-item expanded "><a href="ch10-05-WritingGenericClassesandMethods.html"><strong aria-hidden="true">10.5.</strong> Writing Generic Classes and Methods</a></li><li class="chapter-item expanded "><a href="ch10-06-StreamAPI.html"><strong aria-hidden="true">10.6.</strong> Stream APIs</a></li><li class="chapter-item expanded "><a href="ch10-07-Exercises.html"><strong aria-hidden="true">10.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch10-08-Quiz.html"><strong aria-hidden="true">10.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-IOStreamsFilesNetworking.html"><strong aria-hidden="true">11.</strong> I/O Streams, Files, and Networking</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-IOStreamsReadersAndWriters.html"><strong aria-hidden="true">11.1.</strong> I/O Streams, Readers, and Writers</a></li><li class="chapter-item expanded "><a href="ch11-02-Files.html"><strong aria-hidden="true">11.2.</strong> Files</a></li><li class="chapter-item expanded "><a href="ch11-03-ProgrammingWithFiles.html"><strong aria-hidden="true">11.3.</strong> Programming With Files</a></li><li class="chapter-item expanded "><a href="ch11-04-Networking.html"><strong aria-hidden="true">11.4.</strong> Networking</a></li><li class="chapter-item expanded "><a href="ch11-05-XML.html"><strong aria-hidden="true">11.5.</strong> A Brief Introduction to XML</a></li><li class="chapter-item expanded "><a href="ch11-06-Exercises.html"><strong aria-hidden="true">11.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch11-07-Quiz.html"><strong aria-hidden="true">11.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-ThreadsandMultiprocessing.html"><strong aria-hidden="true">12.</strong> Threads and Multiprocessing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-IntroductiontoThreads.html"><strong aria-hidden="true">12.1.</strong> Introduction to Threads</a></li><li class="chapter-item expanded "><a href="ch12-02-ProgrammingwithThreads.html"><strong aria-hidden="true">12.2.</strong> Programming with Threads</a></li><li class="chapter-item expanded "><a href="ch12-03-ThreadsandParallelProcessing.html"><strong aria-hidden="true">12.3.</strong> Threads and Parallel Processing</a></li><li class="chapter-item expanded "><a class="active" href="ch12-04-ThreadsandNetworking.html"><strong aria-hidden="true">12.4.</strong> Threads and Networking</a></li><li class="chapter-item expanded "><a href="ch12-05-NetworkProgrammingExample.html"><strong aria-hidden="true">12.5.</strong> Network Programming Example</a></li><li class="chapter-item expanded "><a href="ch12-06-Exercises.html"><strong aria-hidden="true">12.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch12-07-Quiz.html"><strong aria-hidden="true">12.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-GUIProgrammingContinued.html"><strong aria-hidden="true">13.</strong> GUI Programming Continued</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-PropertiesandBindings.html"><strong aria-hidden="true">13.1.</strong> Properties and Bindings</a></li><li class="chapter-item expanded "><a href="ch13-02-FancierGraphics.html"><strong aria-hidden="true">13.2.</strong> Fancier Graphics</a></li><li class="chapter-item expanded "><a href="ch13-03-ComplexComponentsandMVC.html"><strong aria-hidden="true">13.3.</strong> Complex Components and MVC</a></li><li class="chapter-item expanded "><a href="ch13-04-MostlyWindowsandDialogs.html"><strong aria-hidden="true">13.4.</strong> Mostly Windows and Dialogs</a></li><li class="chapter-item expanded "><a href="ch13-05-FinishingTouches.html"><strong aria-hidden="true">13.5.</strong> Finishing Touches</a></li><li class="chapter-item expanded "><a href="ch13-06-Exercises.html"><strong aria-hidden="true">13.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch13-07-Quiz.html"><strong aria-hidden="true">13.7.</strong> Quiz</a></li></ol><li class="chapter-item expanded "><a href="appendix-00.html"> Appendix</a></li><li class="chapter-item expanded "><a href="glossary-00.html"> Glossary</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="Java">Java</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Introduction to Programming Using Java</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Xayarsh/Java-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Threads and Networking"><a class="header" href="#Threads and Networking">Threads and Networking</a></h2>
                        <p>
                            In the previous chapter, we looked at several
                            examples of network programming.  Those examples showed how to create
                            network connections and communicate through them, but they didn't deal
                            with one of the fundamental characteristics of network programming,
                            the fact that network communication is asynchronous.
                            From the point of view of a program on one end of a network connection,
                            messages can arrive from the other side of the connection at any time;
                            the arrival of a message is an <i>event</i> that is not under the
                            control of the program that is receiving the message. Perhaps an
                            event-oriented networking API would be a good approach to dealing
                            with the asynchronous nature of network communication, but that is
                            not the approach that is taken in Java.
                            Instead, network programming in Java typically uses <b>threads</b>.</p>


                        <h3 id="The Blocking I/O Problem"><a class="header" href="#The Blocking I/O Problem">The Blocking I/O Problem</a></h3>


                        <p>As covered in <a href="ch11-04-Networking.html">Section&nbsp;11.4</a>, network programming uses
                            sockets.  A socket, in the sense that we are using the term here,
                            represents one end of a network connection.
                            Every socket has an associated input stream and output stream.
                            Data written to the output stream on one end of the connection is
                            transmitted over the network and appears in the input stream
                            at the other end.</p>


                        <p>A program that wants to read data from a socket's input stream
                            calls one of that input stream's input methods.  It is possible
                            that the data has already arrived before the input method is called;
                            in that case, the input method retrieves the data and returns
                            immediately.  More likely, however, the input method will have
                            to wait for data to arrive from the other side of the connection.
                            Until the data arrives, the input method and the thread that
                            called it will be blocked.</p>


                        <p>It is also possible for an output method in a socket's output
                            stream to block.  This can happen if the program tries to output
                            data to the socket faster than the data can be transmitted over
                            the network.  (It's a little complicated:  a socket uses a
                            "buffer" to hold data that is supposed to be transmitted over
                            the network.  A buffer is just a block of memory that is
                            used like a queue.  The output method drops its data
                            into the buffer; lower-level software removes data from
                            the buffer and transmits it over the network.  If the buffer fills up,
                            the output method will block until space becomes available in the buffer.  Note that when
                            the output method returns, it doesn't mean that the data
                            has gone out over the network&mdash;it just means that the
                            data has gone into the buffer and is scheduled for later
                            transmission.)</p>


                        <p>We say that network communication uses <span class="newword">blocking I/O</span>,
                            because input and output operations on the network can block for
                            indefinite periods of time.  Programs that use the network must
                            be prepared to deal with this blocking.  In some cases, it's
                            acceptable for a program to simply shut down all other processing
                            and wait for input.  (This is what happens when a command line program
                            reads input typed by the user.   User input is another type
                            of blocking I/O.)  However, threads make it possible for some
                            parts of a program to continue doing useful work while other
                            parts are blocked.  A network client program that sends requests
                            to a server might get by with a single thread, if it has nothing
                            else to do while waiting for the server's responses.
                            A network server program, on the other hand, can typically
                            be connected to several clients at the same time.  While waiting
                            for data to arrive from a client, the server certainly has other
                            things that it can do, namely communicate with other clients.
                            When a server uses different threads to handle the communication
                            with different clients, the fact that I/O with one client is
                            blocked won't stop the server from communicating with other clients.</p>


                        <p>It's important to understand that using threads to deal with
                            blocking I/O differs in a fundamental way from using threads to
                            speed up computation.  When using threads for speed-up in
                            <a href="ch12-03-ThreadsandParallelProcessing.html">Subsection&nbsp;12.3.2</a>, it made sense to use one thread
                            for each available processor.  If only one processor is available,
                            using more than one thread will yield no speed-up at all; in fact,
                            it would slow things down because of the extra overhead involved
                            in creating and managing the threads.</p>


                        <p>In the case of blocking I/O, on the other hand, it can make
                            sense to have many more threads than there are processors, since
                            at any given time many of the threads can be blocked.  Only
                            the active, unblocked threads are competing for processing time.
                            In the ideal case, to keep all the processors busy, you would
                            want to have one <b>active</b> thread per processor (actually
                            somewhat less than that, on average, to allow for variations
                            over time in the number of active threads).
                            On a network server program, for example, threads generally
                            spend <b>most</b> of their time blocked waiting for I/O operations
                            to complete.  If threads are blocked, say, about 90% of the time,
                            you'd like to have about ten times as many threads as there
                            are processors.  So even on a computer that has just a single
                            processor, server programs can make good use of large numbers
                            of threads.</p>



                        <h3 id="An Asynchronous Network Chat Program"><a class="header" href="#An Asynchronous Network Chat Program">An Asynchronous Network Chat Program</a></h3>

                        <p>As a first example of using threads for network communication,
                            we consider a GUI chat program.</p>


                        <p>The command-line chat programs, <span class="sourceref"><a href="./source/chapter11/CLChatClient.java">CLChatClient.java</a></span> and
                            <span class="sourceref"><a href="./source/chapter11/CLChatServer.java">CLChatServer.java</a></span>, from <a href="ch11-04-Networking.html">Subsection&nbsp;11.4.5</a>
                            use a straight-through, step-by-step protocol for communication.
                            After a user on one side of a connection enters a message,
                            the user must wait for a reply from the other side of the connection.
                            An asynchronous chat program would be much nicer.  In such a program,
                            a user could just keep typing lines and sending messages without waiting
                            for any response.  Messages that arrive&mdash;asynchronously&mdash;from the
                            other side would be displayed as soon as they arrive.  It's not easy to do this
                            in a command-line interface, but it's a natural application for a graphical user
                            interface.  The basic idea for a GUI chat program is to create a
                            thread whose job is to read messages that arrive from the other side
                            of the connection.  As soon as the message arrives, it is displayed to
                            the user; then, the message-reading thread blocks until the next incoming
                            message arrives.  While it is blocked, however, other threads can continue
                            to run.  In particular, the event-handling thread that responds to
                            user actions keeps running; that thread can send outgoing messages
                            as soon as the user generates them.</p>


                        <p>The <span class="code">GUIChat</span> program can act as either the client end or the server end
                            of a connection. (Refer back to <a href="ch11-04-Networking.html">Subsection&nbsp;11.4.3</a> for information about how clients
                            and servers work.) The program has a "Listen on port" button that the user can click to create a server socket
                            that will listen for an incoming connection request; this makes the program act
                            as a server.  It also has a "Connect" button that the user can click to send
                            a connection request; this makes the program act as a client.  As usual, the server
                            listens on a specified port number. The client needs to know the computer on which the
                            server is running and the port on which the server is listening.  There are
                            input boxes in the <span class="code">GUIChat</span> window where the user can enter this
                            information.</p>


                        <p>Once a connection has been established between two <span class="code">GUIChat</span>
                            windows, each user can send messages to the other.  The window has an input box
                            where the user types a message.  Pressing return
                            sends the message.  This means that the sending of the message is handled by the
                            usual event-handling thread, in response to an event generated by a user action.
                            Messages are received by a separate thread that just sits around waiting for
                            incoming messages.  This thread blocks while waiting for a message to arrive;
                            when a message does arrive, it displays that message to the user.  The window
                            contains a large transcript area that displays both incoming and outgoing
                            messages, along with other information about the network connection.</p>


                        <p>I urge you to compile the source code, <span class="sourceref"><a href="./source/chapter12/GUIChat.java">GUIChat.java</a></span>, and
                            try the program.  To try it on single computer,
                            you can run two copies of the program on  that computer, and
                            make a connection between one program window and the other program window,
                            using "localhost" or "127.0.0.1" as the name of the computer. I also urge you to read the source code.
                            I will discuss only parts of it here.</p>


                        <p>The program uses a nested class, <span class="classname">ConnectionHandler</span>,
                            to handle most network-related tasks.  <span class="classname">ConnectionHandler</span>
                            is a subclass of <span class="classname">Thread</span>.  The <span class="classname">ConnectionHandler</span>
                            thread is responsible for opening the network connection and then for reading
                            incoming messages once the connection has been opened.  By putting the connection-opening
                            code in a separate thread,
                            we make sure that the GUI is not blocked while the connection is being opened.
                            (Like reading incoming messages, opening a connection is a blocking operation
                            that can take some time to complete.)  The <span class="classname">ConnectionHandler</span>
                            handles opening the connection both when the program acts as a server and
                            when it acts as a client.  The thread is created
                            when the user clicks either the "Listen" button or the "Connect" button.  The "Listen" button
                            makes the thread act as a server, while "Connect" makes it act as
                            a client.  To distinguish these two cases, the <span class="classname">ConnectionHandler</span>
                            class has the two constructors that are shown below. Note that the <span class="code">postMessage()</span> method posts
                            a message to the transcript area of the window, where it will be visible
                            to the user:</p>


                        <pre><code class="java">/**
 * Listen for a connection on a specified port.  The constructor
 * does not perform any network operations; it just sets some
 * instance variables and starts the thread.  Note that the
 * thread will only listen for one connection, and then will
 * close its server socket.
 */
ConnectionHandler(int port) {  // For acting as the "server."
   state = ConnectionState.LISTENING;
   this.port = port;
   postMessage("\nLISTENING ON PORT " + port + "\n");
   try { setDaemon(true); }
   catch (Exception e) {}
   start();
}

/**
 * Open a connection to a specified computer and port.  The constructor
 * does not perform any network operations; it just sets some
 * instance variables and starts the thread.
 */
ConnectionHandler(String remoteHost, int port) {  // For acting as "client."
   state = ConnectionState.CONNECTING;
   this.remoteHost = remoteHost;
   this.port = port;
   postMessage("\nCONNECTING TO " + remoteHost + " ON PORT " + port + "\n");
   try { setDaemon(true); }
   catch (Exception e) {}
   start();
}</code></pre>


                        <p>Here, <span class="code">state</span> is an instance variable whose type is defined by
                            an enumerated type:</p>


                        <pre><code class="java">enum ConnectionState { LISTENING, CONNECTING, CONNECTED, CLOSED };</code></pre>


                        <p>The values of this <span class="code">enum</span> represent different possible states
                            of the network connection.  It is often useful to treat a network connection
                            as a state machine (see <a href="ch06-03-BasicEvents.html">Subsection&nbsp;6.3.6</a>), since the response to various
                            events can depend on the state of the connection when the event occurs.
                            Setting the <span class="code">state</span> variable to <span class="code">LISTENING</span> or
                            <span class="code">CONNECTING</span> tells the thread whether to act as a server or as a client
                            when setting up the connection.</p>


                        <p>Once the thread has been started, it executes the following <span class="code">run()</span>
                            method:</p>


                        <pre><code class="java">/**
 * The run() method that is executed by the thread.  It opens a
 * connection as a client or as a server (depending on which
 * constructor was used).
 */
public void run() {
   try {
      if (state == ConnectionState.LISTENING) {
            // Open a connection as a server.
         listener = new ServerSocket(port);
         socket = listener.accept();
         listener.close();
      }
      else if (state == ConnectionState.CONNECTING) {
            // Open a connection as a client.
         socket = new Socket(remoteHost,port);
      }
      connectionOpened();  // Sets up to use the connection (including
                           // creating a BufferedReader, in, for reading
                           // incoming messages).
      while (state == ConnectionState.CONNECTED) {
            // Read one line of text from the other side of
            // the connection, and report it to the user.
         String input = in.readLine();
         if (input == null)
            connectionClosedFromOtherSide(); // Close socket and report to user.
         else
            received(input);  // Report message to user.
      }
   }
   catch (Exception e) {
         // An error occurred.  Report it to the user, but not
         // if the connection has been closed (since the error
         // might be the expected error that is generated when
         // a socket is closed).
      if (state != ConnectionState.CLOSED)
         postMessage("\n\n ERROR:  " + e);
   }
   finally {  // Clean up before terminating the thread.
      cleanUp();
   }
}</code></pre>


                        <p>This method calls several other methods to do some of its work, but
                            you can see the general outline of how it works.  After opening the
                            connection as either a server or client, the <span class="code">run()</span> method enters
                            a <span class="code">while</span> loop in which it receives and processes messages from
                            the other side of the connection until the connection is closed. It is
                            important to understand how the connection can be closed.  The <span class="code">GUIChat</span>
                            window has a "Disconnect" button that the user can click to close the connection.
                            The program responds to this event by closing the socket that represents
                            the connection and by setting the connection state to <span class="code">CLOSED</span>.
                            It is likely that when this happens, the connection-handling
                            thread is blocked in the <span class="code">in.readLine()</span> method, waiting for an incoming
                            message.  When the socket is closed by the GUI thread, this method will fail and
                            will throw an exception; this exception causes the thread to terminate.
                            (If the connection-handling thread happens to be between calls to <span class="code">in.readLine()</span>
                            when the socket is closed, the <span class="code">while</span> loop will terminate because
                            the connection state changes from <span class="code">CONNECTED</span> to <span class="code">CLOSED</span>.)
                            Note that closing the window will also close the connection in the same way.</p>


                        <p>It is also possible for the user on the other side of the connection to close
                            the connection.  When that happens, the stream of incoming messages ends,
                            and the <span class="code">in.readLine()</span> on this side of the connection
                            returns the value <span class="code">null</span>, which indicates end-of-stream and acts
                            as a signal that the connection has been closed by the remote user.</p>


                        <p>For a final look into the <span class="code">GUIChat</span> code, consider the methods
                            that send and receive messages.  These methods are called from different
                            threads.  The <span class="code">send()</span> method is called <i>by the event-handling
                                thread</i> in response to a user action.  Its purpose is to transmit a
                            message to the remote user.  (It is conceivable, though not likely, that
                            the data output operation could block, if the socket's output buffer fills up.  A more
                            sophisticated program might take this possibility into account by using another
                            thread to transmit outgoing messages.)
                            The <span class="code">send()</span> method uses a <span class="classname">PrintWriter</span>,
                            <span class="code">out</span>, that writes to the socket's output stream.
                            Synchronization of this method prevents
                            the connection state from changing in the middle of the send operation:</p>


                        <pre><code class="java">/**
 * Send a message to the other side of the connection, and post the
 * message to the transcript.  This should only be called when the
 * connection state is ConnectionState.CONNECTED; if it is called at
 * other times, it is ignored.
 */
synchronized void send(String message) {
   if (state == ConnectionState.CONNECTED) {
      postMessage("SEND:  " + message);
      out.println(message);
      out.flush();
      if (out.checkError()) {
         postMessage("\nERROR OCCURRED WHILE TRYING TO SEND DATA.");
         close();  // Closes the connection.
      }
   }
}</code></pre>


                        <p>The <span class="code">received()</span> method is called <i>by the connection-handling
                            thread</i> after a message
                            has been read from the remote user.  Its only job is to display the
                            message to the user, but again it is synchronized to avoid the race
                            condition that could occur if the connection state were changed by
                            another thread while this method is being executed:</p>


                        <pre><code class="java">/**
 * This is called by the run() method when a message is received from
 * the other side of the connection.  The message is posted to the
 * transcript, but only if the connection state is CONNECTED.  (This
 * is because a message might be received after the user has clicked
 * the "Disconnect" button; that message should not be seen by the
 * user.)
 */
synchronized private void received(String message) {
   if (state == ConnectionState.CONNECTED)
      postMessage("RECEIVE:  " + message);
}</code></pre>




                        <h3 id="A Threaded Network Server"><a class="header" href="#A Threaded Network Server">A Threaded Network Server</a></h3>

                        <p>Threads are often used in network server programs.  They
                            allow the server to deal with several clients at the same time.  When a
                            client can stay connected for an extended period of time, other clients
                            shouldn't have to wait for service.
                            Even if the interaction with each client is expected to be very brief,
                            you can't always assume that that will be the case.  You have to
                            allow for the possibility of a misbehaving client&mdash;one
                            that stays connected without sending data that the server expects.
                            This can hang up a thread indefinitely, but in a threaded server there
                            will be other threads that can carry on with other clients.</p>


                        <p>The <span class="sourceref"><a href="./source/chapter11/DateServer.java">DateServer.java</a></span> sample program, from
                            <a href="ch11-04-Networking.html">Subsection&nbsp;11.4.4</a>, is an extremely simple network server program.
                            It does not use threads, so the server must finish with one client
                            before it can accept a connection from another client.  Let's see
                            how we can turn <span class="code">DateServer</span> into a threaded server.
                            (This server is so simple that doing so doesn't make a great deal
                            of sense.  However, the same techniques will work for more complicated
                            servers.  See, for example, <a href="ch12-06-Exercises.html">Exercise&nbsp;12.5</a>.  Also note that
                            the client program, <span class="sourceref"><a href="./source/chapter11/DateClient.java">DateClient.java</a></span>,
                            which implements a client for the date server, does not need to use threads,
                            since the client only uses one connection.  The original client program
                            will work with the new versions of the server.)</p>


                        <p>As a first attempt, consider <span class="sourceref"><a href="./source/chapter12/DateServerWithThreads.java">DateServerWithThreads.java</a></span>.
                            This sample program creates a new thread every time a connection request
                            is received, instead of handling the connection itself by calling a subroutine.
                            The main program simply creates the thread and hands the
                            connection to the thread.  This takes very little time, and in particular
                            will not block.  The <span class="code">run()</span> method of the thread handles the
                            connection in exactly the same way that it would be handled by the
                            original program.  This is not at all difficult to program.  Here's
                            the new version of the program, with significant changes shown in red.
                            Note again that the constructor for the connection thread does very little and in particular
                            cannot block; this is very important since the constructor runs in the main thread:</p>



                        <pre><code class="java">import java.net.*;
import java.io.*;
import java.util.Date;

/**
 * This program is a server that takes connection requests on
 * the port specified by the constant LISTENING_PORT.  When a
 * connection is opened, the program sends the current time to
 * the connected socket.  The program will continue to receive
 * and process connections until it is killed (by a CONTROL-C,
 * for example).
 *
 <span class="newcode">* This version of the program creates a new thread for
 * every connection request.</span>
 */
public class DateServerWithThreads {

    public static final int LISTENING_PORT = 32007;

    public static void main(String[] args) {

        ServerSocket listener;  // Listens for incoming connections.
        Socket connection;      // For communication with the connecting program.

        /* Accept and process connections forever, or until some error occurs. */

        try {
            listener = new ServerSocket(LISTENING_PORT);
            System.out.println("Listening on port " + LISTENING_PORT);
            while (true) {
                // Accept next connection request and <span class="newcode">create a thread to</span> handle it.
                connection = listener.accept();
                <span class="newcode">ConnectionHandler handler = new ConnectionHandler(connection);
                handler.start();</span>
            }
        }
        catch (Exception e) {
            System.out.println("Sorry, the server has shut down.");
            System.out.println("Error:  " + e);
            return;
        }

    }  // end main()


    <span class="newcode">/**
     *  Defines a thread that handles the connection with one
     *  client.
     */
    private static class ConnectionHandler extends Thread {
        Socket client; // The connection to the client.
        ConnectionHandler(Socket socket) {
            client = socket;
        }
        public void run()</span> {
                 // (code copied from the original DateServer program)
            String clientAddress = client.getInetAddress().toString();
            try {
                System.out.println("Connection from " + clientAddress );
                Date now = new Date();  // The current date and time.
                PrintWriter outgoing;   // Stream for sending data.
                outgoing = new PrintWriter( client.getOutputStream() );
                outgoing.println( now.toString() );
                outgoing.flush();  // Make sure the data is actually sent!
                client.close();
            }
            catch (Exception e){
                <span class="newcode">System.out.println("Error on connection with: "
                        + clientAddress + ": " + e);</span>
            }
        }
    <span class="newcode">}</span>


} //end class DateServerWithThreads</code></pre>


                        <p>One interesting change is at the end of the <span class="code">run()</span> method, where
                            I've added the <span class="code">clientAddress</span> to the output of the error message.
                            I did this to identify which connection the error message refers to.
                            Since threads run in parallel, it's possible for outputs from different
                            threads to be intermingled in various orders. Messages from
                            the same thread don't necessarily come together in the output; they might
                            be separated by messages from other threads.  This is just one of the
                            complications that you have to keep in mind when working with threads!
                        </p>



                        <h3 id="Using a Thread Pool"><a class="header" href="#Using a Thread Pool">Using a Thread Pool</a></h3>

                        <p>It's not very efficient to create a new thread for every
                            connection, especially when the connections are typically very
                            short-lived.  Fortunately, we have an alternative: thread
                            pools (<a href="ch12-03-ThreadsandParallelProcessing.html">Subsection&nbsp;12.3.2</a>).</p>


                        <p>
                            <span class="sourceref"><a href="./source/chapter12/DateServerWithThreadPool.java">DateServerWithThreadPool.java</a></span> is an improved
                            version of our server that uses a thread pool.  Each thread in the
                            pool runs in an infinite loop.  Each time through the loop, it handles
                            one connection.  We need a way for the main program to send
                            connections to the threads.  It's natural to use a blocking
                            queue (<a href="ch12-03-ThreadsandParallelProcessing.html">Subsection&nbsp;12.3.3</a>) named <span class="code">connectionQueue</span> for that purpose.
                            A&nbsp;connection-handling thread takes connections from this queue.
                            Since it is a blocking queue, the thread blocks when the queue is
                            empty and wakes up when a connection becomes available in the
                            queue.  No other synchronization or communication technique is
                            needed; it's all built into the blocking queue.  Here is
                            the <span class="code">run()</span> method for the connection-handling threads:</p>


                        <pre><code class="java">public void run() {
    while (true) {
        Socket client;
        try {
            client = connectionQueue.take();  // Blocks until item is available.
        }
        catch (InterruptedException e) {
            continue; // (If interrupted, just go back to start of while loop.)
        }
        String clientAddress = client.getInetAddress().toString();
        try {
            System.out.println("Connection from " + clientAddress );
            System.out.println("Handled by thread " + this);
            Date now = new Date();  // The current date and time.
            PrintWriter outgoing;   // Stream for sending data.
            outgoing = new PrintWriter( client.getOutputStream() );
            outgoing.println( now.toString() );
            outgoing.flush();  // Make sure the data is actually sent!
            client.close();
        }
        catch (Exception e){
            System.out.println("Error on connection with: "
                    + clientAddress + ": " + e);
        }
    }
}</code></pre>


                        <p>The main program, in the meantime, runs in an infinite loop in which
                            connections are accepted and added to the queue:</p>


                        <pre><code class="java">while (true) {
        // Accept next connection request and put it in the queue.
    connection = listener.accept();
    try {
        connectionQueue.put(connection); // Blocks if queue is full.
    }
    catch (InterruptedException e) {
    }
}</code></pre>


                        <p>The queue in this program is of type <span class="classname">ArrayBlockingQueue&lt;Socket&gt;</span>.
                            As such, it has a limited capacity, and the <span class="code">put()</span> operation on the
                            queue will block if the queue is full.  But wait&mdash;didn't we want to avoid blocking
                            the main program?  When the main program is blocked, the server is no longer accepting
                            connections, and clients who are trying to connect are kept waiting.
                            Would it be better to use a <span class="classname">LinkedBlockingQueue</span>, with
                            an unlimited capacity?</p>


                        <p>In fact, connections in the blocking queue are waiting anyway; they are not being
                            serviced.  If the queue grows unreasonably long, connections in the queue will
                            have to wait for an unreasonable amount of time.  If the queue keeps growing
                            indefinitely, that just means that the server is receiving connection requests
                            faster than it can process them.  That could happen for several reasons:
                            Your server might simply not be powerful enough to handle the volume of traffic
                            that you are getting; you need to buy a new server.  Or perhaps the thread pool
                            doesn't have enough threads to fully utilize your server; you should
                            increase the size of the thread pool to match the server's capabilities.
                            Or maybe your server is under a "Denial Of Service" attack, in which some bad guy
                            is deliberately sending your server more requests than it can handle in an attempt
                            to keep other, legitimate clients from getting service.</p>


                        <p>In any case, <span class="classname">ArrayBlockingQueue</span> with limited capacity
                            is the correct choice.  The queue should be short enough so that connections
                            in the queue will not have to wait too long for service.
                            In a real server, the size of the queue and the number
                            of threads in the thread pool should be adjusted to "tune" the server to account
                            for the particular hardware and network on which the server is running and for
                            the nature of the client requests that it typically processes.  Optimal tuning is,
                            in general, a difficult problem.</p>


                        <p>There is, by the way, another way that things can go wrong:
                            Suppose that the server needs to read some data from the client, but
                            the client doesn't send any data.  The thread that is trying
                            to read the data can then block indefinitely, waiting for the input.  If a thread pool is
                            being used, this could happen to every thread in the pool.  In that
                            case, no further processing can ever take place!  The solution to
                            this problem is to have connections "time out" if they are inactive for
                            an excessive period of time.  Typically, each connection thread will
                            keep track of the time when it last received data from the client.
                            The server runs another thread (sometimes called a "reaper thread",
                            after the Grim Reaper) that wakes up periodically and checks each
                            connection thread to see how long it has been inactive.  A connection
                            thread that has been waiting too long for input is terminated, and
                            a new thread is started in its place.  The question of how long
                            the timeout period should be is another difficult tuning issue.</p>

                        <h3 id="Distributed Computing"><a class="header" href="#Distributed Computing">Distributed Computing</a></h3>

                        <p>We have seen how threads can be used to
                            do parallel processing, where a number of processors work together to complete
                            some task.  So far, we have assumed that all the processors were
                            inside one multi-processor computer.  But parallel processing can also
                            be done using processors that are in different computers, as long as those
                            computers are connected to a network over which they can communicate.
                            This type of parallel processing&mdash;in which a number of computers
                            work together on a task and communicate over a network&mdash;is called
                            <span class="newword">distributed computing</span>.</p>


                        <p>In some sense, the whole Internet is an immense distributed computation,
                            but here I am interested in how computers on a network can cooperate to
                            solve some computational problem.  There are several approaches that can be used
                            for distributed computing in Java. One general technique that is a
                            a standard part of Java is <span class="newword">RMI</span> (Remote Method Invocation).
                            RMI enables a program running
                            on one computer to call methods in objects that exist on other computers.
                            This makes it possible to design an object-oriented program in which
                            different parts of the program are executed on different computers.
                            As is commonly
                            the case in networking, there is the problem of locating services (where
                            in this case, a "service" means an object that is available to be called
                            over the network).  That is, how can one computer know which computer a service is located
                            on and what port it is listening on?  RMI solves this problem
                            using a "request broker"&mdash;a
                            server program running at a known location that keeps a list of services that are
                            available on other computers.  Computers that offer services register
                            those services with the request broker; computers that need services must know
                            the location of the broker, and they contact it
                            to find out what services are available and where they are located.</p>


                        <p>RMI is a complex system that is not very easy to use.  I mention
                            it here because they are part of Java's standard network API, but I will not discuss
                            it further.  Instead, we will look at a relatively simple demonstration of
                            distributed computing that uses only basic networking.</p>


                        <p>The problem that we will consider is the same one that was used
                            in <a href="ch12-02-ProgrammingwithThreads.html">Section&nbsp;12.2</a> and <a href="ch12-03-ThreadsandParallelProcessing.html">Section&nbsp;12.3</a>
                            for <span class="sourceref"><a href="./source/chapter12/MultiprocessingDemo1.java">MultiprocessingDemo1.java</a></span> and its variations, namely the
                            computation of a complex image.  In this case, however, the program is not
                            a GUI program and the image is not shown on the screen.  The computation is one that
                            uses the simplest type of parallel programming, in which
                            the problem can be broken down into tasks that can be performed independently,
                            with no communication between the tasks.  To apply distributed computing to
                            this type of problem, we can use one "master" program that divides the problem
                            into tasks and sends those tasks over the network to "worker" programs
                            that do the actual work.  The worker programs send their results back to
                            the master program, which combines the results from all the tasks into
                            a solution of the overall problem.  In this context, the worker programs
                            are often called "slaves," and the program uses the so-called
                            <span class="newword">master/slave</span> approach to distributed computing.</p>


                        <p>The demonstration program is defined by three source code files:
                            <span class="sourceref"><a href="./source/chapter12/CLMandelbrotMaster.java">CLMandelbrotMaster.java</a></span> defines the master program;
                            <span class="sourceref"><a href="./source/chapter12/CLMandelbrotWorker.java">CLMandelbrotWorker.java</a></span> defines the worker programs;
                            and <span class="sourceref"><a href="./source/chapter12/CLMandelbrotTask.java">CLMandelbrotTask.java</a></span> defines the class that represents
                            the individual tasks that are performed by the workers.  The master divides
                            the overall problem into a collection of tasks; it distributes
                            those tasks to the workers that will execute the tasks and send the
                            results back to the master; and the master applies the results from all
                            the individual tasks to the overall problem.</p>


                        <p>To run the
                            demonstration, you must first start the <span class="code">CLMandelbrotWorker</span>
                            program on several computers (probably by running it on the command line).
                            This program uses <span class="classname">CLMandelbrotTask</span>,
                            so both class files, <span class="code">CLMandelbrotWorker.class</span>
                            and <span class="code">CLMandelbrotTask.class</span>, must be present on the worker
                            computers.  You can then run <span class="code">CLMandelbrotMaster</span> on
                            the master computer.  Note that the master program also requires the
                            class <span class="classname">CLMandelbrotTask</span>.
                            You must specify the host name or IP address
                            of each of the worker computers as command line arguments for
                            <span class="code">CLMandelbrotMaster</span>.  The worker programs listen for
                            connection requests from the master program, and the master
                            program must be told where to send those requests.
                            For example, if the worker
                            program is running on three computers with IP addresses
                            172.21.7.101, 172.21.7.102, and 172.21.7.103, then you
                            can run <span class="code">CLMandelbrotMaster</span> with the command
                        </p>


                        <pre><code class="java">java  CLMandelbrotMaster  172.21.7.101  172.21.7.102  172.21.7.103</code></pre>


                        <p>The master will make a network connection to the worker at each IP
                            address; these connections will be used for communication between the master
                            program and the workers.</p>


                        <p>It is possible to run several copies of <span class="code">CLMandelbrotWorker</span> on
                            the same computer, but they must listen for network connections on different
                            ports.  It is also possible to run <span class="code">CLMandelbrotWorker</span> on
                            the same computer as <span class="code">CLMandelbrotMaster</span>.  You might even see some
                            speed-up when you do this, if your computer has several processors. See the
                            comments in the program source code files for more information, but here are
                            some commands that you can use to run the master program and two copies of the worker
                            program on the same computer.  Give these commands in separate command windows:</p>


                        <pre><code class="java">java  CLMandelbrotWorker                             (Listens on default port)

java  CLMandelbrotWorker  2501                       (Listens on port 2501)

java  CLMandelbrotMaster  localhost  localhost:2501</code></pre>


                        <p>Every time <span class="code">CLMandelbrotMaster</span> is run, it solves exactly
                            the same problem.  (For this demonstration, the nature of the problem is not
                            important, but the problem is to compute the data needed for a picture
                            of a small piece of the famous "Mandelbrot Set."  If you are interested in
                            seeing the picture that is produced, uncomment the call to the <span class="code">saveImage()</span>
                            method at the end of the <span class="code">main()</span> routine in <span class="sourceref"><a href="./source/chapter12/CLMandelbrotMaster.java">CLMandelbrotMaster.java</a></span>.)</p>


                        <p>You can run <span class="code">CLMandelbrotMaster</span> with different numbers of worker programs
                            to see how the time required to solve the problem depends on the number of workers.
                            (Note that the worker programs continue to run after the master program exits,
                            so you can run the master program several times without having to restart the workers.)
                            In addition, if you run <span class="code">CLMandelbrotMaster</span> with no command line
                            arguments, it will solve the entire problem on its own, so you can see how long
                            it takes to do so without using distributed computing.  In a trial that I
                            ran on some very old, slow computers, it took 40 seconds for <span class="code">CLMandelbrotMaster</span> to solve the
                            problem on its own.  Using just one worker, it took 43 seconds.  The extra
                            time represents extra work involved in using the network; it takes time to
                            set up a network connection and to send messages over the network.  Using
                            two workers (on different computers), the problem was solved in 22 seconds.  In this case, each worker
                            did about half of the work, and their computations were performed in parallel,
                            so that the job was done in about half the time.  With larger numbers of
                            workers, the time continued to decrease, but only up to a point.  The master
                            program itself has a certain amount of work to do, no matter how many
                            workers there are, and the total time to solve the problem can never be
                            less than the time it takes for the master program to do its part.  In this
                            case, the minimum time seemed to be about five seconds.</p>





                        <p>Let's take a look at how this distributed application is programmed.
                            The master program divides the overall problem into a set of tasks.
                            Each task is represented by an object of type <span class="classname">CLMandelbrotTask</span>.
                            These tasks have to be communicated to the worker programs, and the worker
                            programs must send back their results.  Some protocol is needed for this
                            communication.  I decided to use character streams.  The master
                            encodes a task as a line of text, which is sent to a worker.  The worker
                            decodes the text (into an object of type <span class="classname">CLMandelbrotTask</span>)
                            to find out what task it is supposed to perform.
                            It performs the assigned task.  It encodes the results as another line of
                            text, which it sends back to the master program.  Finally, the master decodes
                            the results and combines them with the results from other tasks.  After
                            all the tasks have been completed and their results have been combined,
                            the problem has been solved.</p>


                        <p>A <span class="code">CLMandelbrotWorker</span> receives
                            not just one task, but a sequence of tasks.  Each time it finishes a task and
                            sends back the result, it is assigned a new task.  After all tasks are completed,
                            the worker receives a "close" command that tells it to close the connection.
                            In <span class="sourceref"><a href="./source/chapter12/CLMandelbrotWorker.java">CLMandelbrotWorker.java</a></span>, all this is done in
                            a method named <span class="code">handleConnection()</span> that is called to handle
                            a connection that has already been opened to the master program.  It uses
                            a method <span class="code">readTask()</span> to decode a task that it receives from
                            the master and a method <span class="code">writeResults()</span> to encode the results
                            of the task for transmission back to the master.  It must also handle
                            any errors that occur:</p>


                        <pre><code class="java">private static void handleConnection(Socket connection) {
   try {
      BufferedReader in = new BufferedReader(
                new InputStreamReader( connection.getInputStream()) );
      PrintWriter out = new PrintWriter(connection.getOutputStream());
      while (true) {
         String line = in.readLine();  // Message from the master.
         if (line == null) {
               // End-of-stream encountered -- should not happen.
            throw new Exception("Connection closed unexpectedly.");
         }
         if (line.startsWith(CLOSE_CONNECTION_COMMAND)) {
               // Represents the normal termination of the connection.
            System.out.println("Received close command.");
            break;
         }
         else if (line.startsWith(TASK_COMMAND)) {
               // Represents a CLMandelbrotTask that this worker is
               // supposed to perform.
            CLMandelbrotTask task = readTask(line);  // Decode the message.
            task.compute();  // Perform the task.
            out.println(writeResults(task));  //  Send back the results.
            out.flush();  // Make sure data is sent promptly!
         }
         else {
               // No other messages are part of the protocol.
            throw new Exception("Illegal command received.");
         }
      }
   }
   catch (Exception e) {
      System.out.println("Client connection closed with error " + e);
   }
   finally {
      try {
         connection.close();  // Make sure the socket is closed.
      }
      catch (Exception e) {
      }
   }
}</code></pre>


                        <p>Note that this method is <b>not</b> executed in a separate thread.  The
                            worker has only one thing to do at a time and does not need to be multithreaded.
                        </p>



                        <p>Turning to the master program, <span class="sourceref"><a href="./source/chapter12/CLMandelbrotMaster.java">CLMandelbrotMaster.java</a></span>,
                            we encounter a more complex situation.  The master program must communicate
                            with several workers over several network connections.  To accomplish this,
                            the master program is multi-threaded, with one thread to manage communication
                            with each worker.  A pseudocode outline of the <span class="code">main()</span> routine
                            is quite simple:</p>


                        <pre><code class="java">create the tasks that must be performed and add them to a queue
if there are no command line arguments {
      // The master program does all the tasks itself.
   Remove each task from the queue and perform it.
}
else {
      // The tasks will be performed by worker programs.
   for each command line argument:
      Get information about a worker from command line argument.
      Create and start a thread to send tasks to workers.
   Wait for all threads to terminate.
}
// All tasks are now complete (assuming no error occurred).</code></pre>


                        <p>The tasks are put into a variable of type
                            <span class="classname">ConcurrentBlockingQueue&lt;CLMandelbrotTask&gt;</span> named <span class="code">tasks</span>
                            (see <a href="ch12-03-ThreadsandParallelProcessing.html">Subsection&nbsp;12.3.2</a>.) The
                            communication threads take tasks from this queue and send them
                            to worker programs.  The method <span class="code">tasks.poll()</span> is used to remove
                            a task from the queue.  If the queue is empty, it returns
                            <span class="code">null</span>, which acts as a signal that all tasks have
                            been assigned and the communication thread can terminate.</p>


                        <p>The job of a thread is to send a sequence of tasks to a worker
                            thread and to receive the results that the worker sends back.  The thread
                            is also responsible for opening the connection in the first place.  A
                            pseudocode outline for the process executed by the thread might
                            look like:</p>


                        <pre><code class="java">Create a socket connected to the worker program.
Create input and output streams for communicating with the worker.
while (true) {
   Let task = tasks.poll().
   If task == null
      break;  // All tasks have been assigned.
   Encode the task into a message and transmit it to the worker.
   Read the response from the worker.
   Decode and process the response.
}
Send a "close" command to the worker.
Close the socket.</code></pre>


                        <p>This would work OK.  However, there are a few subtle points.  First of
                            all, the thread must be ready to deal with a network error.  For example,
                            a worker might shut down unexpectedly. But if that happens, the master
                            program can continue, provided other workers are still available.
                            (You can try this when you run the program:  Stop one of the
                            worker programs, with <span class="code">CONTROL-C</span>, and observe that the
                            master program still completes successfully.)  A difficulty arises
                            if an error occurs while the thread is working on a task:  If the
                            problem as a whole is going to be completed, that task will have
                            to be reassigned to another worker.  I take care of this by putting
                            the uncompleted task back into the task list.  (Unfortunately, my
                            program does not handle all possible errors.  If the last worker thread
                            fails, there will be no one left to take over the uncompleted task.
                            Also, if a network connection
                            "hangs" indefinitely without actually generating an error, my program
                            will also hang, waiting for a response from a worker that will never
                            arrive.  A more robust program would have some way of detecting
                            the problem and reassigning the task.)</p>


                        <p>Another defect in the procedure outlined above is that it leaves
                            the worker program idle while the thread in the master program is processing the
                            worker's response.  It would be nice to get a new task to the
                            worker before processing the response from the previous task.
                            This would keep the worker busy and allow two operations to
                            proceed simultaneously instead of sequentially.  (In this example,
                            the time it takes to process a response is so short that keeping
                            the worker waiting while it is done probably makes no significant
                            difference.  But as a general principle, it's desirable to have
                            as much parallelism as possible in the algorithm.)  We can modify
                            the procedure to take this into account:</p>


                        <pre><code class="java">try {
   Create a socket connected to the worker program.
   Create input and output streams for communicating with the worker.
   Let currentTask = tasks.poll()
   if (currentTask != null)
      Encode currentTask into a message and send it to the worker.
   while (currentTask != null) {
      Read the response from the worker.
      Let nextTask = tasks.poll().
      If nextTask != null {
            // Send nextTask to the worker before processing the
            // response to currentTask.
         Encode nextTask into a message and send it to the worker.
      }
      Decode and process the response to currentTask.
      currentTask = nextTask.
   }
   Send a "close" command to the worker.
   Close the socket.
}
catch (Exception e) {
   Put uncompleted task, if any, back into the task queue.
}
finally {
   Close the connection.
}</code></pre>


                        <p>To see how this all translates into Java, check out the
                            <span class="classname">WorkerConnection</span> nested class in
                            <span class="sourceref"><a href="./source/chapter12/CLMandelbrotMaster.java">CLMandelbrotMaster.java</a></span>
                        </p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch12-03-ThreadsandParallelProcessing.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch12-05-NetworkProgrammingExample.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch12-03-ThreadsandParallelProcessing.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch12-05-NetworkProgrammingExample.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </body>
</html>
