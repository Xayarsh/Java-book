<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>A Brief Introduction to XML - Introduction to Programming Using Java</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

<link rel="stylesheet" href="code-class.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html" >Introduction to Programming Using Java</a></li><li class="chapter-item expanded affix "><a href="preface.html">Preface</a></li><li class="chapter-item expanded "><a href="ch01-00-Overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-FetchExecuteCycle.html"><strong aria-hidden="true">1.1.</strong> Fetch and Execute Cycle</a></li><li class="chapter-item expanded "><a href="ch01-02-AsynchronousEvents.html"><strong aria-hidden="true">1.2.</strong> Asynchronous Events</a></li><li class="chapter-item expanded "><a href="ch01-03-JavaVirtualMachine.html"><strong aria-hidden="true">1.3.</strong> The Java Virtual Machine</a></li><li class="chapter-item expanded "><a href="ch01-04-FundamentalBuildingBlocks.html"><strong aria-hidden="true">1.4.</strong> Fundamentals</a></li><li class="chapter-item expanded "><a href="ch01-05-OOP.html"><strong aria-hidden="true">1.5.</strong> Object Oriented Programming</a></li><li class="chapter-item expanded "><a href="ch01-06-ModernUserInterface.html"><strong aria-hidden="true">1.6.</strong> Modern User Interface</a></li><li class="chapter-item expanded "><a href="ch01-07-InternetAndBeyond.html"><strong aria-hidden="true">1.7.</strong> Internet and Beyond</a></li><li class="chapter-item expanded "><a href="ch01-08-Quiz.html"><strong aria-hidden="true">1.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-NameAndThings.html"><strong aria-hidden="true">2.</strong> Name and Things</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-BasicJavaApplication.html"><strong aria-hidden="true">2.1.</strong> Basic Java Application</a></li><li class="chapter-item expanded "><a href="ch02-02-VariablesAndTypes.html"><strong aria-hidden="true">2.2.</strong> Variables and Types</a></li><li class="chapter-item expanded "><a href="ch02-03-ObjectsAndSubroutines.html"><strong aria-hidden="true">2.3.</strong> Objects and Subroutines</a></li><li class="chapter-item expanded "><a href="ch02-04-TextInputAndOutput.html"><strong aria-hidden="true">2.4.</strong> Text Input and Output</a></li><li class="chapter-item expanded "><a href="ch02-05-DetailsOfExpressions.html"><strong aria-hidden="true">2.5.</strong> Details of Expressions</a></li><li class="chapter-item expanded "><a href="ch02-06-ProgrammingEnvironments.html"><strong aria-hidden="true">2.6.</strong> Programming and Environments</a></li><li class="chapter-item expanded "><a href="ch02-07-Exercises.html"><strong aria-hidden="true">2.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch02-08-Quiz.html"><strong aria-hidden="true">2.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-Control.html"><strong aria-hidden="true">3.</strong> Control</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-BlocksLoopsBranches.html"><strong aria-hidden="true">3.1.</strong> Blocks, Loops and Branches</a></li><li class="chapter-item expanded "><a href="ch03-02-AlgorithmDevelopment.html"><strong aria-hidden="true">3.2.</strong> Algorithm Development</a></li><li class="chapter-item expanded "><a href="ch03-03-While.html"><strong aria-hidden="true">3.3.</strong> while and do...while</a></li><li class="chapter-item expanded "><a href="ch03-04-For.html"><strong aria-hidden="true">3.4.</strong> The for statement</a></li><li class="chapter-item expanded "><a href="ch03-05-If.html"><strong aria-hidden="true">3.5.</strong> The If Statement</a></li><li class="chapter-item expanded "><a href="ch03-06-Switch.html"><strong aria-hidden="true">3.6.</strong> The Switch Statement</a></li><li class="chapter-item expanded "><a href="ch03-07-ExceptionsTryCatch.html"><strong aria-hidden="true">3.7.</strong> Exceptions and try...catch</a></li><li class="chapter-item expanded "><a href="ch03-08-Arrays.html"><strong aria-hidden="true">3.8.</strong> Arrays: An Introduction</a></li><li class="chapter-item expanded "><a href="ch03-09-GUI.html"><strong aria-hidden="true">3.9.</strong> GUI: An Introduction</a></li><li class="chapter-item expanded "><a href="ch03-10-Exercises.html"><strong aria-hidden="true">3.10.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch03-11-Quiz.html"><strong aria-hidden="true">3.11.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-Subroutines.html"><strong aria-hidden="true">4.</strong> Subroutines</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-BlackBoxes.html"><strong aria-hidden="true">4.1.</strong> Black Boxes</a></li><li class="chapter-item expanded "><a href="ch04-02-StaticSubroutines.html"><strong aria-hidden="true">4.2.</strong> Static Subroutines and Variables</a></li><li class="chapter-item expanded "><a href="ch04-03-Parameters.html"><strong aria-hidden="true">4.3.</strong> Parameters</a></li><li class="chapter-item expanded "><a href="ch04-04-ReturnValues.html"><strong aria-hidden="true">4.4.</strong> Return Values</a></li><li class="chapter-item expanded "><a href="ch04-05-Lambda.html"><strong aria-hidden="true">4.5.</strong> Lambda Expressions</a></li><li class="chapter-item expanded "><a href="ch04-06-APIPackagesModulesJavadoc.html"><strong aria-hidden="true">4.6.</strong> API, Packages, Modules and Javadoc</a></li><li class="chapter-item expanded "><a href="ch04-07-MoreOnProgramDesign.html"><strong aria-hidden="true">4.7.</strong> More on Program Design</a></li><li class="chapter-item expanded "><a href="ch04-08-TruthAboutDeclarations.html"><strong aria-hidden="true">4.8.</strong> Truth about Declarations</a></li><li class="chapter-item expanded "><a href="ch04-09-Exercises.html"><strong aria-hidden="true">4.9.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch04-10-Quiz.html"><strong aria-hidden="true">4.10.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-ObjectsClasses.html"><strong aria-hidden="true">5.</strong> Objects and Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-ObjectsAndInstanceMethods.html"><strong aria-hidden="true">5.1.</strong> Objects and Instance Methods</a></li><li class="chapter-item expanded "><a href="ch05-02-ConstructorObjectInit.html"><strong aria-hidden="true">5.2.</strong> Constructor and Object Initialization</a></li><li class="chapter-item expanded "><a href="ch05-03-ProgrammingWithObjects.html"><strong aria-hidden="true">5.3.</strong> Programming with Objects</a></li><li class="chapter-item expanded "><a href="ch05-04-AnExample.html"><strong aria-hidden="true">5.4.</strong> An Example</a></li><li class="chapter-item expanded "><a href="ch05-05-InheritanceAndPolymorphism.html"><strong aria-hidden="true">5.5.</strong> Inheritance and Polymorphism</a></li><li class="chapter-item expanded "><a href="ch05-06-thisandsuper.html"><strong aria-hidden="true">5.6.</strong> this and super</a></li><li class="chapter-item expanded "><a href="ch05-07-Interfaces.html"><strong aria-hidden="true">5.7.</strong> Interfaces</a></li><li class="chapter-item expanded "><a href="ch05-08-NestedClasses.html"><strong aria-hidden="true">5.8.</strong> Nested Classes</a></li><li class="chapter-item expanded "><a href="ch05-09-Exercises.html"><strong aria-hidden="true">5.9.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch05-10-Quiz.html"><strong aria-hidden="true">5.10.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-GUIProgramming.html"><strong aria-hidden="true">6.</strong> Introduction to GUI Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-BasicJavaFXApp.html"><strong aria-hidden="true">6.1.</strong> A Basic JavaFX Application</a></li><li class="chapter-item expanded "><a href="ch06-02-BasicClasses.html"><strong aria-hidden="true">6.2.</strong> Basic Classes</a></li><li class="chapter-item expanded "><a href="ch06-03-BasicEvents.html"><strong aria-hidden="true">6.3.</strong> Basic Events</a></li><li class="chapter-item expanded "><a href="ch06-04-BasicControls.html"><strong aria-hidden="true">6.4.</strong> Basic Controls</a></li><li class="chapter-item expanded "><a href="ch06-05-BasicLayout.html"><strong aria-hidden="true">6.5.</strong> Basic Layout</a></li><li class="chapter-item expanded "><a href="ch06-06-CompetePrograms.html"><strong aria-hidden="true">6.6.</strong> Complete Programs</a></li><li class="chapter-item expanded "><a href="ch06-07-Exercises.html"><strong aria-hidden="true">6.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch06-08-Quiz.html"><strong aria-hidden="true">6.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-ArraysArraylistsRecords.html"><strong aria-hidden="true">7.</strong> Arrays, ArrayLists and Records</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-ArrayDetails.html"><strong aria-hidden="true">7.1.</strong> Array Details</a></li><li class="chapter-item expanded "><a href="ch07-02-ArrayProcessing.html"><strong aria-hidden="true">7.2.</strong> Array Processing</a></li><li class="chapter-item expanded "><a href="ch07-03-ArrayLists.html"><strong aria-hidden="true">7.3.</strong> ArrayLists</a></li><li class="chapter-item expanded "><a href="ch07-04-Records.html"><strong aria-hidden="true">7.4.</strong> Records</a></li><li class="chapter-item expanded "><a href="ch07-05-SearchingAndSorting.html"><strong aria-hidden="true">7.5.</strong> Searching and Sorting</a></li><li class="chapter-item expanded "><a href="ch07-06-2DArrays.html"><strong aria-hidden="true">7.6.</strong> 2D Arrays</a></li><li class="chapter-item expanded "><a href="ch07-07-Exercises.html"><strong aria-hidden="true">7.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch07-08-Quiz.html"><strong aria-hidden="true">7.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-CorrectnessRobustnessEfficiency.html"><strong aria-hidden="true">8.</strong> Correctness, Robustness, Efficiency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-IntroductionCorrectnessandRobustness.html"><strong aria-hidden="true">8.1.</strong> Introduction to Correctness and Robustness</a></li><li class="chapter-item expanded "><a href="ch08-02-WritingCorrectPrograms.html"><strong aria-hidden="true">8.2.</strong> Writing Correct Programs</a></li><li class="chapter-item expanded "><a href="ch08-03-ExceptionsAndtrycatch.html"><strong aria-hidden="true">8.3.</strong> Exceptions and try..catch</a></li><li class="chapter-item expanded "><a href="ch08-04-AssertionsAnnotations.html"><strong aria-hidden="true">8.4.</strong> Assertions and Annotations</a></li><li class="chapter-item expanded "><a href="ch08-05-AnalysisofAlgorithms.html"><strong aria-hidden="true">8.5.</strong> Analysis of Algorithms</a></li><li class="chapter-item expanded "><a href="ch08-06-Exercises.html"><strong aria-hidden="true">8.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch08-07-Quiz.html"><strong aria-hidden="true">8.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-LinkedDataStructuresRecursion.html"><strong aria-hidden="true">9.</strong> Linked Data Structures and Recursion</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-Recursion.html"><strong aria-hidden="true">9.1.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="ch09-02-LinkedDataStructures.html"><strong aria-hidden="true">9.2.</strong> Linked Data Structures</a></li><li class="chapter-item expanded "><a href="ch09-03-StacksQueuesADTs.html"><strong aria-hidden="true">9.3.</strong> Stacks, Queues and ADTs</a></li><li class="chapter-item expanded "><a href="ch09-04-BinaryTrees.html"><strong aria-hidden="true">9.4.</strong> Binary Trees</a></li><li class="chapter-item expanded "><a href="ch09-05-SimpleRecursiveDescentParser.html"><strong aria-hidden="true">9.5.</strong> A Simple Recursive Descent Parser</a></li><li class="chapter-item expanded "><a href="ch09-06-Exercises.html"><strong aria-hidden="true">9.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch09-07-Quiz.html"><strong aria-hidden="true">9.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-GenericProgrammingandCollectionClasses.html"><strong aria-hidden="true">10.</strong> Generic Programmingand Collection Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-GenericProgramming.html"><strong aria-hidden="true">10.1.</strong> Generic Programming</a></li><li class="chapter-item expanded "><a href="ch10-02-ListsandSets.html"><strong aria-hidden="true">10.2.</strong> Lists and Sets</a></li><li class="chapter-item expanded "><a href="ch10-03-Maps.html"><strong aria-hidden="true">10.3.</strong> Maps</a></li><li class="chapter-item expanded "><a href="ch10-04-JCF.html"><strong aria-hidden="true">10.4.</strong> Programming with the JCF</a></li><li class="chapter-item expanded "><a href="ch10-05-WritingGenericClassesandMethods.html"><strong aria-hidden="true">10.5.</strong> Writing Generic Classes and Methods</a></li><li class="chapter-item expanded "><a href="ch10-06-StreamAPI.html"><strong aria-hidden="true">10.6.</strong> Stream APIs</a></li><li class="chapter-item expanded "><a href="ch10-07-Exercises.html"><strong aria-hidden="true">10.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch10-08-Quiz.html"><strong aria-hidden="true">10.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-IOStreamsFilesNetworking.html"><strong aria-hidden="true">11.</strong> I/O Streams, Files, and Networking</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-IOStreamsReadersAndWriters.html"><strong aria-hidden="true">11.1.</strong> I/O Streams, Readers, and Writers</a></li><li class="chapter-item expanded "><a href="ch11-02-Files.html"><strong aria-hidden="true">11.2.</strong> Files</a></li><li class="chapter-item expanded "><a href="ch11-03-ProgrammingWithFiles.html"><strong aria-hidden="true">11.3.</strong> Programming With Files</a></li><li class="chapter-item expanded "><a href="ch11-04-Networking.html"><strong aria-hidden="true">11.4.</strong> Networking</a></li><li class="chapter-item expanded "><a class="active" href="ch11-05-XML.html"><strong aria-hidden="true">11.5.</strong> A Brief Introduction to XML</a></li><li class="chapter-item expanded "><a href="ch11-06-Exercises.html"><strong aria-hidden="true">11.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch11-07-Quiz.html"><strong aria-hidden="true">11.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-ThreadsandMultiprocessing.html"><strong aria-hidden="true">12.</strong> Threads and Multiprocessing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-IntroductiontoThreads.html"><strong aria-hidden="true">12.1.</strong> Introduction to Threads</a></li><li class="chapter-item expanded "><a href="ch12-02-ProgrammingwithThreads.html"><strong aria-hidden="true">12.2.</strong> Programming with Threads</a></li><li class="chapter-item expanded "><a href="ch12-03-ThreadsandParallelProcessing.html"><strong aria-hidden="true">12.3.</strong> Threads and Networking</a></li><li class="chapter-item expanded "><a href="ch12-04-ThreadsandNetworking.html"><strong aria-hidden="true">12.4.</strong> Threads and Networking</a></li><li class="chapter-item expanded "><a href="ch12-05-NetworkProgrammingExample.html"><strong aria-hidden="true">12.5.</strong> Network Programming Example</a></li><li class="chapter-item expanded "><a href="ch12-06-Exercises.html"><strong aria-hidden="true">12.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch12-07-Quiz.html"><strong aria-hidden="true">12.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-GUIProgrammingContinued.html"><strong aria-hidden="true">13.</strong> GUI Programming Continued</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-PropertiesandBindings.html"><strong aria-hidden="true">13.1.</strong> Properties and Bindings</a></li><li class="chapter-item expanded "><a href="ch13-02-FancierGraphics.html"><strong aria-hidden="true">13.2.</strong> Fancier Graphics</a></li><li class="chapter-item expanded "><a href="ch13-03-ComplexComponentsandMVC.html"><strong aria-hidden="true">13.3.</strong> Complex Components and MVC</a></li><li class="chapter-item expanded "><a href="ch13-04-MostlyWindowsandDialogs.html"><strong aria-hidden="true">13.4.</strong> Mostly Windows and Dialogs</a></li><li class="chapter-item expanded "><a href="ch13-05-FinishingTouches.html"><strong aria-hidden="true">13.5.</strong> Finishing Touches</a></li><li class="chapter-item expanded "><a href="ch13-06-Exercises.html"><strong aria-hidden="true">13.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch13-07-Quiz.html"><strong aria-hidden="true">13.7.</strong> Quiz</a></li></ol><li class="chapter-item expanded "><a href="appendix-00.html"> Appendix</a></li><li class="chapter-item expanded "><a href="glossary-00.html"> Glossary</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="Java">Java</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Introduction to Programming Using Java</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Xayarsh/Java-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="A Brief Introduction to XML"><a class="header" href="#A Brief Introduction to XML">A Brief Introduction to XML</a></h2>
                        <p>
                            When data is saved to a file or transmitted over
                            a network, it must be represented in some way that will allow the same data
                            to be rebuilt later, when the file is read or the transmission is received.
                            We have seen that there are good reasons to prefer textual, character-based
                            representations in many cases, but there are many ways to represent a given
                            collection of data as text.  In this section, we'll take a brief look at
                            one type of character-based data representation that has become increasingly
                            common.</p>


                        <p>
                            <span class="newword">XML</span> (eXtensible Markup Language) is a syntax for creating
                            data representation languages.  There are two aspects or levels of XML.
                            On the first level, XML specifies a strict but relatively simple syntax.
                            Any sequence of characters that follows that syntax is a
                            <span class="newword">well-formed</span> XML document.  On the second level, XML
                            provides a way of placing further restrictions on what can appear in
                            a document.  This is done by associating a <span class="newword">DTD</span> (Document
                            Type Definition) with an XML document.  A DTD is
                            essentially a list of things that are allowed to appear in the
                            XML document.  A well-formed XML document that has an associated DTD and that follows
                            the rules of the DTD is said to be a <span class="newword">valid</span> XML
                            document.  The idea is that XML is a general format for data representation,
                            and a DTD specifies how to use XML to represent a particular kind of data.
                            (There are also alternatives to DTDs, such as <span class="newword">XML schemas</span>,
                            for defining valid XML documents, but let's ignore them here.)</p>


                        <p>There is nothing magical about XML.  It's certainly not perfect.  It's a
                            very verbose language, and some people think it's ugly.  On the other hand
                            it's very flexible. It can be used to represent almost any type of data.
                            It was built from the start to support all languages and alphabets.  Most
                            important, it has become an accepted standard.  There is support in just
                            about any programming language for processing XML documents.  There are
                            standard DTDs for describing many different kinds of data.  There are many
                            ways to design a data representation language, but XML is one that has happened to
                            come into widespread use.  In fact, it has found its way into almost every
                            corner of information technology.  For example:  There are XML languages for representing
                            mathematical expressions (MathML), musical notation (MusicXML), molecules and
                            chemical reactions (CML), vector graphics (SVG), and many other kinds of information.  XML is
                            used by OpenOffice and recent versions of Microsoft Office
                            in the document format for office applications such as word processing,
                            spreadsheets, and presentations.  XML site syndication languages (RSS, ATOM)
                            make it possible for web sites, newspapers, and blogs to make a list of
                            recent headlines available in a standard format that can be used by other
                            web sites and by web browsers; the same format is used to publish podcasts.
                            And XML is a common format for the electronic exchange of business information.
                        </p>


                        <p>My purpose here is not to tell you everything there is to know about XML.
                            I will just explain a few ways in which it can be used in your own programs.
                            In particular, I will not say anything further about DTDs and
                            valid XML.  For many purposes, it is sufficient to use well-formed XML
                            documents with no associated DTDs.</p>


                        <h3 id="Basic XML Syntax"><a class="header" href="#Basic XML Syntax">Basic XML Syntax</a></h3>

                        <p>If you know HTML, the language for writing web pages, then XML will look familiar.
                            An XML document looks a lot like an HTML document.
                            HTML is not itself an XML language, since it does not follow all the strict XML syntax
                            rules, but the basic ideas are similar.  Here is a short, well-formed XML document:</p>


                        <pre><code class="java">&lt;?xml version="1.0"?&gt;
&lt;simplepaint version="1.0"&gt;
   &lt;background red='1' green='0.6' blue='0.2'/&gt;
   &lt;curve&gt;
      &lt;color red='0' green='0' blue='1'/&gt;
      &lt;symmetric&gt;false&lt;/symmetric&gt;
      &lt;point x='83' y='96'/&gt;
      &lt;point x='116' y='149'/&gt;
      &lt;point x='159' y='215'/&gt;
      &lt;point x='216' y='294'/&gt;
      &lt;point x='264' y='359'/&gt;
      &lt;point x='309' y='418'/&gt;
      &lt;point x='371' y='499'/&gt;
      &lt;point x='400' y='543'/&gt;
   &lt;/curve&gt;
   &lt;curve&gt;
      &lt;color red='1' green='1' blue='1'/&gt;
      &lt;symmetric&gt;true&lt;/symmetric&gt;
      &lt;point x='54' y='305'/&gt;
      &lt;point x='79' y='289'/&gt;
      &lt;point x='128' y='262'/&gt;
      &lt;point x='190' y='236'/&gt;
      &lt;point x='253' y='209'/&gt;
      &lt;point x='341' y='158'/&gt;
   &lt;/curve&gt;
&lt;/simplepaint&gt;</code></pre>


                        <p>The first line, which is optional, merely identifies this as an XML document.
                            This line can also specify other information, such as the character encoding that
                            was used to encode the characters in the document into binary form.  If this
                            document had an associated DTD, it would be specified in a "DOCTYPE" directive
                            on the next line of the file.</p>


                        <p>Aside from the first line, the document is made up of <span class="newword">elements</span>,
                            <span class="newword">attributes</span>, and textual content.  An element starts with a
                            <span class="newword">tag</span>, such as <span class="code">&lt;curve&gt;</span> and ends with a
                            matching <span class="newword">end-tag</span> such as <span class="code">&lt;/curve&gt;</span>.
                            Between the tag and end-tag is the <span class="newword">content</span> of the
                            element, which can consist of text and nested elements.  (In the example, the
                            only textual content is the <span class="code">true</span> or <span class="code">false</span> in
                            the <span class="code">&lt;symmetric&gt;</span> elements.)  If an element has
                            no content, then the opening tag and end-tag can be combined into a single
                            <span class="newword">empty tag</span>, such as <span class="code">&lt;point&nbsp;x='83'&nbsp;y='96'/&gt;</span>,
                            with a "<span class="code">/</span>" before the final&nbsp;"<span class="code">&gt;</span>".
                            This is an abbreviation for <span class="code">&lt;point&nbsp;x='83' y='96'&gt;&lt;/point&gt;</span>.
                            A tag can include attributes such as the <span class="code">x</span> and <span class="code">y</span>
                            in <span class="code">&lt;point&nbsp;x='83'&nbsp;y='96'/&gt;</span> or the
                            <span class="code">version</span> in <span class="code">&lt;simplepaint version="1.0"&gt;</span>.
                            A document can also include a few other things, such as comments, that I
                            will not discuss here.</p>


                        <p>The author of a well-formed XML document gets to choose the tag names
                            and attribute names, and meaningful names can be chosen to describe the
                            data to a human reader.  (For a valid XML document
                            that uses a DTD, it's the author of the DTD who gets to choose the tag names.)</p>


                        <p>Every well-formed XML document follows a strict syntax.  Here are some
                            of the most important syntax rules:
                            Tag names and attribute names in XML are case sensitive.  A name must begin with
                            a letter and can contain letters, digits and certain other characters.
                            Spaces and ends-of-line
                            are significant only in textual content.  Every tag must
                            either be an empty tag or have a matching end-tag.  By "matching" here,
                            I mean that elements must be properly nested; if a tag is inside some element,
                            then the matching end-tag must also be inside that element.  A document
                            must have a <span class="newword">root element</span>, which contains all the other
                            elements.  The root element in the above example has tag name <span class="code">simplepaint</span>.
                            Every attribute must have a value, and that value must be enclosed in quotation
                            marks; either single quotes or double quotes can be used for this.  The
                            special characters <span class="code">&lt;</span> and <span class="code">&amp;</span>, if they appear
                            in attribute values or textual content, must be written as <span class="code">&amp;lt;</span>
                            and <span class="code">&amp;amp;</span>.  "<span class="code">&amp;lt;</span>"&nbsp;and "<span class="code">&amp;amp;</span>"
                            are examples of <span class="newword">entities</span>.  The entities <span class="code">&amp;gt;</span>,
                            <span class="code">&amp;quot;</span>, and <span class="code">&amp;apos;</span> are also defined, representing
                            <span class="code">&gt;</span>, double quote, and single quote.  (Additional entities can
                            be defined in a DTD.)</p>


                        <p>While this description will not enable you to understand everything that you
                            might encounter in XML documents, it should allow you to design well-formed
                            XML documents to represent data structures used in Java programs.</p>


                        <h3 id="Working With the DOM"><a class="header" href="#Working With the DOM">Working With the DOM</a></h3>


                        <p>The sample XML file shown above was designed to store information
                            about simple drawings made by the user.  The drawings in question are ones that
                            could be made using the sample program <span class="sourceref"><a href="./source/chapter7/SimplePaint2.java">SimplePaint2.java</a></span>
                            from <a href="ch07-03-ArrayLists.html">Subsection&nbsp;7.3.3</a>.
                            We'll look at another version of that program that can save
                            the user's drawing using an XML format for the data file.
                            The new version is <span class="sourceref"><a href="./source/chapter11/SimplePaintWithXML.java">SimplePaintWithXML.java</a></span>.
                            The sample XML document shown earlier in this section
                            can be used with that program.  I designed the format of that document
                            to represent all the data needed to reconstruct a picture in
                            <span class="code">SimplePaint2</span>.  The document encodes the background color
                            of the picture and a list of curves.  Each <span class="code">&lt;curve&gt;</span>
                            element contains the data from one object of type <span class="classname">CurveData</span>.</p>


                        <p>It is easy enough to write data in a customized XML format, although we
                            have to be very careful to follow all the syntax rules.  Here is how <span class="code">SimplePaintWithXML</span>
                            writes the data for a <span class="code">SimplePaint2</span> picture to a
                            <span class="classname">PrintWriter</span>, <span class="code">out</span>.  This produces
                            an XML file with the same structure as the example shown above:</p>


                        <pre><code class="java">out.println("&lt;?xml version=\"1.0\"?&gt;");
out.println("&lt;simplepaint version=\"1.0\"&gt;");
out.println("   &lt;background red='" + backgroundColor.getRed() + "' green='" +
        backgroundColor.getGreen() + "' blue='" + backgroundColor.getBlue() + "'/&gt;");
for (CurveData c : curves) {
    out.println("   &lt;curve&gt;");
    out.println("      &lt;color red='" + c.color.getRed() + "' green='" +
            c.color.getGreen() + "' blue='" + c.color.getBlue() + "'/&gt;");
    out.println("      &lt;symmetric&gt;" + c.symmetric + "&lt;/symmetric&gt;");
    for (Point2D pt : c.points)
        out.println("      &lt;point x='" + pt.getX() + "' y='" + pt.getY() + "'/&gt;");
    out.println("   &lt;/curve&gt;");
}
out.println("&lt;/simplepaint&gt;");</code></pre>


                        <p>Reading the data back into the program is another matter.  To reconstruct
                            the data structure represented by the XML Document, it is necessary to
                            parse the document and extract the data from it. This could be difficult to do by
                            hand. Fortunately, Java has
                            a standard API for parsing and processing XML Documents.  (Actually, it
                            has two, but we will only look at one of them.)</p>


                        <p>A well-formed XML document has a certain structure, consisting of elements
                            containing attributes, nested elements, and textual content.  It's possible to
                            build a data structure in the computer's memory that corresponds to the structure
                            and content of the document.  Of course, there are many ways to do this, but there
                            is one common standard representation known as the <span class="newword">Document Object Model</span>,
                            or DOM.  The DOM specifies how to build data structures to represent XML documents,
                            and it specifies some standard methods for accessing the data in that structure.
                            The data structure is a kind of tree whose structure mirrors the structure of
                            the document.  The tree is constructed from <span class="newword">nodes</span> of various
                            types.  There are nodes to represent elements, attributes, and text. (The tree
                            can also contain several other types of node, representing aspects of XML that
                            we can ignore here.)  Attributes and text can be processed without directly
                            manipulating the corresponding nodes, so we will be concerned almost entirely
                            with element nodes.</p>


                        <p>(The sample program <span class="sourceref"><a href="./source/chapter11/XMLDemo.java">XMLDemo.java</a></span> lets you experiment with
                            XML and the DOM.  It has a text area where you can enter an XML document.
                            Initially, the input area contains the sample XML document from this section.
                            When you click a button named "Parse XML Input", the program will attempt
                            to read the XML from the input box and build a DOM representation of that
                            document.  If the input is not well-formed XML, an error message is displayed.
                            If it is legal, the program will traverse the DOM representation and
                            display a list of elements, attributes, and textual content that it
                            encounters.  The program uses a few techniques for processing XML that I won't discuss here.)</p>


                        <p>In Java, the DOM representation of an XML document file can be created
                            with just two statements.  If <span class="code">selectedFile</span> is a variable of
                            type <span class="classname">File</span> that represents the XML file, and
                            <span class="code">xmldoc</span> is of type <span class="classname">Document</span>, then</p>


                        <pre><code class="java">DocumentBuilder docReader
                 = DocumentBuilderFactory.newInstance().newDocumentBuilder();
xmldoc = docReader.parse(selectedFile);</code></pre>


                        <p>will open the file, read its contents, and build the DOM representation.
                            The classes <span class="classname">DocumentBuilder</span> and <span class="classname">DocumentBuilderFactory</span>
                            are both defined in the package <span class="code">javax.xml.parsers</span>.
                            The method <span class="code">docReader.parse()</span> does the actual work.  It
                            will throw an exception if it can't read the file or if the file does
                            not contain a legal XML document.  If it succeeds, then the value returned
                            by <span class="code">docReader.parse()</span> is an object that represents the entire
                            XML document.  (This is a very complex task!  It has been coded once and
                            for all into a method that can be used very easily in any Java program.  We see
                            the benefit of using a standardized syntax.)</p>


                        <p>The structure of the DOM data structure is defined in the package
                            <span class="code">org.w3c.dom</span>, which contains several data types that represent
                            an XML document as a whole and the individual nodes in a document.
                            The "org.w3c" in the name refers to the World Wide Web Consortium,
                            <a href="http://www.w3c.org">W3C</a>, which is the standards organization for the Web.
                            DOM, like XML, is a general standard, not just a Java standard.
                            The data types that we need here are <span class="classname">Document</span>,
                            <span class="classname">Node</span>, <span class="classname">Element</span>, and <span class="classname">NodeList</span>.
                            (They are defined as <span class="code">interfaces</span> rather than <span class="code">classes</span>,
                            but that fact is not relevant here.)   We can use methods that are defined
                            in these data types to access the data in the DOM representation of
                            an XML document.</p>


                        <p>An object of type <span class="classname">Document</span> represents an entire
                            XML document.  The return value of <span class="code">docReader.parse()</span>&mdash;<span class="code">xmldoc</span>
                            in the above example&mdash;is of type <span class="classname">Document</span>.
                            We will only need one method from this class:  If <span class="code">xmldoc</span>
                            is of type <span class="classname">Document</span>, then</p>


                        <pre><code class="java">xmldoc.getDocumentElement()</code></pre>


                        <p>returns a value of type <span class="classname">Element</span> that represents the
                            root element of the document.  (Recall that this is the top-level element
                            that contains all the other elements.)  In the sample XML document from earlier
                            in this section, the root element consists of the tag
                            <span class="code">&lt;simplepaint version="1.0"&gt;</span>, the end-tag
                            <span class="code">&lt;/simplepaint&gt;</span>, and everything in between.
                            The elements that are nested inside
                            the root element are represented by their own nodes, which are said to
                            be <span class="newword">children</span> of the root node.
                            An object of type <span class="classname">Element</span>
                            contains several useful methods.  If <span class="code">element</span> is of type
                            <span class="classname">Element</span>, then we have:</p>


                        <ul>

                            <li>
                                <span class="codedef">element.getTagName()</span> &mdash; returns a <span class="classname">String</span>
                                containing the name that is used in the element's tag.  For example, the name
                                of a <span class="code">&lt;curve&gt;</span> element is the string "curve".</li>

                            <li>
                                <span class="codedef">element.getAttribute(attrName)</span> &mdash; if <span class="code">attrName</span>
                                is the name of an attribute in the element, then this method returns the value
                                of that attribute.  For the element, <span class="code">&lt;point&nbsp;x="83"&nbsp;y="42"/&gt;</span>,
                                <span class="code">element.getAttribute("x")</span> would return the string "83".  Note that the
                                return value is always a <span class="classname">String</span>, even if the attribute
                                is supposed to represent a numerical value.  If the element has no attribute with
                                the specified name, then the return value is an empty string.</li>

                            <li>
                                <span class="codedef">element.getTextContent()</span> &mdash; returns a <span class="classname">String</span>
                                containing all of the textual content that is contained in the element.  Note that this
                                includes text that is contained inside other elements that are nested inside the element.</li>

                            <li>
                                <span class="codedef">element.getChildNodes()</span> &mdash; returns a value of type
                                <span class="classname">NodeList</span> that contains all the <span class="classname">Nodes</span> that
                                are children of the element.  The list includes nodes representing other elements and
                                textual content that are directly nested in the element (as well as some other
                                types of node that I don't care about here).  The <span class="code">getChildNodes()</span>
                                method makes it possible to traverse the entire DOM data structure by starting
                                with the root element, looking at children of the root element, children of
                                the children, and so on.  (There is a similar method that returns the
                                attributes of the element, but I won't be using it here.)</li>

                            <li>
                                <span class="codedef">element.getElementsByTagName(tagName)</span> &mdash; returns
                                a <span class="classname">NodeList</span> that contains all the nodes representing
                                all elements that are nested inside <span class="code">element</span> and which have the
                                given tag name.  Note that this includes elements that are nested to any level,
                                not just elements that are directly contained inside <span class="code">element</span>.
                                The <span class="code">getElementsByTagName()</span> method allows you to reach into the
                                document and pull out specific data that you are interested in.
                            </li>

                        </ul>


                        <p>An object of type <span class="classname">NodeList</span> represents a list of
                            <span class="classname">Nodes</span>.  Unfortunately, it does not use the API defined for lists
                            in the Java Collection Framework.  Instead, a value, <span class="code">nodeList</span>,
                            of type <span class="classname">NodeList</span> has two methods:
                            <span class="code">nodeList.getLength()</span> returns the number of nodes in the
                            list, and <span class="code">nodeList.item(i)</span> returns the node at position
                            <span class="code">i</span>, where the positions are numbered <span class="code">0</span>, <span class="code">1</span>, ...,
                            <span class="code">nodeList.getLength()&nbsp;-&nbsp;1</span>.  Note that the
                            return value of <span class="code">nodeList.get()</span> is of type <span class="classname">Node</span>,
                            and it might have to be type-cast to a more specific node type before it is used.</p>


                        <p>Knowing just this much, you can do the most common types of processing of
                            DOM representations.  Let's look at a few code fragments.  Suppose that
                            in the course of processing a document you come across an <span class="classname">Element</span>
                            node that represents the element</p>


                        <pre><code class="java">&lt;background red='1' green='0.6' blue='0.2'/&gt;</code></pre>


                        <p>This element might be encountered either while traversing the
                            document with <span class="code">getChildNodes()</span> or in the result of
                            a call to <span class="code">getElementsByTagName("background")</span>.
                            Our goal is to reconstruct the data structure represented by the document, and
                            this element represents part of that data.  In this
                            case, the element represents a color, and the red, green, and blue components
                            are given by the attributes of the element.  If <span class="code">element</span> is a variable
                            that refers to the node, the color can be obtained by saying:</p>



                        <pre><code class="java">double r = Double.parseDouble( element.getAttribute("red") );
double g = Double.parseDouble( element.getAttribute("green") );
double b = Double.parseDouble( element.getAttribute("blue") );
Color bgColor = Color.color(r,g,b);</code></pre>




                        <p>Suppose now that <span class="code">element</span> refers to the node that represents
                            the element</p>


                        <pre><code class="java">&lt;symmetric&gt;true&lt;/symmetric&gt;</code></pre>


                        <p>In this case, the element represents the value of a <span class="ptype">boolean</span>
                            variable, and the value is encoded in the textual content of the element.
                            We can recover the value from the element with:</p>


                        <pre><code class="java">String bool = element.getTextContent();
boolean symmetric;
if (bool.equals("true"))
   symmetric = true;
else
   symmetric = false;</code></pre>


                        <p>Next, consider an example that uses a <span class="classname">NodeList</span>.
                            Suppose we encounter an element that represents a list of <span class="classname">Point2Ds</span>:
                        </p>


                        <pre><code class="java">&lt;pointlist&gt;
   &lt;point x='17' y='42'/&gt;
   &lt;point x='23' y='8'/&gt;
   &lt;point x='109' y='342'/&gt;
   &lt;point x='18' y='270'/&gt;
&lt;/pointlist&gt;</code></pre>


                        <p>Suppose that <span class="code">element</span> refers to the node that represents
                            the <span class="code">&lt;pointlist&gt;</span> element.  Our goal is to build the list
                            of type <span class="code">ArrayList&lt;Point2D&gt;</span> that is represented by the
                            element.  We can do this by traversing the <span class="classname">NodeList</span>
                            that contains the child nodes of <span class="code">element</span>:</p>


                        <pre><code class="java">ArrayList&lt;Point2D&gt; points = new ArrayList&lt;&gt;();
NodeList children = element.getChildNodes();
for (int i = 0; i &lt; children.getLength(); i++) {
   Node child = children.item(i);   // One of the child nodes of element.
   if ( child instanceof Element ) {
      Element pointElement = (Element)child;  // One of the &lt;point&gt; elements.
      double x = Double.parseDouble( pointElement.getAttribute("x") );
      double y = Double.parseDouble( pointElement.getAttribute("y") );
      Point2D pt = new Point2D(x,y); // Create the Point represented by pointElement.
      points.add(pt);  // Add the point to the list of points.
   }
}</code></pre>


                        <p>All the nested <span class="code">&lt;point&gt;</span> elements are children of
                            the <span class="code">&lt;pointlist&gt;</span> element.  The <span class="code">if</span> statement
                            in this code fragment is necessary because an element can have other
                            children in addition to its nested elements.  In this example, we only
                            want to process the children that are elements.</p>


                        <p>All these techniques can be employed to write the file input method for the
                            sample program <span class="sourceref"><a href="./source/chapter11/SimplePaintWithXML.java">SimplePaintWithXML.java</a></span>.  When building
                            the data structure represented by an XML file, my approach is to start
                            with a default data structure and then to modify and add to it as I
                            traverse the DOM representation of the file.  It's not a trivial process,
                            but I hope that you can follow it:</p>



                        <pre><code class="java">Color newBackground = Color.WHITE;
ArrayList&lt;CurveData&gt; newCurves = new ArrayList&lt;&gt;();
Element rootElement = xmldoc.getDocumentElement();
if ( ! rootElement.getNodeName().equals("simplepaint") )
    throw new Exception("File is not a SimplePaint file.");
String version = rootElement.getAttribute("version");
try {
    double versionNumber = Double.parseDouble(version);
    if (versionNumber &gt; 1.0)
        throw new Exception("File requires a newer version of SimplePaint.");
}
catch (NumberFormatException e) {
}
NodeList nodes = rootElement.getChildNodes();
for (int i = 0; i &lt; nodes.getLength(); i++) {
   if (nodes.item(i) instanceof Element) {
      Element element = (Element)nodes.item(i);
      if (element.getTagName().equals("background")) {
         double r = Double.parseDouble(element.getAttribute("red"));
         double g = Double.parseDouble(element.getAttribute("green"));
         double b = Double.parseDouble(element.getAttribute("blue"));
         newBackground = Color.color(r,g,b);
      }
      else if (element.getTagName().equals("curve")) {
         CurveData curve = new CurveData();
         curve.color = Color.BLACK;
         curve.points = new ArrayList&lt;&gt;();
         newCurves.add(curve);
         NodeList curveNodes = element.getChildNodes();
         for (int j = 0; j &lt; curveNodes.getLength(); j++) {
           if (curveNodes.item(j) instanceof Element) {
             Element curveElement = (Element)curveNodes.item(j);
             if (curveElement.getTagName().equals("color")) {
               double r = Double.parseDouble(curveElement.getAttribute("red"));
               double g = Double.parseDouble(curveElement.getAttribute("green"));
               double b = Double.parseDouble(curveElement.getAttribute("blue"));
               curve.color = Color.color(r,g,b);
             }
             else if (curveElement.getTagName().equals("point")) {
               double x = Double.parseDouble(curveElement.getAttribute("x"));
               double y = Double.parseDouble(curveElement.getAttribute("y"));
               curve.points.add(new Point2D(x,y));
             }
             else if (curveElement.getTagName().equals("symmetric")) {
               String content = curveElement.getTextContent();
               if (content.equals("true"))
                 curve.symmetric = true;
             }
           }
         }
      }
   }
}
backgroundColor = newBackground;
curves = newCurves;</code></pre>




                        <p>You can find the complete source code in <span class="sourceref"><a href="./source/chapter11/SimplePaintWithXML.java">SimplePaintWithXML.java</a></span>.</p>





                        <p>XML has developed into an extremely important technology, and some applications
                            of it are very complex.  But there is a core of simple ideas that can be easily
                            applied in Java.  Knowing just the basics, you can make good use of XML in
                            your own Java programs.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch11-04-Networking.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch11-06-Exercises.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch11-04-Networking.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch11-06-Exercises.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </body>
</html>
