<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Writing Generic Classes and Methods - Introduction to Programming Using Java</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

<link rel="stylesheet" href="code-class.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html" >Introduction to Programming Using Java</a></li><li class="chapter-item expanded affix "><a href="preface.html">Preface</a></li><li class="chapter-item expanded "><a href="ch01-00-Overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-FetchExecuteCycle.html"><strong aria-hidden="true">1.1.</strong> Fetch and Execute Cycle</a></li><li class="chapter-item expanded "><a href="ch01-02-AsynchronousEvents.html"><strong aria-hidden="true">1.2.</strong> Asynchronous Events</a></li><li class="chapter-item expanded "><a href="ch01-03-JavaVirtualMachine.html"><strong aria-hidden="true">1.3.</strong> The Java Virtual Machine</a></li><li class="chapter-item expanded "><a href="ch01-04-FundamentalBuildingBlocks.html"><strong aria-hidden="true">1.4.</strong> Fundamentals</a></li><li class="chapter-item expanded "><a href="ch01-05-OOP.html"><strong aria-hidden="true">1.5.</strong> Object Oriented Programming</a></li><li class="chapter-item expanded "><a href="ch01-06-ModernUserInterface.html"><strong aria-hidden="true">1.6.</strong> Modern User Interface</a></li><li class="chapter-item expanded "><a href="ch01-07-InternetAndBeyond.html"><strong aria-hidden="true">1.7.</strong> Internet and Beyond</a></li><li class="chapter-item expanded "><a href="ch01-08-Quiz.html"><strong aria-hidden="true">1.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-NameAndThings.html"><strong aria-hidden="true">2.</strong> Name and Things</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-BasicJavaApplication.html"><strong aria-hidden="true">2.1.</strong> Basic Java Application</a></li><li class="chapter-item expanded "><a href="ch02-02-VariablesAndTypes.html"><strong aria-hidden="true">2.2.</strong> Variables and Types</a></li><li class="chapter-item expanded "><a href="ch02-03-ObjectsAndSubroutines.html"><strong aria-hidden="true">2.3.</strong> Objects and Subroutines</a></li><li class="chapter-item expanded "><a href="ch02-04-TextInputAndOutput.html"><strong aria-hidden="true">2.4.</strong> Text Input and Output</a></li><li class="chapter-item expanded "><a href="ch02-05-DetailsOfExpressions.html"><strong aria-hidden="true">2.5.</strong> Details of Expressions</a></li><li class="chapter-item expanded "><a href="ch02-06-ProgrammingEnvironments.html"><strong aria-hidden="true">2.6.</strong> Programming and Environments</a></li><li class="chapter-item expanded "><a href="ch02-07-Exercises.html"><strong aria-hidden="true">2.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch02-08-Quiz.html"><strong aria-hidden="true">2.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-Control.html"><strong aria-hidden="true">3.</strong> Control</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-BlocksLoopsBranches.html"><strong aria-hidden="true">3.1.</strong> Blocks, Loops and Branches</a></li><li class="chapter-item expanded "><a href="ch03-02-AlgorithmDevelopment.html"><strong aria-hidden="true">3.2.</strong> Algorithm Development</a></li><li class="chapter-item expanded "><a href="ch03-03-While.html"><strong aria-hidden="true">3.3.</strong> while and do...while</a></li><li class="chapter-item expanded "><a href="ch03-04-For.html"><strong aria-hidden="true">3.4.</strong> The for statement</a></li><li class="chapter-item expanded "><a href="ch03-05-If.html"><strong aria-hidden="true">3.5.</strong> The If Statement</a></li><li class="chapter-item expanded "><a href="ch03-06-Switch.html"><strong aria-hidden="true">3.6.</strong> The Switch Statement</a></li><li class="chapter-item expanded "><a href="ch03-07-ExceptionsTryCatch.html"><strong aria-hidden="true">3.7.</strong> Exceptions and try...catch</a></li><li class="chapter-item expanded "><a href="ch03-08-Arrays.html"><strong aria-hidden="true">3.8.</strong> Arrays: An Introduction</a></li><li class="chapter-item expanded "><a href="ch03-09-GUI.html"><strong aria-hidden="true">3.9.</strong> GUI: An Introduction</a></li><li class="chapter-item expanded "><a href="ch03-10-Exercises.html"><strong aria-hidden="true">3.10.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch03-11-Quiz.html"><strong aria-hidden="true">3.11.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-Subroutines.html"><strong aria-hidden="true">4.</strong> Subroutines</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-BlackBoxes.html"><strong aria-hidden="true">4.1.</strong> Black Boxes</a></li><li class="chapter-item expanded "><a href="ch04-02-StaticSubroutines.html"><strong aria-hidden="true">4.2.</strong> Static Subroutines and Variables</a></li><li class="chapter-item expanded "><a href="ch04-03-Parameters.html"><strong aria-hidden="true">4.3.</strong> Parameters</a></li><li class="chapter-item expanded "><a href="ch04-04-ReturnValues.html"><strong aria-hidden="true">4.4.</strong> Return Values</a></li><li class="chapter-item expanded "><a href="ch04-05-Lambda.html"><strong aria-hidden="true">4.5.</strong> Lambda Expressions</a></li><li class="chapter-item expanded "><a href="ch04-06-APIPackagesModulesJavadoc.html"><strong aria-hidden="true">4.6.</strong> API, Packages, Modules and Javadoc</a></li><li class="chapter-item expanded "><a href="ch04-07-MoreOnProgramDesign.html"><strong aria-hidden="true">4.7.</strong> More on Program Design</a></li><li class="chapter-item expanded "><a href="ch04-08-TruthAboutDeclarations.html"><strong aria-hidden="true">4.8.</strong> Truth about Declarations</a></li><li class="chapter-item expanded "><a href="ch04-09-Exercises.html"><strong aria-hidden="true">4.9.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch04-10-Quiz.html"><strong aria-hidden="true">4.10.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-ObjectsClasses.html"><strong aria-hidden="true">5.</strong> Objects and Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-ObjectsAndInstanceMethods.html"><strong aria-hidden="true">5.1.</strong> Objects and Instance Methods</a></li><li class="chapter-item expanded "><a href="ch05-02-ConstructorObjectInit.html"><strong aria-hidden="true">5.2.</strong> Constructor and Object Initialization</a></li><li class="chapter-item expanded "><a href="ch05-03-ProgrammingWithObjects.html"><strong aria-hidden="true">5.3.</strong> Programming with Objects</a></li><li class="chapter-item expanded "><a href="ch05-04-AnExample.html"><strong aria-hidden="true">5.4.</strong> An Example</a></li><li class="chapter-item expanded "><a href="ch05-05-InheritanceAndPolymorphism.html"><strong aria-hidden="true">5.5.</strong> Inheritance and Polymorphism</a></li><li class="chapter-item expanded "><a href="ch05-06-thisandsuper.html"><strong aria-hidden="true">5.6.</strong> this and super</a></li><li class="chapter-item expanded "><a href="ch05-07-Interfaces.html"><strong aria-hidden="true">5.7.</strong> Interfaces</a></li><li class="chapter-item expanded "><a href="ch05-08-NestedClasses.html"><strong aria-hidden="true">5.8.</strong> Nested Classes</a></li><li class="chapter-item expanded "><a href="ch05-09-Exercises.html"><strong aria-hidden="true">5.9.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch05-10-Quiz.html"><strong aria-hidden="true">5.10.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-GUIProgramming.html"><strong aria-hidden="true">6.</strong> Introduction to GUI Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-BasicJavaFXApp.html"><strong aria-hidden="true">6.1.</strong> A Basic JavaFX Application</a></li><li class="chapter-item expanded "><a href="ch06-02-BasicClasses.html"><strong aria-hidden="true">6.2.</strong> Basic Classes</a></li><li class="chapter-item expanded "><a href="ch06-03-BasicEvents.html"><strong aria-hidden="true">6.3.</strong> Basic Events</a></li><li class="chapter-item expanded "><a href="ch06-04-BasicControls.html"><strong aria-hidden="true">6.4.</strong> Basic Controls</a></li><li class="chapter-item expanded "><a href="ch06-05-BasicLayout.html"><strong aria-hidden="true">6.5.</strong> Basic Layout</a></li><li class="chapter-item expanded "><a href="ch06-06-CompetePrograms.html"><strong aria-hidden="true">6.6.</strong> Complete Programs</a></li><li class="chapter-item expanded "><a href="ch06-07-Exercises.html"><strong aria-hidden="true">6.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch06-08-Quiz.html"><strong aria-hidden="true">6.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-ArraysArraylistsRecords.html"><strong aria-hidden="true">7.</strong> Arrays, ArrayLists and Records</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-ArrayDetails.html"><strong aria-hidden="true">7.1.</strong> Array Details</a></li><li class="chapter-item expanded "><a href="ch07-02-ArrayProcessing.html"><strong aria-hidden="true">7.2.</strong> Array Processing</a></li><li class="chapter-item expanded "><a href="ch07-03-ArrayLists.html"><strong aria-hidden="true">7.3.</strong> ArrayLists</a></li><li class="chapter-item expanded "><a href="ch07-04-Records.html"><strong aria-hidden="true">7.4.</strong> Records</a></li><li class="chapter-item expanded "><a href="ch07-05-SearchingAndSorting.html"><strong aria-hidden="true">7.5.</strong> Searching and Sorting</a></li><li class="chapter-item expanded "><a href="ch07-06-2DArrays.html"><strong aria-hidden="true">7.6.</strong> 2D Arrays</a></li><li class="chapter-item expanded "><a href="ch07-07-Exercises.html"><strong aria-hidden="true">7.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch07-08-Quiz.html"><strong aria-hidden="true">7.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-CorrectnessRobustnessEfficiency.html"><strong aria-hidden="true">8.</strong> Correctness, Robustness, Efficiency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-IntroductionCorrectnessandRobustness.html"><strong aria-hidden="true">8.1.</strong> Introduction to Correctness and Robustness</a></li><li class="chapter-item expanded "><a href="ch08-02-WritingCorrectPrograms.html"><strong aria-hidden="true">8.2.</strong> Writing Correct Programs</a></li><li class="chapter-item expanded "><a href="ch08-03-ExceptionsAndtrycatch.html"><strong aria-hidden="true">8.3.</strong> Exceptions and try..catch</a></li><li class="chapter-item expanded "><a href="ch08-04-AssertionsAnnotations.html"><strong aria-hidden="true">8.4.</strong> Assertions and Annotations</a></li><li class="chapter-item expanded "><a href="ch08-05-AnalysisofAlgorithms.html"><strong aria-hidden="true">8.5.</strong> Analysis of Algorithms</a></li><li class="chapter-item expanded "><a href="ch08-06-Exercises.html"><strong aria-hidden="true">8.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch08-07-Quiz.html"><strong aria-hidden="true">8.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-LinkedDataStructuresRecursion.html"><strong aria-hidden="true">9.</strong> Linked Data Structures and Recursion</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-Recursion.html"><strong aria-hidden="true">9.1.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="ch09-02-LinkedDataStructures.html"><strong aria-hidden="true">9.2.</strong> Linked Data Structures</a></li><li class="chapter-item expanded "><a href="ch09-03-StacksQueuesADTs.html"><strong aria-hidden="true">9.3.</strong> Stacks, Queues and ADTs</a></li><li class="chapter-item expanded "><a href="ch09-04-BinaryTrees.html"><strong aria-hidden="true">9.4.</strong> Binary Trees</a></li><li class="chapter-item expanded "><a href="ch09-05-SimpleRecursiveDescentParser.html"><strong aria-hidden="true">9.5.</strong> A Simple Recursive Descent Parser</a></li><li class="chapter-item expanded "><a href="ch09-06-Exercises.html"><strong aria-hidden="true">9.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch09-07-Quiz.html"><strong aria-hidden="true">9.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-GenericProgrammingandCollectionClasses.html"><strong aria-hidden="true">10.</strong> Generic Programmingand Collection Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-GenericProgramming.html"><strong aria-hidden="true">10.1.</strong> Generic Programming</a></li><li class="chapter-item expanded "><a href="ch10-02-ListsandSets.html"><strong aria-hidden="true">10.2.</strong> Lists and Sets</a></li><li class="chapter-item expanded "><a href="ch10-03-Maps.html"><strong aria-hidden="true">10.3.</strong> Maps</a></li><li class="chapter-item expanded "><a href="ch10-04-JCF.html"><strong aria-hidden="true">10.4.</strong> Programming with the JCF</a></li><li class="chapter-item expanded "><a class="active" href="ch10-05-WritingGenericClassesandMethods.html"><strong aria-hidden="true">10.5.</strong> Writing Generic Classes and Methods</a></li><li class="chapter-item expanded "><a href="ch10-06-StreamAPI.html"><strong aria-hidden="true">10.6.</strong> Stream APIs</a></li><li class="chapter-item expanded "><a href="ch10-07-Exercises.html"><strong aria-hidden="true">10.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch10-08-Quiz.html"><strong aria-hidden="true">10.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-IOStreamsFilesNetworking.html"><strong aria-hidden="true">11.</strong> I/O Streams, Files, and Networking</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-IOStreamsReadersAndWriters.html"><strong aria-hidden="true">11.1.</strong> I/O Streams, Readers, and Writers</a></li><li class="chapter-item expanded "><a href="ch11-02-Files.html"><strong aria-hidden="true">11.2.</strong> Files</a></li><li class="chapter-item expanded "><a href="ch11-03-ProgrammingWithFiles.html"><strong aria-hidden="true">11.3.</strong> Programming With Files</a></li><li class="chapter-item expanded "><a href="ch11-04-Networking.html"><strong aria-hidden="true">11.4.</strong> Networking</a></li><li class="chapter-item expanded "><a href="ch11-05-XML.html"><strong aria-hidden="true">11.5.</strong> A Brief Introduction to XML</a></li><li class="chapter-item expanded "><a href="ch11-06-Exercises.html"><strong aria-hidden="true">11.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch11-07-Quiz.html"><strong aria-hidden="true">11.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-ThreadsandMultiprocessing.html"><strong aria-hidden="true">12.</strong> Threads and Multiprocessing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-IntroductiontoThreads.html"><strong aria-hidden="true">12.1.</strong> Introduction to Threads</a></li><li class="chapter-item expanded "><a href="ch12-02-ProgrammingwithThreads.html"><strong aria-hidden="true">12.2.</strong> Programming with Threads</a></li><li class="chapter-item expanded "><a href="ch12-03-ThreadsandParallelProcessing.html"><strong aria-hidden="true">12.3.</strong> Threads and Parallel Processing</a></li><li class="chapter-item expanded "><a href="ch12-04-ThreadsandNetworking.html"><strong aria-hidden="true">12.4.</strong> Threads and Networking</a></li><li class="chapter-item expanded "><a href="ch12-05-NetworkProgrammingExample.html"><strong aria-hidden="true">12.5.</strong> Network Programming Example</a></li><li class="chapter-item expanded "><a href="ch12-06-Exercises.html"><strong aria-hidden="true">12.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch12-07-Quiz.html"><strong aria-hidden="true">12.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-GUIProgrammingContinued.html"><strong aria-hidden="true">13.</strong> GUI Programming Continued</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-PropertiesandBindings.html"><strong aria-hidden="true">13.1.</strong> Properties and Bindings</a></li><li class="chapter-item expanded "><a href="ch13-02-FancierGraphics.html"><strong aria-hidden="true">13.2.</strong> Fancier Graphics</a></li><li class="chapter-item expanded "><a href="ch13-03-ComplexComponentsandMVC.html"><strong aria-hidden="true">13.3.</strong> Complex Components and MVC</a></li><li class="chapter-item expanded "><a href="ch13-04-MostlyWindowsandDialogs.html"><strong aria-hidden="true">13.4.</strong> Mostly Windows and Dialogs</a></li><li class="chapter-item expanded "><a href="ch13-05-FinishingTouches.html"><strong aria-hidden="true">13.5.</strong> Finishing Touches</a></li><li class="chapter-item expanded "><a href="ch13-06-Exercises.html"><strong aria-hidden="true">13.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch13-07-Quiz.html"><strong aria-hidden="true">13.7.</strong> Quiz</a></li></ol><li class="chapter-item expanded "><a href="appendix-00.html"> Appendix</a></li><li class="chapter-item expanded "><a href="glossary-00.html"> Glossary</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="Java">Java</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Introduction to Programming Using Java</h1>

                    <div class="right-buttons">

                        <a href="https://github.com/Xayarsh/Java-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Writing Generic Classes and Methods"><a class="header" href="#Writing Generic Classes and Methods">Writing Generic Classes and Methods</a></h2>
                        <p>
                            So far in this chapter, you have learned
                            about using the generic classes and methods that are part of the
                            Java Collection Framework.  Now, it's time to learn how to write
                            new generic classes and methods from scratch.  Generic programming produces
                            highly general and reusable code&mdash;it's very useful for people
                            who write reusable software libraries to know how to do generic
                            programming, since it enables them to write code that can be used in
                            many different situations.  Not every programmer needs to write reusable
                            software libraries, but every programmer should know at least a little
                            about how to do it.  In fact, just to read the Javadoc documentation for
                            Java's standard generic classes, you need to know some of the syntax that is
                            introduced in this section.</p>


                        <p>I will not cover every detail of generic programming in Java in this
                            section, but the material presented here should be sufficient to cover the
                            most common cases.</p>


                        <h3 id="Simple Generic Classes"><a class="header" href="#Simple Generic Classes">Simple Generic Classes</a></h3>

                        <p>Let's start with an example that illustrates the motivation for generic
                            programming.  In <a href="ch10-02-ListsandSets.html">Subsection&nbsp;10.2.1</a>, I remarked that it would
                            be easy to use a <span class="classname">LinkedList</span> to implement a queue.
                            (Queues were introduced in <a href="ch09-03-StacksQueuesADTs.html">Subsection&nbsp;9.3.2</a>.)
                            To ensure that the only operations that are performed on the list are
                            the queue operations <span class="code">enqueue</span>, <span class="code">dequeue</span>, and
                            <span class="code">isEmpty</span>, we can create a new class that contains the
                            linked list as a private instance variable.  To implement
                            queues of strings, for example, we can define the class:</p>


                        <pre><code class="java">class QueueOfStrings {
   private LinkedList&lt;String&gt; items = new LinkedList&lt;&gt;();
   public void enqueue(String item) {
      items.addLast(item);
   }
   public String dequeue() {
      return items.removeFirst();
   }
   public boolean isEmpty() {
      return (items.size() == 0);
   }
}</code></pre>


                        <p>This is a fine and useful class.  But, if this is how we write queue classes, and
                            if we want queues of <span class="classname">Integers</span>
                            or <span class="classname">Doubles</span> or <span class="classname">Colors</span> or any other type,
                            then we will have to write a different class for each type.  The code for all of these
                            classes will be almost identical, which seems like a lot of redundant programming.
                            To avoid the redundancy, we can write a <b>generic</b> <span class="classname">Queue</span>
                            class that can be used to define queues of any type of object.</p>


                        <p>The syntax for writing the generic class is straightforward: We replace the specific
                            type <span class="classname">String</span> with a type parameter such as&nbsp;<span class="classname">T</span>,
                            and we add the type parameter to the name of the class:</p>


                        <pre><code class="java">class Queue&lt;T&gt; {
   private LinkedList&lt;T&gt; items = new LinkedList&lt;&gt;();
   public void enqueue(T item) {
      items.addLast(item);
   }
   public T dequeue() {
      return items.removeFirst();
   }
   public boolean isEmpty() {
      return (items.size() == 0);
   }
}</code></pre>


                        <p>Note that within the class, the type parameter <span class="classname">T</span> is used
                            just like any regular type name.  It's used to declare the return type for
                            <span class="code">dequeue</span>, as the type of the formal parameter <span class="code">item</span> in
                            <span class="code">enqueue</span>, and even as the actual type parameter in <span class="classname">LinkedList&lt;T&gt;</span>.
                            Given this class definition, we can use parameterized types such
                            as <span class="classname">Queue&lt;String&gt;</span> and <span class="classname">Queue&lt;Integer&gt;</span>
                            and <span class="classname">Queue&lt;Color&gt;</span>.  That is, the <span class="classname">Queue</span> class
                            is used in exactly the same way as built-in generic classes like <span class="classname">LinkedList</span>
                            and <span class="classname">HashSet</span>.</p>


                        <p>Note that you don't have to use "T" as the name of the type parameter in the
                            definition of the generic class.  Type parameters are like formal parameters in subroutines.
                            You can make up any name you like in the <b>definition</b> of the class.  The
                            name in the definition will be replaced by an actual type name when the class
                            is used to declare variables or create objects.  If you prefer to use a more
                            meaningful name for the type parameter, you might define the <span class="classname">Queue</span>
                            class as:</p>


                        <pre><code class="java">class Queue&lt;<span class="newcode">ItemType</span>&gt; {
   private LinkedList&lt;<span class="newcode">ItemType</span>&gt; items = new LinkedList&lt;&gt;();
   public void enqueue(<span class="newcode">ItemType</span> item) {
      items.addLast(item);
   }
   public <span class="newcode">ItemType</span> dequeue() {
      return items.removeFirst();
   }
   public boolean isEmpty() {
      return (items.size() == 0);
   }
}</code></pre>


                        <p>Changing the name from "<span class="code">T</span>" to "<span class="code">ItemType</span>" has absolutely no effect on the meaning
                            of the class definition or on the way that <span class="classname">Queue</span> is used.</p>


                        <p>Generic interfaces can be defined in a similar way.
                            It's also easy to define generic classes and interfaces that have two or more type parameters,
                            as is done with the standard interface <span class="classname">Map&lt;K,V&gt;</span>.
                            A typical example is the definition of a "Pair" that contains two objects,
                            possibly of different types.  A simple version of such a class can be defined as:</p>


                        <pre><code class="java">public class Pair&lt;T,S&gt; {
   public T first;
   public S second;
   public Pair( T a, S b ) {  // Constructor.
      first = a;
      second = b;
   }
}</code></pre>


                        <p>This class can be used to declare variables and create objects such as:</p>


                        <pre><code class="java">Pair&lt;String,Color&gt; colorName = new Pair&lt;&gt;("Red", Color.RED);
Pair&lt;Double,Double&gt; coordinates = new Pair&lt;&gt;(17.3,42.8);</code></pre>


                        <p>Note that in the definition of the constructor in this class, the name "<span class="code">Pair</span>"
                            does <b>not</b> have type parameters.  You might have expected "<span class="code">Pair&lt;T,S&gt;</span>".
                            However, the name of the class is "<span class="code">Pair</span>", not "<span class="code">Pair&lt;T,S&gt;</span>",
                            and within the definition of the class, "<span class="code">T</span>" and "<span class="code">S</span>" are used
                            as if they are the names of specific, actual types.  Note in any case that type
                            parameters are <b>never</b> added to the names of methods or constructors, only
                            to the names of classes and interfaces.</p>


                        <p>Record classes can also be generic.  For example, a generic record class
                            version of <span class="classname">Pair</span> could be defined simply as</p>


                        <pre><code class="java">public record Pair(T a, S b) { }</code></pre>


                        <h3 id="Simple Generic Methods"><a class="header" href="#Simple Generic Methods">Simple Generic Methods</a></h3>


                        <p>In addition to generic classes, Java also has generic methods.  An example
                            is the method <span class="code">Collections.sort()</span>, which can sort collections of
                            objects of any type.  To see how to write generic methods, let's start
                            with a non-generic method for counting the number of times that a
                            given string occurs in an array of strings:</p>


                        <pre><code class="java">/**
 * Returns the number of times that itemToCount occurs in list.  Items in the
 * list are tested for equality using itemToCount.equals(), except in the
 * special case where itemToCount is null.
 */
public static int countOccurrences(String[] list, String itemToCount) {
   int count = 0;
   if (itemToCount == null) {
      for ( String listItem : list )
         if (listItem == null)
            count++;
   }
   else {
      for ( String listItem : list )
         if (itemToCount.equals(listItem))
            count++;
   }
   return count;
}</code></pre>


                        <p>Once again, we have some code that works for type <span class="classname">String</span>,
                            and we can imagine writing almost identical code to work with other types of objects.
                            By writing a generic method, we get to write a single method definition that will
                            work for objects of any non-primitive type.  We need to replace the specific type <span class="classname">String</span>
                            in the definition of the method with the name of a type parameter, such as&nbsp;<span class="classname">T</span>.
                            However, if that's the only change we make, the compiler will think that "T" is the name
                            of an actual type, and it will mark it as an undeclared identifier.  We need some way of
                            telling the compiler that "T" is a type parameter.  That's what the "<span class="code">&lt;T&gt;</span>"
                            does in the definition of the generic class "<span class="code">class&nbsp;Queue&lt;T&gt;&nbsp;{&nbsp;...</span>".
                            For a generic method, the "<span class="code">&lt;T&gt;</span>" goes just before the name of the return
                            type of the method:</p>


                        <pre><code class="java">public static &lt;T&gt; int countOccurrences(T[] list, T itemToCount) {
   int count = 0;
   if (itemToCount == null) {
      for ( T listItem : list )
         if (listItem == null)
            count++;
   }
   else {
      for ( T listItem : list )
         if (itemToCount.equals(listItem))
            count++;
   }
   return count;
}</code></pre>


                        <p>The "<span class="code">&lt;T&gt;</span>" marks the method as being generic and specifies the name
                            of the type parameter that will be used in the definition.  Of course, the name of the
                            type parameter doesn't have to be "T"; it can be anything.  (The "<span class="code">&lt;T&gt;</span>"
                            looks a little strange in that position, I know, but it had to go somewhere and
                            that's just where the designers of Java decided to put it.)</p>


                        <p>Given the generic method definition, we can apply it to objects of any type.
                            If <span class="code">wordList</span> is a variable of type
                            <span class="atype">String[]</span> and <span class="code">word</span> is a variable of type <span class="classname">String</span>,
                            then</p>


                        <pre><code class="java">int ct = countOccurrences( wordList, word );</code></pre>


                        <p>will count the number of times that <span class="code">word</span> occurs in <span class="code">wordList</span>.
                            If <span class="code">palette</span> is a variable of type <span class="atype">Color[]</span> and
                            <span class="code">color</span> is a variable of type <span class="classname">Color</span>, then</p>


                        <pre><code class="java">int ct = countOccurrences( palette, color );</code></pre>


                        <p>will count the number of times that <span class="code">color</span> occurs in <span class="code">palette</span>.
                            If <span class="code">numbers</span> is a variable of type <span class="atype">Integer[]</span>, then</p>


                        <pre><code class="java">int ct = countOccurrences( numbers, 17 );</code></pre>


                        <p>will count the number of times that <span class="code">17</span> occurs in <span class="code">numbers</span>.
                            This last example uses autoboxing; the 17 is automatically converted to a value of
                            type <span class="classname">Integer</span>.  Note that,
                            since generic programming in Java applies only to objects, we <b>cannot</b> use
                            <span class="code">countOccurrences</span> to count the number of occurrences of 17 in an
                            array of type <span class="atype">int[]</span>.</p>


                        <p>A generic method can have one or more type parameters, such as the "T" in
                            <span class="code">countOccurrences</span>.  Note that when a generic method is used,
                            as in the function call "<span class="code">countOccurrences(wordlist, word)</span>",
                            there is no explicit mention of the type that is substituted for the
                            type parameter.  The compiler deduces the type from the types of the
                            actual parameters in the method call.  Since <span class="code">wordlist</span> is
                            of type <span class="atype">String[]</span>, the compiler can tell that in
                            "<span class="code">countOccurrences(wordlist, word)</span>", the type that replaces
                            <span class="classname">T</span> is <span class="classname">String</span>.  This contrasts
                            with the use of generic classes, as in "<span class="code">Queue&lt;String&gt;</span>",
                            where the type parameter is specified explicitly.</p>


                        <p>The <span class="code">countOccurrences</span> method operates on an array.
                            We could also write a similar method to count occurrences of an object
                            in any collection:</p>


                        <pre><code class="java">public static &lt;T&gt; int countOccurrences(Collection&lt;T&gt; collection, T itemToCount) {
   int count = 0;
   if (itemToCount == null) {
      for ( T item : collection )
         if (item == null)
            count++;
   }
   else {
      for ( T item : collection )
         if (itemToCount.equals(item))
            count++;
   }
   return count;
}</code></pre>


                        <p>Since <span class="classname">Collection&lt;T&gt;</span> is itself a generic type,
                            this method is very general.  It can operate on an <span class="classname">ArrayList</span>
                            of <span class="classname">Integers</span>, a <span class="classname">TreeSet</span> of <span class="classname">Strings</span>,
                            a <span class="classname">LinkedList</span> of
                            <span class="classname">Buttons</span>,&nbsp;....</p>

                        <h3 id="Wildcard Types"><a class="header" href="#Wildcard Types">Wildcard Types</a></h3>

                        <p>There is a limitation on the sort of generic classes and methods that we have
                            looked at so far:  The type parameter in our examples, usually named <span class="classname">T</span>,
                            can be any type at all.  This is OK in many cases, but it means that the only things that
                            you can do with <span class="classname">T</span> are things that can be done with <b>every</b> type,
                            and the only things that you can do with objects of type <span class="classname">T</span>
                            are things that you can do with <b>every</b> object.  With the techniques that we have
                            covered so far, you can't, for example, write a generic method that compares
                            objects with the <span class="code">compareTo()</span> method, since that
                            method is not defined for all objects.  The <span class="code">compareTo()</span> method is
                            defined in the <span class="classname">Comparable</span> interface.  What we need is a
                            way of specifying that a generic class or method only applies to objects of
                            type <span class="classname">Comparable</span> and not to arbitrary objects.  With that
                            restriction, we should be free to use <span class="code">compareTo()</span> in the definition of
                            the generic class or method.</p>


                        <p>There are two different but related syntaxes for putting restrictions on the
                            types that are used in generic programming.  One of these is <span class="newword">bounded type parameters</span>,
                            which are used as formal type parameters in generic class and method definitions;
                            a bounded type parameter would be used in place of the simple type parameter <span class="classname">T</span>
                            in "<span class="code">class GenericClass&lt;T&gt;&nbsp;...</span>" or in "<span class="code">public static
&lt;T&gt; void genericMethod(...</span>".  The second syntax is <span class="newword">wildcard
types</span>, which are used as type parameters in the declarations of
                            variables and of formal parameters in method definitions; a wildcard type could be used in
                            place of the type parameter <span class="classname">String</span> in the declaration
                            statement "<span class="code">List&lt;String&gt;&nbsp;list;</span>" or in the formal parameter list
                            "<span class="code">void concat(Collection&lt;String&gt;&nbsp;c)</span>".  We will look at
                            wildcard types first, and we will return to the topic of bounded types later
                            in this section.</p>


                        <p>Let's start with a simple example in which a wildcard type is useful.
                            Suppose that <span class="classname">Shape</span> is
                            a class that defines a method <span class="code">public void draw()</span>, and suppose that
                            <span class="classname">Shape</span> has subclasses such as <span class="classname">Rect</span>
                            and <span class="classname">Oval</span>.  Suppose that we want a method that can draw
                            all the shapes in a collection of <span class="classname">Shapes</span>.  We might try:</p>


                        <pre><code class="java">public static void drawAll(Collection&lt;Shape&gt; shapes) {
   for ( Shape s : shapes )
      s.draw();
}</code></pre>


                        <p>This method works fine if we apply it to a variable of type
                            <span class="classname">Collection&lt;Shape&gt;</span>, or <span class="classname">ArrayList&lt;Shape&gt;</span>,
                            or any other collection class with type parameter <span class="classname">Shape</span>.
                            Suppose, however, that you have a list of <span class="classname">Rects</span> stored
                            in a variable named <span class="code">rectangles</span> of type <span class="classname">Collection&lt;Rect&gt;</span>.
                            Since <span class="classname">Rects</span> are <span class="classname">Shapes</span>, you might
                            expect to be able to call <span class="code">drawAll(rectangles)</span>.  Unfortunately, this
                            will not work; a collection of <span class="classname">Rects</span> is <b>not</b> considered
                            to be a collection of <span class="classname">Shapes</span>!  The variable <span class="code">rectangles</span>
                            cannot be assigned to the formal parameter <span class="code">shapes</span>.  The solution is to
                            replace the type parameter "<span class="code">Shape</span>" in the declaration of
                            <span class="code">shapes</span> with the wildcard type "<span class="code">?&nbsp;extends&nbsp;Shape</span>":
                        </p>


                        <pre><code class="java">public static void drawAll(Collection&lt;<span class="newcode">? extends Shape</span>&gt; shapes) {
   for ( Shape s : shapes )
      s.draw();
}</code></pre>


                        <p>The wildcard type "<span class="code">?&nbsp;extends&nbsp;Shape</span>" means roughly
                            "any type that is either equal to <span class="classname">Shape</span> or
                            that is a subclass of <span class="classname">Shape</span>".  When the formal
                            parameter, <span class="code">shapes</span>, is declared to be of type
                            <span class="classname">Collection&lt;?&nbsp;extends&nbsp;Shape&gt;</span>, it
                            becomes possible to call the <span class="code">drawAll</span> method with an actual
                            parameter of type <span class="classname">Collection&lt;Rect&gt;</span> since
                            <span class="classname">Rect</span> is a subclass of <span class="classname">Shape</span>
                            and therefore matches the wildcard.
                            We could also pass actual parameters to <span class="code">drawAll</span> of type
                            <span class="classname">ArrayList&lt;Rect&gt;</span> or <span class="classname">Set&lt;Oval&gt;</span>
                            or <span class="classname">List&lt;Oval&gt;</span>.  And we can still pass
                            variables of type <span class="classname">Collection&lt;Shape&gt;</span>
                            or <span class="classname">ArrayList&lt;Shape&gt;</span>, since the class
                            <span class="classname">Shape</span> itself matches "<span class="code">?&nbsp;extends&nbsp;Shape</span>".
                            We have greatly increased the usefulness of the method by using the
                            wildcard type.</p>


                        <p>(Although it is not essential, you might be interested in knowing <i>why</i>
                            Java does not allow a collection of <span class="classname">Rects</span> to be used
                            as a collection of <span class="classname">Shapes</span>, even though every <span class="classname">Rect</span>
                            is considered to be a <span class="classname">Shape</span>.  Consider the rather silly
                            but legal method that adds an oval to a list of shapes:</p>


                        <pre><code class="java">static void addOval(List&lt;Shape&gt; shapes, Oval oval) {
   shapes.add(oval);
}</code></pre>


                        <p>Suppose that <span class="code">rectangles</span> is of type <span class="classname">List&lt;Rect&gt;</span>.
                            It's illegal to call <span class="code">addOval(rectangles,oval)</span>, because of the rule that
                            a list of <span class="classname">Rects</span> is not a list of <span class="classname">Shapes</span>.
                            If we dropped that rule, then <span class="code">addOval(rectangles,oval)</span> would be legal,
                            and it would add an <span class="classname">Oval</span> to a list of <span class="classname">Rects</span>.
                            This would be bad: Since <span class="classname">Oval</span> is not a subclass of <span class="classname">Rect</span>,
                            an <span class="classname">Oval</span> is <b>not</b> a <span class="classname">Rect</span>,
                            and a list of <span class="classname">Rects</span> should never be able to contain an <span class="classname">Oval</span>.
                            The method call <span class="code">addOval(rectangles,oval)</span> does not make sense and
                            <b>should</b> be illegal.)</p>


                        <p>As another example, consider the method <span class="code">addAll()</span> from the
                            interface <span class="classname">Collection&lt;T&gt;</span>.  In my description of
                            this method in <a href="ch10-01-GenericProgramming.html">Subsection&nbsp;10.1.4</a>, I say that for a collection, <span class="code">coll</span>,
                            of type <span class="classname">Collection&lt;T&gt;</span>, <span class="code">coll.addAll(coll2)</span>
                            "adds all the objects in <span class="code">coll2</span> to <span class="code">coll</span>. The parameter, <span class="code">coll2</span>,
                            can be any collection of type <span class="classname">Collection&lt;T&gt;</span>. However, it can also be
                            more general. For example, if <span class="classname">T</span> is a class and <span class="classname">S</span>
                            is a subclass of <span class="classname">T</span>, then <span class="code">coll2</span> can be of type
                            <span class="classname">Collection&lt;S&gt;</span>.  This makes sense because any object of type <span class="classname">S</span>
                            is automatically of type <span class="classname">T</span> and so can legally be added to <span class="code">coll</span>."
                            If you think for a moment, you'll see that what I'm
                            describing here, a little awkwardly, is a use of wildcard types: We don't want to
                            require <span class="code">coll2</span> to be a collection of objects of type <span class="classname">T</span>;
                            we want to allow collections of any subclass of <span class="classname">T</span>.
                            To be more specific, let's look at how a similar <span class="code">addAll()</span> method could
                            be added to the generic <span class="classname">Queue</span> class that was defined earlier
                            in this section:</p>


                        <pre><code class="java">class Queue&lt;T&gt; {
   private LinkedList&lt;T&gt; items = new LinkedList&lt;T&gt;();
   public void enqueue(T item) {
      items.addLast(item);
   }
   public T dequeue() {
      return items.removeFirst();
   }
   public boolean isEmpty() {
      return (items.size() == 0);
   }
   <span class="newcode">public void addAll(Collection&lt;? extends T&gt; collection) {
         // Add all the items from the collection to the end of the queue
      for ( T item : collection )
         enqueue(item);
   }</span>
}</code></pre>


                        <p>Here, <span class="classname">T</span> is a type parameter in the generic class definition.
                            We are combining wildcard types with generic classes.
                            Inside the generic class definition, "<span class="code">T</span>" is used as if it is a specific, though unknown, type.
                            The wildcard type "<span class="code">?&nbsp;extends&nbsp;T</span>" means some type that is equal to or extends that specific type.
                            When we create a queue of type <span class="classname">Queue&lt;Shape&gt;</span>, "<span class="code">T</span>" refers to "Shape",
                            and the wildcard type "<span class="code">?&nbsp;extends&nbsp;T</span>" in the class definition means
                            "<span class="code">?&nbsp;extends&nbsp;Shape</span>". This ensures that the <span class="code">addAll</span> method of the queue
                            can be applied to collections of <span class="classname">Rects</span> and <span class="classname">Ovals</span>
                            as well as to collections of <span class="classname">Shapes</span>.</p>


                        <p>The for-each loop in the definition of <span class="code">addAll</span> iterates through the
                            <span class="code">collection</span> using a variable, <span class="code">item</span>, of type <span class="classname">T</span>.
                            Now, <span class="code">collection</span> can be of type <span class="classname">Collection&lt;S&gt;</span>,
                            where <span class="classname">S</span> is a subclass of <span class="classname">T</span>.  Since
                            <span class="code">item</span> is of type <span class="classname">T</span>, not <span class="classname">S</span>,
                            do we have a problem here?  No, no problem.  As long as <span class="classname">S</span> is a
                            subclass of <span class="classname">T</span>, a value of type <span class="classname">S</span> can
                            be assigned to a variable of type <span class="classname">T</span>.  The restriction
                            on the wildcard type makes everything work nicely.</p>


                        <p>The <span class="code">addAll</span> method adds all the items from a collection to the queue.
                            Suppose that we wanted to do the opposite: Add all the items that are currently
                            in the queue to a given collection.  An instance method defined as</p>


                        <pre><code class="java">public void addAllTo(Collection&lt;T&gt; collection)</code></pre>


                        <p>would only work for collections whose base type is exactly the same as
                            <span class="classname">T</span>.  This is too restrictive.  We need some sort of wildcard.
                            However, "<span class="code">?&nbsp;extends&nbsp;T</span>" won't work.  Suppose we try it:</p>


                        <pre><code class="java">public void addAllTo(Collection&lt;? extends T&gt; collection) {
      // Remove all items currently on the queue and add them to collection
   while ( ! isEmpty() ) {
      T item = dequeue();  // Remove an item from the queue.
      collection.add( item );  // Add it to the collection.  <span class="newcode">ILLEGAL!!</span>
   }
}</code></pre>


                        <p>The problem is that we can't add an <span class="code">item</span> of type <span class="classname">T</span>
                            to a collection that might only be able to hold items belonging to some
                            subclass, <span class="classname">S</span>, of <span class="classname">T</span>.  The containment is
                            going in the wrong direction: An <span class="code">item</span> of type <span class="classname">T</span>
                            is not necessarily of type <span class="classname">S</span>.   For example, if we have
                            a queue of type <span class="classname">Queue&lt;Shape&gt;</span>, it doesn't make sense
                            to add items from the queue to a collection of type <span class="classname">Collection&lt;Rect&gt;</span>,
                            since not every <span class="classname">Shape</span> is a <span class="classname">Rect</span>.
                            On the other hand, if we have a <span class="classname">Queue&lt;Rect&gt;</span>, it would
                            make sense to add items from that queue to a <span class="classname">Collection&lt;Shape&gt;</span>
                            or indeed to any collection <span class="classname">Collection&lt;S&gt;</span> where
                            <span class="classname">S</span> is a <b>super</b>class of <span class="classname">Rect</span>.
                        </p>


                        <p>To express this type of relationship, we need a new kind of type wildcard:
                            "<span class="code">?&nbsp;super&nbsp;T</span>".  This wildcard means, roughly, "either <span class="classname">T</span>
                            itself or any class that is a superclass of <span class="classname">T</span>."  For example,
                            <span class="classname">Collection&lt;?&nbsp;super&nbsp;Rect&gt;</span> would
                            match the types <span class="classname">Collection&lt;Shape&gt;</span>,
                            <span class="classname">ArrayList&lt;Object&gt;</span>, and <span class="classname">Set&lt;Rect&gt;</span>.
                            This is what we need for our <span class="code">addAllTo</span> method.  With this change,
                            our complete generic queue class becomes:</p>


                        <pre><code class="java">class Queue&lt;T&gt; {
   private LinkedList&lt;T&gt; items = new LinkedList&lt;T&gt;();
   public void enqueue(T item) {
      items.addLast(item);
   }
   public T dequeue() {
      return items.removeFirst();
   }
   public boolean isEmpty() {
      return (items.size() == 0);
   }
   public void addAll(Collection&lt;? extends T&gt; collection) {
         // Add all the items from the collection to the end of the queue
      for ( T item : collection )
         enqueue(item);
   }
   <span class="newcode">public void addAllTo(Collection&lt;? super T&gt; collection) {
         // Remove all items currently on the queue and add them to collection
      while ( ! isEmpty() ) {
         T item = dequeue();  // Remove an item from the queue.
         collection.add( item );  // Add it to the collection.
      }
   }</span>
}</code></pre>



                        <p>In a wildcard type such as "<span class="code">?&nbsp;extends&nbsp;T</span>", <span class="classname">T</span>
                            can be an <span class="code">interface</span> instead of a class.  Note that the term
                            "<span class="code">extends</span>"  (not "<span class="code">implements</span>") is used
                            in the wildcard type, even if <span class="classname">T</span> is an interface.  For
                            example, we have seen that <span class="classname">Runnable</span> is an <span class="code">interface</span>
                            that defines the method <span class="code">public void run()</span>.
                            Here is a method that runs all the objects in a collection of
                            <span class="classname">Runnables</span> by executing the <span class="code">run()</span>
                            method from each runnable object:</p>


                        <pre><code class="java">public static runAll( Collection&lt;?&nbsp;extends&nbsp;Runnable&gt; runnables ) {
   for ( Runnable runnable : runnables ) {
      runnable.run();
   }
}</code></pre>


                        <p>Wildcard types are used <b>only</b> as type parameters in parameterized
                            types, such as <span class="classname">Collection&lt;?&nbsp;extends&nbsp;Runnable&gt;</span>.
                            The place where a wildcard type is most likely to occur, by far, is
                            in a formal parameter list, where the wildcard type is used in the declaration of the type
                            of a formal parameter.  However, they can also be used in a few other places.
                            For example, they can be used  in the type specification in a variable declaration
                            statement.</p>


                        <p>One final remark: The wildcard type "<span class="code">&lt;?&gt;</span>" is equivalent to
                            "<span class="code">&lt;?&nbsp;extends&nbsp;Object&gt;</span>".  That is, it matches any possible
                            type.  For example, the <span class="code">removeAll()</span> method in the generic interface
                            <span class="classname">Collection&lt;T&gt;</span> is declared as</p>


                        <pre><code class="java">public boolean removeAll( Collection&lt;?&gt; c ) { ...</code></pre>


                        <p>This just means that the <span class="code">removeAll</span> method can be applied to any
                            collection of any type of object.</p>


                        <h3 id="Bounded Types"><a class="header" href="#Bounded Types">Bounded Types</a></h3>

                        <p>Wildcard types don't solve all of our problems.  They allow us to generalize
                            method definitions so that they can work with collections of objects of various types,
                            rather than just a single type.  However, they do not allow us to restrict
                            the types that are allowed as formal type parameters in a generic class or method definition.
                            Bounded types exist for this purpose.</p>


                        <p>We start with a small, not very realistic example.
                            Suppose that you would like to create groups of GUI
                            components using a generic class named <span class="classname">ControlGroup</span>.
                            For example, the parameterized type
                            <span class="classname">ControlGroup&lt;Button&gt;</span>
                            would represent a group of <span class="classname">Buttons</span>, while
                            <span class="classname">ControlGroup&lt;Slider&gt;</span>
                            would represent a group
                            of <span class="classname">Sliders</span>.
                            The class will include methods that can be
                            called to apply certain operations to all components in the group at once.
                            For example, there will be an instance method of the form</p>


                        <pre><code class="java">public void disableAll() {
   .
   .  // Call c.setDisable(true) for every control, c, in the group.
   .
}</code></pre>


                        <p>The problem is that the <span class="code">setDisable()</span> method is defined in a
                            <span class="classname">Control</span> object,
                            but not for objects of arbitrary
                            type.  It wouldn't make sense to allow types such as
                            <span class="classname">ControlGroup&lt;String&gt;</span> or
                            <span class="classname">ControlGroup&lt;Integer&gt;</span>, since <span class="classname">Strings</span>
                            and <span class="classname">Integers</span> don't have <span class="code">setDisable()</span> methods.
                            We need some way to restrict the type parameter <span class="classname">T</span>
                            in <span class="classname">ControlGroup&lt;T&gt;</span> so that only
                            <span class="classname">Control</span>
                            and subclasses of <span class="classname">Control</span> are allowed
                            as actual type parameters.
                            We can do this by using the <span class="newword">bounded type</span>
                            "<span class="code">T&nbsp;extends&nbsp;Control</span>"
                            instead of a plain "<span class="code">T</span>" in the definition of the class:
                        </p>


                        <pre><code class="java">public class ControlGroup&lt;<span class="newcode">T extends Control</span>&gt; {
   private ArrayList&lt;T&gt; components; // For storing the components in this group.
   public void disableAll( ) {
      for ( Control c : components ) {
         if (c != null)
            c.setDisable(true);
      }
   }
   public void enableAll( ) {
      for ( Control c : components ) {
         if (c != null)
            c.setDisable(false);
      }
   }
   public void add( T c ) {  // Add a value c, of type T, to the group.
      components.add(c);
   }
   .
   .  // Additional methods and constructors.
   .
}</code></pre>


                        <p>The restriction "<span class="code">extends Control</span>" on <span class="code">T</span> makes it
                            illegal to create the parameterized types <span class="classname">ControlGroup&lt;String&gt;</span> and
                            <span class="classname">ControlGroup&lt;Integer&gt;</span>, since the actual type parameter
                            that replaces "<span class="code">T</span>" is required to be either
                            <span class="classname">Control</span> itself
                            or a subclass of <span class="classname">Control</span>.
                            With this restriction, we know&mdash;and, more important, the compiler knows&mdash;that
                            the objects in the group are of type <span class="classname">Control</span>, so that the
                            operation <span class="code">c.setDisable()</span> is defined for any <span class="code">c</span> in the group.</p>


                        <p>In general, a bounded type parameter "<span class="code">T&nbsp;extends&nbsp;SomeType</span>" means roughly
                            "a type, <span class="classname">T</span>, that is either equal to <span class="classname">SomeType</span>
                            or is a subclass of <span class="classname">SomeType</span>; the upshot is that any
                            object of type <span class="classname">T</span> is also of type <span class="classname">SomeType</span>, and
                            any operation that is defined for objects of type <span class="classname">SomeType</span>
                            is defined for objects of type <span class="classname">T</span>.  The type
                            <span class="classname">SomeType</span> doesn't have to be the name of a class.
                            It can be any name that represents an actual object type.  For example, it can be
                            an <span class="code">interface</span> or even a parameterized type.</p>


                        <p>Bounded types and wildcard types are clearly related.
                            They are, however, used in very different ways.  A bounded type can be used only
                            as a formal type parameter in the definition of a generic method, class, or interface.
                            A wildcard type is used most often to declare the type of a formal parameter in a
                            method and cannot be used as a formal type parameter.  One other difference, by
                            the way, is that, in contrast to wildcard types, bounded type parameters can only
                            use "<span class="code">extends</span>", never "<span class="code">super</span>".</p>


                        <p>Bounded type parameters can be used when declaring generic methods.
                            For example, as an alternative to the generic <span class="classname">ControlGroup</span>
                            class, one could write a free-standing generic <span class="code">static</span> method that can
                            disable any collection of
                            <span class="classname">Controls</span> as follows:</p>


                        <pre><code class="java">public static &lt;T extends Control&gt; void disableAll(Collection&lt;T&gt; comps) {
   for ( Control c : comps )
      if (c != null)
         c.setDisable(true);
}</code></pre>


                        <p>Using "<span class="code">&lt;T extends Control&gt;</span>" as the formal type parameter
                            means that the method can only be called for collections whose base type is
                            <span class="code">Control</span> or some subclass of <span class="code">Control</span>,
                            such as <span class="code">Button</span> or <span class="code">Slider</span>.</p>



                        <p>Note that we don't really need a generic type parameter in this case.  We can
                            write an equivalent method using a wildcard type:</p>


                        <pre><code class="java">public static void disableAll(Collection&lt;? extends Control&gt; comps) {
   for ( Control c : comps )
      if (c != null)
         c.setDisable(true);
}</code></pre>


                        <p>In this situation, the version that uses the wildcard type is to be preferred,
                            since the implementation is simpler.  However, there are some situations where
                            a generic method with a bounded type parameter cannot be rewritten using
                            a wildcard type. Note that a generic type parameter gives a name, such as <span class="classname">T</span>,
                            to the unknown type, while a wildcard type does not give a name to the unknown type.
                            The name makes it possible to refer to the unknown type in the body of the method
                            that is being defined.  If a generic method definition uses the generic type name
                            more than once or uses it outside the formal parameter list of the method,
                            then the generic type parameter cannot be replaced with a wildcard type.</p>


                        <p>Let's look at a generic method in which a bounded type parameter is essential.
                            In <a href="ch10-02-ListsandSets.html">Subsection&nbsp;10.2.1</a>, I presented a code segment for inserting
                            a string into a sorted list of strings, in such a way that the modified list
                            is still in sorted order.  Here is the same code, but this time in the form
                            of a method definition (and without the comments):</p>


                        <pre><code class="java">static void sortedInsert(List&lt;String&gt; sortedList, String newItem) {
   ListIterator&lt;String&gt; iter = sortedList.listIterator();
   while (iter.hasNext()) {
      String item = iter.next();
      if (newItem.compareTo(item) &lt;= 0) {
         iter.previous();
         break;
      }
   }
   iter.add(newItem);
}</code></pre>


                        <p>This method works fine for lists of strings, but it would be nice to have
                            a generic method that can be applied to lists of other types of objects.  The
                            problem, of course, is that the code assumes that the <span class="code">compareTo()</span>
                            method is defined for objects in the list, so the method can only work for
                            lists of objects that implement the <span class="classname">Comparable</span> interface.
                            We can't simply use a wildcard type to enforce this restriction.  Suppose we try to do it, by replacing
                            <span class="classname">List&lt;String&gt;</span> with
                            <span class="classname">List&lt;?&nbsp;extends&nbsp;Comparable&gt;</span>:</p>


                        <pre><code class="java">static void sortedInsert(List&lt;? extends Comparable&gt; sortedList, <span class="newcode">????</span> newItem) {
   ListIterator&lt;<span class="newcode">????</span>&gt; iter = sortedList.listIterator();
   ...</code></pre>


                        <p>We immediately run into a problem, because we have no name for the unknown
                            type represented by the wildcard.  We <b>need</b> a name for that type because
                            the type of <span class="code">newItem</span> and of <span class="code">iter</span> should be the same
                            as the type of the items in the list.  The problem is solved if we write a
                            generic method with a bounded type parameter, since then we have a name for
                            the unknown type, and we can write a valid generic method:</p>


                        <pre><code class="java">static &lt;T extends Comparable&gt; void sortedInsert(List&lt;T&gt; sortedList, T newItem) {
   ListIterator&lt;T&gt; iter = sortedList.listIterator();
   while (iter.hasNext()) {
      T item = iter.next();
      if (newItem.compareTo(item) &lt;= 0) {
         iter.previous();
         break;
      }
   }
   iter.add(newItem);
}</code></pre>


                        <p>There is still one technicality to cover in this example.  <span class="classname">Comparable</span>
                            is itself a parameterized type, but I have used it here without a type parameter.
                            This is legal but the compiler might give you a warning about using a "raw type."
                            In fact, the objects in the list should implement the parameterized interface
                            <span class="classname">Comparable&lt;T&gt;</span>, since they are being compared to items
                            of type <span class="classname">T</span>.  This just means that instead of using
                            <span class="classname">Comparable</span> as the type bound, we should use
                            <span class="classname">Comparable&lt;T&gt;</span>:</p>


                        <pre><code class="java">static &lt;T extends <span class="newcode">Comparable&lt;T&gt;</span>&gt; void sortedInsert(List&lt;T&gt; sortedList, ...</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch10-04-JCF.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch10-06-StreamAPI.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch10-04-JCF.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch10-06-StreamAPI.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </body>
</html>
