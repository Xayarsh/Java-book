<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Generic Programming - Introduction to Programming Using Java</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

<link rel="stylesheet" href="code-class.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html" >Introduction to Programming Using Java</a></li><li class="chapter-item expanded affix "><a href="preface.html">Preface</a></li><li class="chapter-item expanded "><a href="ch01-00-Overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-FetchExecuteCycle.html"><strong aria-hidden="true">1.1.</strong> Fetch and Execute Cycle</a></li><li class="chapter-item expanded "><a href="ch01-02-AsynchronousEvents.html"><strong aria-hidden="true">1.2.</strong> Asynchronous Events</a></li><li class="chapter-item expanded "><a href="ch01-03-JavaVirtualMachine.html"><strong aria-hidden="true">1.3.</strong> The Java Virtual Machine</a></li><li class="chapter-item expanded "><a href="ch01-04-FundamentalBuildingBlocks.html"><strong aria-hidden="true">1.4.</strong> Fundamentals</a></li><li class="chapter-item expanded "><a href="ch01-05-OOP.html"><strong aria-hidden="true">1.5.</strong> Object Oriented Programming</a></li><li class="chapter-item expanded "><a href="ch01-06-ModernUserInterface.html"><strong aria-hidden="true">1.6.</strong> Modern User Interface</a></li><li class="chapter-item expanded "><a href="ch01-07-InternetAndBeyond.html"><strong aria-hidden="true">1.7.</strong> Internet and Beyond</a></li><li class="chapter-item expanded "><a href="ch01-08-Quiz.html"><strong aria-hidden="true">1.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-NameAndThings.html"><strong aria-hidden="true">2.</strong> Name and Things</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-BasicJavaApplication.html"><strong aria-hidden="true">2.1.</strong> Basic Java Application</a></li><li class="chapter-item expanded "><a href="ch02-02-VariablesAndTypes.html"><strong aria-hidden="true">2.2.</strong> Variables and Types</a></li><li class="chapter-item expanded "><a href="ch02-03-ObjectsAndSubroutines.html"><strong aria-hidden="true">2.3.</strong> Objects and Subroutines</a></li><li class="chapter-item expanded "><a href="ch02-04-TextInputAndOutput.html"><strong aria-hidden="true">2.4.</strong> Text Input and Output</a></li><li class="chapter-item expanded "><a href="ch02-05-DetailsOfExpressions.html"><strong aria-hidden="true">2.5.</strong> Details of Expressions</a></li><li class="chapter-item expanded "><a href="ch02-06-ProgrammingEnvironments.html"><strong aria-hidden="true">2.6.</strong> Programming and Environments</a></li><li class="chapter-item expanded "><a href="ch02-07-Exercises.html"><strong aria-hidden="true">2.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch02-08-Quiz.html"><strong aria-hidden="true">2.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-Control.html"><strong aria-hidden="true">3.</strong> Control</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-BlocksLoopsBranches.html"><strong aria-hidden="true">3.1.</strong> Blocks, Loops and Branches</a></li><li class="chapter-item expanded "><a href="ch03-02-AlgorithmDevelopment.html"><strong aria-hidden="true">3.2.</strong> Algorithm Development</a></li><li class="chapter-item expanded "><a href="ch03-03-While.html"><strong aria-hidden="true">3.3.</strong> while and do...while</a></li><li class="chapter-item expanded "><a href="ch03-04-For.html"><strong aria-hidden="true">3.4.</strong> The for statement</a></li><li class="chapter-item expanded "><a href="ch03-05-If.html"><strong aria-hidden="true">3.5.</strong> The If Statement</a></li><li class="chapter-item expanded "><a href="ch03-06-Switch.html"><strong aria-hidden="true">3.6.</strong> The Switch Statement</a></li><li class="chapter-item expanded "><a href="ch03-07-ExceptionsTryCatch.html"><strong aria-hidden="true">3.7.</strong> Exceptions and try...catch</a></li><li class="chapter-item expanded "><a href="ch03-08-Arrays.html"><strong aria-hidden="true">3.8.</strong> Arrays: An Introduction</a></li><li class="chapter-item expanded "><a href="ch03-09-GUI.html"><strong aria-hidden="true">3.9.</strong> GUI: An Introduction</a></li><li class="chapter-item expanded "><a href="ch03-10-Exercises.html"><strong aria-hidden="true">3.10.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch03-11-Quiz.html"><strong aria-hidden="true">3.11.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-Subroutines.html"><strong aria-hidden="true">4.</strong> Subroutines</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-BlackBoxes.html"><strong aria-hidden="true">4.1.</strong> Black Boxes</a></li><li class="chapter-item expanded "><a href="ch04-02-StaticSubroutines.html"><strong aria-hidden="true">4.2.</strong> Static Subroutines and Variables</a></li><li class="chapter-item expanded "><a href="ch04-03-Parameters.html"><strong aria-hidden="true">4.3.</strong> Parameters</a></li><li class="chapter-item expanded "><a href="ch04-04-ReturnValues.html"><strong aria-hidden="true">4.4.</strong> Return Values</a></li><li class="chapter-item expanded "><a href="ch04-05-Lambda.html"><strong aria-hidden="true">4.5.</strong> Lambda Expressions</a></li><li class="chapter-item expanded "><a href="ch04-06-APIPackagesModulesJavadoc.html"><strong aria-hidden="true">4.6.</strong> API, Packages, Modules and Javadoc</a></li><li class="chapter-item expanded "><a href="ch04-07-MoreOnProgramDesign.html"><strong aria-hidden="true">4.7.</strong> More on Program Design</a></li><li class="chapter-item expanded "><a href="ch04-08-TruthAboutDeclarations.html"><strong aria-hidden="true">4.8.</strong> Truth about Declarations</a></li><li class="chapter-item expanded "><a href="ch04-09-Exercises.html"><strong aria-hidden="true">4.9.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch04-10-Quiz.html"><strong aria-hidden="true">4.10.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-ObjectsClasses.html"><strong aria-hidden="true">5.</strong> Objects and Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-ObjectsAndInstanceMethods.html"><strong aria-hidden="true">5.1.</strong> Objects and Instance Methods</a></li><li class="chapter-item expanded "><a href="ch05-02-ConstructorObjectInit.html"><strong aria-hidden="true">5.2.</strong> Constructor and Object Initialization</a></li><li class="chapter-item expanded "><a href="ch05-03-ProgrammingWithObjects.html"><strong aria-hidden="true">5.3.</strong> Programming with Objects</a></li><li class="chapter-item expanded "><a href="ch05-04-AnExample.html"><strong aria-hidden="true">5.4.</strong> An Example</a></li><li class="chapter-item expanded "><a href="ch05-05-InheritanceAndPolymorphism.html"><strong aria-hidden="true">5.5.</strong> Inheritance and Polymorphism</a></li><li class="chapter-item expanded "><a href="ch05-06-thisandsuper.html"><strong aria-hidden="true">5.6.</strong> this and super</a></li><li class="chapter-item expanded "><a href="ch05-07-Interfaces.html"><strong aria-hidden="true">5.7.</strong> Interfaces</a></li><li class="chapter-item expanded "><a href="ch05-08-NestedClasses.html"><strong aria-hidden="true">5.8.</strong> Nested Classes</a></li><li class="chapter-item expanded "><a href="ch05-09-Exercises.html"><strong aria-hidden="true">5.9.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch05-10-Quiz.html"><strong aria-hidden="true">5.10.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-GUIProgramming.html"><strong aria-hidden="true">6.</strong> Introduction to GUI Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-BasicJavaFXApp.html"><strong aria-hidden="true">6.1.</strong> A Basic JavaFX Application</a></li><li class="chapter-item expanded "><a href="ch06-02-BasicClasses.html"><strong aria-hidden="true">6.2.</strong> Basic Classes</a></li><li class="chapter-item expanded "><a href="ch06-03-BasicEvents.html"><strong aria-hidden="true">6.3.</strong> Basic Events</a></li><li class="chapter-item expanded "><a href="ch06-04-BasicControls.html"><strong aria-hidden="true">6.4.</strong> Basic Controls</a></li><li class="chapter-item expanded "><a href="ch06-05-BasicLayout.html"><strong aria-hidden="true">6.5.</strong> Basic Layout</a></li><li class="chapter-item expanded "><a href="ch06-06-CompetePrograms.html"><strong aria-hidden="true">6.6.</strong> Complete Programs</a></li><li class="chapter-item expanded "><a href="ch06-07-Exercises.html"><strong aria-hidden="true">6.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch06-08-Quiz.html"><strong aria-hidden="true">6.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-ArraysArraylistsRecords.html"><strong aria-hidden="true">7.</strong> Arrays, ArrayLists and Records</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-ArrayDetails.html"><strong aria-hidden="true">7.1.</strong> Array Details</a></li><li class="chapter-item expanded "><a href="ch07-02-ArrayProcessing.html"><strong aria-hidden="true">7.2.</strong> Array Processing</a></li><li class="chapter-item expanded "><a href="ch07-03-ArrayLists.html"><strong aria-hidden="true">7.3.</strong> ArrayLists</a></li><li class="chapter-item expanded "><a href="ch07-04-Records.html"><strong aria-hidden="true">7.4.</strong> Records</a></li><li class="chapter-item expanded "><a href="ch07-05-SearchingAndSorting.html"><strong aria-hidden="true">7.5.</strong> Searching and Sorting</a></li><li class="chapter-item expanded "><a href="ch07-06-2DArrays.html"><strong aria-hidden="true">7.6.</strong> 2D Arrays</a></li><li class="chapter-item expanded "><a href="ch07-07-Exercises.html"><strong aria-hidden="true">7.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch07-08-Quiz.html"><strong aria-hidden="true">7.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-CorrectnessRobustnessEfficiency.html"><strong aria-hidden="true">8.</strong> Correctness, Robustness, Efficiency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-IntroductionCorrectnessandRobustness.html"><strong aria-hidden="true">8.1.</strong> Introduction to Correctness and Robustness</a></li><li class="chapter-item expanded "><a href="ch08-02-WritingCorrectPrograms.html"><strong aria-hidden="true">8.2.</strong> Writing Correct Programs</a></li><li class="chapter-item expanded "><a href="ch08-03-ExceptionsAndtrycatch.html"><strong aria-hidden="true">8.3.</strong> Exceptions and try..catch</a></li><li class="chapter-item expanded "><a href="ch08-04-AssertionsAnnotations.html"><strong aria-hidden="true">8.4.</strong> Assertions and Annotations</a></li><li class="chapter-item expanded "><a href="ch08-05-AnalysisofAlgorithms.html"><strong aria-hidden="true">8.5.</strong> Analysis of Algorithms</a></li><li class="chapter-item expanded "><a href="ch08-06-Exercises.html"><strong aria-hidden="true">8.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch08-07-Quiz.html"><strong aria-hidden="true">8.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-LinkedDataStructuresRecursion.html"><strong aria-hidden="true">9.</strong> Linked Data Structures and Recursion</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-Recursion.html"><strong aria-hidden="true">9.1.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="ch09-02-LinkedDataStructures.html"><strong aria-hidden="true">9.2.</strong> Linked Data Structures</a></li><li class="chapter-item expanded "><a href="ch09-03-StacksQueuesADTs.html"><strong aria-hidden="true">9.3.</strong> Stacks, Queues and ADTs</a></li><li class="chapter-item expanded "><a href="ch09-04-BinaryTrees.html"><strong aria-hidden="true">9.4.</strong> Binary Trees</a></li><li class="chapter-item expanded "><a href="ch09-05-SimpleRecursiveDescentParser.html"><strong aria-hidden="true">9.5.</strong> A Simple Recursive Descent Parser</a></li><li class="chapter-item expanded "><a href="ch09-06-Exercises.html"><strong aria-hidden="true">9.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch09-07-Quiz.html"><strong aria-hidden="true">9.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-GenericProgrammingandCollectionClasses.html"><strong aria-hidden="true">10.</strong> Generic Programmingand Collection Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a class="active" href="ch10-01-GenericProgramming.html"><strong aria-hidden="true">10.1.</strong> Generic Programming</a></li><li class="chapter-item expanded "><a href="ch10-02-ListsandSets.html"><strong aria-hidden="true">10.2.</strong> Lists and Sets</a></li><li class="chapter-item expanded "><a href="ch10-03-Maps.html"><strong aria-hidden="true">10.3.</strong> Maps</a></li><li class="chapter-item expanded "><a href="ch10-04-JCF.html"><strong aria-hidden="true">10.4.</strong> Programming with the JCF</a></li><li class="chapter-item expanded "><a href="ch10-05-WritingGenericClassesandMethods.html"><strong aria-hidden="true">10.5.</strong> Writing Generic Classes and Methods</a></li><li class="chapter-item expanded "><a href="ch10-06-StreamAPI.html"><strong aria-hidden="true">10.6.</strong> Stream APIs</a></li><li class="chapter-item expanded "><a href="ch10-07-Exercises.html"><strong aria-hidden="true">10.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch10-08-Quiz.html"><strong aria-hidden="true">10.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-IOStreamsFilesNetworking.html"><strong aria-hidden="true">11.</strong> I/O Streams, Files, and Networking</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-IOStreamsReadersAndWriters.html"><strong aria-hidden="true">11.1.</strong> I/O Streams, Readers, and Writers</a></li><li class="chapter-item expanded "><a href="ch11-02-Files.html"><strong aria-hidden="true">11.2.</strong> Files</a></li><li class="chapter-item expanded "><a href="ch11-03-ProgrammingWithFiles.html"><strong aria-hidden="true">11.3.</strong> Programming With Files</a></li><li class="chapter-item expanded "><a href="ch11-04-Networking.html"><strong aria-hidden="true">11.4.</strong> Networking</a></li><li class="chapter-item expanded "><a href="ch11-05-XML.html"><strong aria-hidden="true">11.5.</strong> A Brief Introduction to XML</a></li><li class="chapter-item expanded "><a href="ch11-06-Exercises.html"><strong aria-hidden="true">11.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch11-07-Quiz.html"><strong aria-hidden="true">11.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-ThreadsandMultiprocessing.html"><strong aria-hidden="true">12.</strong> Threads and Multiprocessing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-IntroductiontoThreads.html"><strong aria-hidden="true">12.1.</strong> Introduction to Threads</a></li><li class="chapter-item expanded "><a href="ch12-02-ProgrammingwithThreads.html"><strong aria-hidden="true">12.2.</strong> Programming with Threads</a></li><li class="chapter-item expanded "><a href="ch12-03-ThreadsandParallelProcessing.html"><strong aria-hidden="true">12.3.</strong> Threads and Parallel Processing</a></li><li class="chapter-item expanded "><a href="ch12-04-ThreadsandNetworking.html"><strong aria-hidden="true">12.4.</strong> Threads and Networking</a></li><li class="chapter-item expanded "><a href="ch12-05-NetworkProgrammingExample.html"><strong aria-hidden="true">12.5.</strong> Network Programming Example</a></li><li class="chapter-item expanded "><a href="ch12-06-Exercises.html"><strong aria-hidden="true">12.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch12-07-Quiz.html"><strong aria-hidden="true">12.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-GUIProgrammingContinued.html"><strong aria-hidden="true">13.</strong> GUI Programming Continued</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-PropertiesandBindings.html"><strong aria-hidden="true">13.1.</strong> Properties and Bindings</a></li><li class="chapter-item expanded "><a href="ch13-02-FancierGraphics.html"><strong aria-hidden="true">13.2.</strong> Fancier Graphics</a></li><li class="chapter-item expanded "><a href="ch13-03-ComplexComponentsandMVC.html"><strong aria-hidden="true">13.3.</strong> Complex Components and MVC</a></li><li class="chapter-item expanded "><a href="ch13-04-MostlyWindowsandDialogs.html"><strong aria-hidden="true">13.4.</strong> Mostly Windows and Dialogs</a></li><li class="chapter-item expanded "><a href="ch13-05-FinishingTouches.html"><strong aria-hidden="true">13.5.</strong> Finishing Touches</a></li><li class="chapter-item expanded "><a href="ch13-06-Exercises.html"><strong aria-hidden="true">13.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch13-07-Quiz.html"><strong aria-hidden="true">13.7.</strong> Quiz</a></li></ol><li class="chapter-item expanded "><a href="appendix-00.html"> Appendix</a></li><li class="chapter-item expanded "><a href="glossary-00.html"> Glossary</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="Java">Java</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Introduction to Programming Using Java</h1>

                    <div class="right-buttons">

                        <a href="https://github.com/Xayarsh/Java-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Generic Programming"><a class="header" href="#Generic Programming">Generic Programming</a></h2>
                        <p>
                            Generic programming refers to writing code that
                            will work for many types of data.  We encountered the alternative to
                            generic programming in <a href="ch07-02-ArrayProcessing.html">Subsection&nbsp;7.2.4</a>, where we looked at dynamic arrays of
                            integers. The source code presented there for working with dynamic arrays of
                            integers works only for data of type <span class="ptype">int</span>. But the source code for
                            dynamic arrays of <span class="ptype">double</span>, <span class="classname">String</span>,
                            <span class="classname">Color</span>, or any
                            other type would be almost identical, except for the substitution of one type name
                            for another.  It seems silly to write essentially the
                            same code over and over.  Java's approach to this problem is parameterized types.
                            As we saw in <a href="ch07-03-ArrayLists.html">Section&nbsp;7.3</a>, the parameterized class
                            <span class="classname">ArrayList</span> implements dynamic arrays.  Since it
                            is parameterized, there are types such as <span class="atype">ArrayList&lt;String&gt;</span>
                            to represent dynamic arrays of <span class="classname">String</span>,
                            <span class="atype">ArrayList&lt;Color&gt;</span> for dynamic arrays of colors, and
                            more generally <span class="atype">ArrayList&lt;T&gt;</span> for any object type&nbsp;<span class="classname">T</span>.
                            <span class="classname">ArrayList</span> is just one class, but the source code works
                            for many different types.  This is generic programming.</p>


                        <p>The <span class="classname">ArrayList</span> class is just one of many standard
                            classes that are used for generic programming in Java. We will spend the next three sections
                            looking at some of these classes and how they are used, and we'll see that there are also
                            generic methods and generic interfaces. The classes and interfaces discussed in
                            these sections are defined in the package <span class="code">java.util</span>, and you will need
                            import statements at the beginning of your programs to get access to them.
                        </p>


                        <p>In <a href="ch10-05-WritingGenericClassesandMethods.html">Section&nbsp;10.5</a>, we will see that it is possible to define
                            new generic classes, interfaces, and methods.  Until then, we will stick to using
                            Java's predefined generics.  And in
                            <a href="ch10-06-StreamAPI.html">Section&nbsp;10.6</a>, we will look at <span class="newword">streams</span>,
                            a relatively new feature of Java that makes extensive use of generics.</p>


                        <p>It is no easy task to design a library for generic programming. Java's
                            solution has many nice features but is certainly not the only possible
                            approach. It is almost certainly not the best, and has a few features that
                            in my opinion can only be called bizarre, but in the context of the
                            overall design of Java, it might be close to optimal. To get some perspective
                            on generic programming in general, it might be useful to look very briefly at
                            some other approaches to generic programming.</p>


                        <h3 id="Generic Programming in Smalltalk"><a class="header" href="#Generic Programming in Smalltalk">Generic Programming in Smalltalk</a></h3>

                        <p>Smalltalk was one of the very first object-oriented programming languages.
                            It is still used today, although its use is not very common. It never achieved anything like the
                            popularity of Java or C++, but it is the source of many ideas used in these
                            languages. In Smalltalk, essentially all programming is generic, because of two
                            basic properties of the language.</p>


                        <p>First of all, variables in Smalltalk are typeless. A data value has a type,
                            such as integer or string, but variables do not have types. Any variable can
                            hold data of any type. Parameters are also typeless, so a subroutine can be
                            applied to parameter values of any type. Similarly, a data structure can hold
                            data values of any type. For example, once you've defined a binary tree data
                            structure in SmallTalk, you can use it for binary trees of integers or strings
                            or dates or data of any other type. There is simply no need to write new code
                            for each data type.</p>


                        <p>Secondly, all data values are objects, and all operations on objects are
                            defined by methods in a class. This is true even for types that are "primitive"
                            in Java, such as integers. When the "<span class="code">+</span>" operator is used to add two integers,
                            the operation is performed by calling a method in the integer class. When you
                            define a new class, you can define a "<span class="code">+</span>" operator, and you will then be able to
                            add objects belonging to that class by saying "<span class="code">a&nbsp;+&nbsp;b</span>" just as if you
                            were adding numbers. Now, suppose that you write a subroutine that uses the "<span class="code">+</span>"
                            operator to add up the items in a list. The subroutine can be applied to a list
                            of integers, but it can also be applied, automatically, to any other data type
                            for which "<span class="code">+</span>" is defined. Similarly, a subroutine that uses the "<span class="code">&lt;"</span> operator
                            to sort a list can be applied to lists containing any type of data for which
                            "<span class="code">&lt;</span>" is defined. There is no need to write a different sorting subroutine for
                            each type of data.</p>


                        <p>Put these two features together and you have a language where data
                            structures and algorithms will work for any type of data for which they make
                            sense, that is, for which the appropriate operations are defined. This is real
                            generic programming. This might sound pretty good, and you might be asking
                            yourself why all programming languages don't work this way. This type of
                            freedom makes it easier to write programs, but unfortunately it makes it harder
                            to write programs that are correct and robust (see <a href="ch08-00-CorrectnessRobustnessEfficiency.html">Chapter&nbsp;8</a>).
                            Once you have a data structure that can
                            contain data of any type, it becomes hard to ensure that it only holds the type
                            of data that you want it to hold. If you have a subroutine that can sort any
                            type of data, it's hard to ensure that it will only be applied to data for
                            which the "<span class="code">&lt;</span>" operator is defined. More particularly, there is no way for a
                            <b>compiler</b> to ensure these things. The problem will only show up at run time
                            when an attempt is made to apply some operation to a data type for which it is
                            not defined, and the program will crash.</p>


                        <h3 id="Generic Programming in C++"><a class="header" href="#Generic Programming in C++">Generic Programming in C++</a></h3>

                        <p>Unlike Smalltalk, C++ is a very strongly typed language.
                            Every variable has a type, and can only hold data values of that type.
                            This means that the kind of generic programming that is used in Smalltalk is
                            impossible in C++.
                            Nevertheless, C++ has a powerful and flexible system of
                            generic programming. It is made possible by a language feature known as
                            <span class="newword">templates</span>. In C++, instead of writing a different
                            sorting subroutine for each type of data, you can write a single subroutine
                            template. The template is not a subroutine; it's more like a factory for making
                            subroutines. We can look at an example, since the syntax of C++ is very similar
                            to Java's:</p>


                        <pre><code class="java">template&lt;class ItemType&gt;
void sort( ItemType A[], int count ) {
      // Sort items in the array, A, into increasing order.
      // The items in positions 0, 1, 2, ..., (count-1) are sorted.
      // The algorithm that is used here is selection sort.
   for (int i = count-1; i &gt; 0; i--) {
      int position_of_max = 0;
      for (int j = 1; j &lt;= i ; j++)
         if ( A[j] &gt; A[position_of_max] )
            position_of_max = j;
      ItemType temp = A[i];
      A[i] = A[position_of_max];
      A[position_of_max] = temp;
   }
}</code></pre>


                        <p>This piece of code defines a subroutine template. If you remove the first
                            line, "template&lt;class ItemType&gt;", and substitute the word "int" for the
                            word "ItemType" in the rest of the template, you get a subroutine for sorting
                            arrays of <span class="ptype">ints</span>. (Even though it says "class ItemType", you can actually
                            substitute any type for ItemType, including the primitive types.) If you
                            substitute "string" for "ItemType", you get a subroutine for sorting arrays of
                            strings. This is pretty much what the compiler does with the template. If your
                            program says "<span class="code">sort(list,10)</span>" where list is an array of <span class="ptype">ints</span>, the compiler uses
                            the template to generate a subroutine for sorting arrays of <span class="ptype">ints</span>. If you say
                            "<span class="code">sort(cards,10)</span>" where cards is an array of objects of type <span class="classname">Card</span>,
                            then the compiler generates a subroutine for sorting arrays of <span class="classname">Cards</span>.
                            At least, it tries to. The template uses the "<span class="code">&gt;</span>" operator to compare values. If this operator
                            is defined for values of type <span class="classname">Card</span>, then the compiler will successfully use the
                            template to generate a subroutine for sorting cards. If "<span class="code">&gt;</span>" is not defined
                            for <span class="classname">Cards</span>, then the compiler will fail&mdash;but
                            this will happen at compile time,
                            not, as in Smalltalk, at run time where it would make the program crash.
                            (By the way, in C++, it is possible to write definitions of operators like <span class="code">&gt;</span> for
                            any type, so that it is possible that <span class="code">&gt;</span> might work for values of type
                            <span class="classname">Card</span>.)</p>


                        <p>In addition to subroutine templates,
                            C++ also has templates for making classes. If you write a template for a
                            binary tree class, you can use it to generate classes for binary trees of <span class="ptype">ints</span>,
                            binary trees of strings, binary trees of dates, and so on&mdash;all from one
                            template. Modern C++ comes with a large number of
                            pre-written templates called the <span class="newword">Standard Template Library</span>
                            or STL. The STL is quite complex. Many people would say that it's
                            much too complex. But it is also one of the most interesting features of
                            C++.</p>

                        <h3 id="Generic Programming in Java"><a class="header" href="#Generic Programming in Java">Generic Programming in Java</a></h3>

                        <p>Java's generic programming features have gone through several stages of
                            development.  Early versions of Java did not have parameterized types,
                            but they did have classes to represent common data structures.  Those
                            classes were designed to work with <span class="classname">Objects</span>;
                            that is, they could hold objects of any type, and there was no way to
                            restrict the types of objects that could be stored in a given data
                            structure.  For example, <span class="classname">ArrayList</span> was not
                            originally a parameterized type, so that any ArrayList could hold any
                            type of object.  This means that if <span class="code">list</span>
                            was an <span class="classname">ArrayList</span>, then <span class="code">list.get(i)</span>
                            would return a value of type <span class="classname">Object</span>.  If the programmer
                            was actually using the list to store <span class="classname">Strings</span>,
                            the value returned by <span class="code">list.get(i)</span> would have to be type-cast
                            to treat it as a string:</p>


                        <pre><code class="java">String item = (String)list.get(i);</code></pre>


                        <p>This is still a kind of generic programming, since one
                            class can work for any kind of object, but it was closer in spirit to Smalltalk
                            than it was to C++, since there is no way to do type checks at compile time.
                            Unfortunately, as in Smalltalk, the result is a category
                            of errors that show up only at run time, rather than at compile time.  If a
                            programmer assumes that all the items in a data structure are strings and
                            tries to process those items as strings, a run-time error will occur if other
                            types of data have inadvertently been added to the data structure.  In
                            Java, the error will most likely occur when the program retrieves an
                            <span class="classname">Object</span> from the data structure and tries to
                            type-cast it to type <span class="classname">String</span>.  If the
                            object is not actually of type <span class="classname">String</span>, the
                            illegal type-cast will throw an error of type <span class="classname">ClassCastException</span>.</p>


                        <p>Java 5.0 introduced parameterized types, which
                            made it possible to create generic data structures that can be type-checked
                            at compile time rather than at run time.  For example, if <span class="code">list</span>
                            is of type <span class="atype">ArrayList&lt;String&gt;</span>, then the compiler will only
                            allow objects of type <span class="classname">String</span> to be added to <span class="code">list</span>.
                            Furthermore, the return type of <span class="code">list.get(i)</span> is <span class="classname">String</span>,
                            so type-casting is not necessary.  Java's
                            parameterized classes are similar to template classes in C++ (although the implementation
                            is very different), and their introduction moves Java's generic programming model
                            closer to C++ and farther from Smalltalk.  In this chapter, I will use the
                            parameterized types exclusively, but you should remember that their use is not mandatory.
                            It is still legal to use a parameterized class as a non-parameterized type, such as
                            a plain <span class="classname">ArrayList</span>.  In that case, any type of object can be
                            stored in the data structure.  (But if that is what you really want to do, it would
                            be preferable to use the type <span class="atype">ArrayList&lt;Object&gt;</span>.)</p>


                        <p>Note that there is a significant difference between parameterized classes in Java
                            and template classes in C++.  A template class in C++ is not really a class at all&mdash;it's
                            a kind of factory for generating classes.  Every time the template is used with
                            a new type, a new compiled class is created.  With a Java parameterized class,
                            there is only one compiled class file.  For example, there is only one compiled
                            class file, <span class="code">ArrayList.class</span>, for the parameterized class <span class="classname">ArrayList</span>.
                            The parameterized types <span class="classname">ArrayList&lt;String&gt;</span> and
                            <span class="classname">ArrayList&lt;Integer&gt;</span> both use the same compiled class file,
                            as does the plain <span class="classname">ArrayList</span> type.  The type
                            parameter&mdash;<span class="classname">String</span> or <span class="classname">Integer</span>&mdash;just
                            tells the compiler to limit the type of object that can be stored in the data structure.
                            The type parameter has no effect at run time and is not even known at run time.
                            The type information is said to be "erased" at run time.  This <span class="newword">type erasure</span>
                            introduces a certain amount of weirdness.  For example, you can't test "<span class="code">if (list instanceof
ArrayList&lt;String&gt;)</span>" because the <span class="code">instanceof</span> operator is evaluated
                            at run time, and at run time only the plain <span class="classname">ArrayList</span> exists.  Similarly,
                            you can't type-cast to the type <span class="atype">ArrayList&lt;String&gt;</span>.
                            Even worse, you can't create an array that has base type <span class="atype">ArrayList&lt;String&gt;</span>
                            by using the <span class="code">new</span> operator, as in "<span class="code">new&nbsp;ArrayList&lt;String&gt;[N]</span>".
                            This is because the <span class="code">new</span> operator is evaluated at run time, and at run time
                            there is no such thing as "<span class="code">ArrayList&lt;String&gt;</span>"; only the non-parameterized
                            type <span class="classname">ArrayList</span> exists at run time.  (However, although you can't
                            have an array of <span class="atype">ArrayList&lt;String&gt;</span>, you <b>can</b> have
                            an ArrayList of <span class="atype">ArrayList&lt;String&gt;</span>&mdash;with the type
                            written as <span class="atype">ArrayList&lt;ArrayList&lt;String&gt;&gt;</span>&mdash;which is just as good or better.)</p>


                        <p>Fortunately, most programmers don't have to deal with such problems, since they turn
                            up only in fairly advanced programming.  Most people who use parameterized types
                            will not encounter the problems, and they will get the benefits of type-safe generic programming
                            with little difficulty.</p>


                        <p>It's worth noting that if the type parameter in a parameterized type can be
                            deduced by the compiler, then the name of the type parameter can be omitted.  For
                            example, the word "String" is optional in the constructor in the following statement,
                            because the <span class="classname">ArrayList</span> that is created must be an
                            <span class="atype">ArrayList&lt;String&gt;</span> to match the type of the variable:</p>


                        <pre><code class="java">ArrayList&lt;String&gt; words = new ArrayList&lt;&gt;();</code></pre>


                        <h3 id="The Java Collection Framework"><a class="header" href="#The Java Collection Framework">The Java Collection Framework</a></h3>

                        <p>As I've said, Java comes with a number of parameterized types that
                            implement common data structures.  This collection of data structure
                            classes and interfaces is referred to as the <span class="newword">Java Collection Framework</span>,
                            or <span class="newword">JCF</span>.  We will spend the next few sections learning
                            about the JCF.</p>


                        <p>The generic data structures in the Java Collection Framework
                            can be divided into two categories: <span class="newword">collections</span> and <span class="newword">maps</span>.
                            A collection is more or less what it sounds like: a collection of objects. A map
                            associates objects in one set with objects in another set in the way that a
                            dictionary associates definitions with words or a phone book associates phone
                            numbers with names. A map is similar to what I called an "association list" in
                            <a href="ch07-05-SearchingAndSorting.html">Subsection&nbsp;7.5.2</a>.  In Java, collections and maps are represented
                            by the parameterized interfaces <span class="classname">Collection&lt;T&gt;</span>
                            and <span class="classname">Map&lt;T,S&gt;</span>. Here, "T" and "S" stand for any type
                            except for the primitive types.  <span class="classname">Map&lt;T,S&gt;</span> is
                            an example of a parameterized type that has two type parameters, <span class="classname">T</span>
                            and&nbsp;<span class="classname">S</span>;
                            we will not deal further with this possibility until we look at maps more closely
                            in <a href="ch10-03-Maps.html">Section&nbsp;10.3</a>.  In this section and the next, we look
                            at collections only.</p>


                        <p>There are two types of collections: <span class="newword">lists</span> and
                            <span class="newword">sets</span>. A list is a collection in which the objects
                            are arranged in a linear sequence. A list has a first item, a second item, and
                            so on. For any item in the list, except the last, there is an item that
                            directly follows it.  For collections that are "sets," the defining property
                            is that no object can occur more than once in a set; the elements of a set are not necessarily
                            thought of as being in any particular order.  The ideas of lists and sets
                            are represented as parameterized interfaces <span class="classname">List&lt;T&gt;</span>
                            and <span class="classname">Set&lt;T&gt;</span>.  These are sub-interfaces of
                            <span class="classname">Collection&lt;T&gt;</span>.  That is, any object that implements
                            the interface <span class="classname">List&lt;T&gt;</span> or <span class="classname">Set&lt;T&gt;</span>
                            automatically implements <span class="classname">Collection&lt;T&gt;</span> as well.
                            The interface <span class="classname">Collection&lt;T&gt;</span> specifies general
                            operations that can be applied to any collection at all.  <span class="classname">List&lt;T&gt;</span>
                            and <span class="classname">Set&lt;T&gt;</span> add additional operations that
                            are appropriate for lists and sets respectively.</p>


                        <p>Of course, any actual object
                            that is a collection, list, or set must belong to a concrete class that
                            implements the corresponding interface.  For example, the class
                            <span class="classname">ArrayList&lt;T&gt;</span> implements the interface
                            <span class="classname">List&lt;T&gt;</span> and therefore also implements
                            <span class="classname">Collection&lt;T&gt;</span>.  This means
                            that all the methods that are defined in the list and collection
                            interfaces can be used with  an ArrayList.
                            We will look at various classes that implement the list and set interfaces in
                            the <a href="ch10-02-ListsandSets.html">next section</a>. But before we do that, we'll
                            look briefly at some of the general operations that are available for all
                            collections.</p>


                        <p>The interface <span class="classname">Collection&lt;T&gt;</span>
                            specifies methods for performing some basic
                            operations on any collection of objects. Since "collection" is a very general
                            concept, operations that can be applied to all collections are also very
                            general. They are generic operations in the sense that they can be applied to
                            various types of collections containing various types of objects.
                            Suppose that <span class="code">coll</span> is an object that implements the
                            interface <span class="classname">Collection&lt;T&gt;</span> (for some
                            specific non-primitive type <span class="classname">T</span>).
                            Then the following operations, which are specified in the
                            interface <span class="classname">Collection&lt;T&gt;</span>, are
                            defined for <span class="code">coll</span>:</p>


                        <ul>

                            <li>
                                <span class="codedef">coll.size()</span> &mdash; returns an
                                <span class="ptype">int</span> that gives the number of objects in the collection.</li>


                            <li>
                                <span class="codedef">coll.isEmpty()</span> &mdash; returns a <span class="ptype">boolean</span>
                                value which is <span class="code">true</span> if the size of the collection is&nbsp;0.</li>


                            <li>
                                <span class="codedef">coll.clear()</span> &mdash; removes all objects
                                from the collection.</li>


                            <li>
                                <span class="codedef">coll.add(tobject)</span> &mdash; adds
                                <span class="code">tobject</span> to the collection. The parameter must be of type <span class="classname">T</span>;
                                if not, a syntax error occurs at compile time.  (Remember that if <span class="classname">T</span> is
                                a class, this includes objects belonging to a subclass of <span class="classname">T</span>,
                                and if <span class="classname">T</span> is an interface, it includes any object that implements
                                <span class="classname">T</span>.)  The <span class="code">add()</span>
                                method returns a <span class="ptype">boolean</span> value which tells you whether the operation actually
                                modified the collection. For example, adding an object to a <span class="code">Set</span> has no
                                effect if that object was already in the set.</li>


                            <li>
                                <span class="codedef">coll.contains(object)</span> &mdash; returns a
                                <span class="ptype">boolean</span> value that is true if <span class="code">object</span> is in the collection.
                                Note that <span class="code">object</span> is <b>not</b> required to be of type <span class="classname">T</span>,
                                since it makes sense to check whether <span class="code">object</span> is in the collection,
                                no matter what type <span class="code">object</span> has.
                                (For testing equality, <span class="code">null</span> is considered to
                                be equal to itself.  The criterion for testing non-null objects for equality
                                can differ from one kind of collection to another; see
                                <a href="ch10-01-GenericProgramming.html">Subsection&nbsp;10.1.6</a>, below.)</li>


                            <li>
                                <span class="codedef">coll.remove(object)</span> &mdash; removes
                                <span class="code">object</span> from the collection, if it occurs in the collection, and
                                returns a <span class="ptype">boolean</span> value that tells you whether the object was found.
                                Again, <span class="code">object</span> is not required to be of type&nbsp;<span class="classname">T</span>.
                                The test for equality is the same test that is used by <span class="code">contains()</span>.</li>


                            <li>
                                <span class="codedef">coll.containsAll(coll2)</span> &mdash; returns a
                                <span class="ptype">boolean</span> value that is true if every <span class="code">object</span> in <span class="code">coll2</span> is also
                                in <span class="code">coll</span>. The parameter can be any collection.</li>


                            <li>
                                <span class="codedef">coll.addAll(coll2)</span> &mdash; adds all the
                                objects in  <span class="code">coll2</span> to <span class="code">coll</span>.  The parameter,
                                <span class="code">coll2</span>, can be any collection of type <span class="classname">Collection&lt;T&gt;</span>.
                                However, it can also be more general.  For example, if <span class="classname">T</span> is a
                                class and <span class="classname">S</span> is a sub-class of <span class="classname">T</span>,
                                then <span class="code">coll2</span> can be of type <span class="classname">Collection&lt;S&gt;</span>.  This makes sense
                                because any object of type <span class="classname">S</span> is automatically of type
                                <span class="classname">T</span> and so can legally be added to <span class="code">coll</span>.
                            </li>


                            <li>
                                <span class="codedef">coll.removeAll(coll2)</span> &mdash; removes
                                every <span class="code">object</span> from <span class="code">coll</span> that also occurs in the collection
                                <span class="code">coll2</span>.  <span class="code">coll2</span> can be any collection.</li>


                            <li>
                                <span class="codedef">coll.retainAll(coll2)</span> &mdash; removes
                                every <span class="code">object</span> from <span class="code">coll</span> that <b>does not occur</b> in the
                                collection <span class="code">coll2</span>. It "retains" only the objects that do occur in
                                <span class="code">coll2</span>.  <span class="code">coll2</span> can be any collection.</li>


                            <li>
                                <span class="codedef">coll.toArray()</span> &mdash; returns an array of
                                type <span class="atype">Object[]</span> that contains all the items in the collection.
                                Note that the return type is <span class="atype">Object[]</span>, not <span class="atype">T[]</span>!
                                However, there is another version of this method that takes an array of
                                type <span class="atype">T[]</span> as a parameter: the method <span class="code">coll.toArray(tarray)</span>
                                returns an array of type <span class="atype">T[]</span> containing all the items in the collection.
                                If the array parameter <span class="code">tarray</span> is large enough to hold the entire collection,
                                then the items are stored in <span class="code">tarray</span> and <span class="code">tarray</span> is also the
                                return value of the collection. If <span class="code">tarray</span> is not large enough, then a
                                new array is created to hold the items; in that case <span class="code">tarray</span> serves only
                                to specify the type of the array.  For example, <span class="code">coll.toArray(new&nbsp;String[0])</span>
                                can be used if <span class="code">coll</span> is a collection of <span class="classname">Strings</span> and
                                will return a new array of type <span class="atype">String[]</span>.
                            </li>

                        </ul>


                        <p>Since these methods are part of the <span class="classname">Collection&lt;T&gt;</span> interface, they must
                            be defined for every object that implements that interface. There is a problem
                            with this, however. For example, the size of some collections
                            cannot be changed after they are created. Methods that add or remove objects
                            don't make sense for these collections. While it is still legal to call the
                            methods, an exception will be thrown when the call is evaluated at run time.
                            The type of the exception is <span class="classname">UnsupportedOperationException</span>.
                            Furthermore, since <span class="classname">Collection&lt;T&gt;</span> is only an interface,
                            not a concrete class, the actual implementation of the method is left to
                            the classes that implement the interface. This means that the semantics
                            of the methods, as described above, are not guaranteed to be valid for all
                            collection objects; they are valid, however, for classes in the Java
                            Collection Framework.</p>


                        <p>There is also the question of efficiency. Even when an operation is defined
                            for several types of collections, it might not be equally efficient in all
                            cases. Even a method as simple as <span class="code">size()</span> can vary greatly in
                            efficiency. For some collections, computing the <span class="code">size()</span> might involve
                            counting the items in the collection. The number of steps in this process is
                            equal to the number of items. Other collections might have instance variables
                            to keep track of the size, so evaluating <span class="code">size()</span> just means returning
                            the value of a variable. In this case, the computation takes only one step, no
                            matter how many items there are. When working with collections, it's good to
                            have some idea of how efficient operations are and to choose a collection for
                            which the operations that you need can be implemented most efficiently. We'll see
                            specific examples of this in the next two sections.</p>


                        <h3 id="Iterators and for-each Loops"><a class="header" href="#Iterators and for-each Loops">Iterators and for-each Loops</a></h3>


                        <p>The interface <span class="classname">Collection&lt;T&gt;</span> defines a few basic generic algorithms,
                            but suppose you want to write your own generic algorithms. Suppose, for
                            example, you want to do something as simple as printing out every item in a
                            collection. To do this in a generic way, you need some way of going through an
                            arbitrary collection, accessing each item in turn. We have seen how to do this
                            for specific data structures: For an array, you can use a <span class="code">for</span> loop to iterate
                            through all the array indices. For a linked list, you can use a while loop in
                            which you advance a pointer along the list. For a binary tree, you can use a
                            recursive subroutine to do an inorder traversal. Collections can be represented
                            in any of these forms and many others besides. With such a variety of traversal
                            mechanisms, how can we even hope to come up with a single generic method that will
                            work for collections that are stored in wildly different forms? This problem is
                            solved by <span class="newword">iterators</span>. An iterator is an object that
                            can be used to traverse a collection. Different types of collections have
                            iterators that are implemented in different ways, but all iterators are <b>used</b> in the same way. An
                            algorithm that uses an iterator to traverse a collection is generic, because
                            the same technique can be applied to any type of collection. Iterators can seem
                            rather strange to someone who is encountering generic programming for the first
                            time, but you should understand that they solve a difficult problem in an
                            elegant way.</p>


                        <p>The interface <span class="classname">Collection&lt;T&gt;</span> defines a method that can be used to
                            obtain an iterator for any collection. If <span class="code">coll</span> is a collection, then
                            <span class="code">coll.iterator()</span> returns an iterator that can be used to traverse the
                            collection. You should think of the iterator as a kind of generalized pointer
                            that starts at the beginning of the collection and can move along the
                            collection from one item to the next. Iterators are defined by a parameterized interface
                            named <span class="classname">Iterator&lt;T&gt;</span>.  If <span class="code">coll</span> implements the
                            interface <span class="classname">Collection&lt;T&gt;</span> for some specific type <span class="classname">T</span>,
                            then <span class="code">coll.iterator()</span> returns an iterator of type <span class="classname">Iterator&lt;T&gt;</span>,
                            with the same type <span class="classname">T</span> as its type parameter.
                            The interface <span class="classname">Iterator&lt;T&gt;</span> defines just three methods. If
                            <span class="code">iter</span> refers to an object that implements <span class="classname">Iterator&lt;T&gt;</span>, then we have:</p>


                        <ul>

                            <li>
                                <span class="codedef">iter.next()</span> &mdash; returns the next item,
                                and advances the iterator. The return value is of type <span class="classname">T</span>.
                                This method lets you look at one of the items in the collection.  Note
                                that there is no way to look at an item without advancing the iterator past
                                that item. If this method is called when no items remain, it will throw a
                                <span class="classname">NoSuchElementException</span>.</li>


                            <li>
                                <span class="codedef">iter.hasNext()</span> &mdash; returns a <span class="ptype">boolean</span>
                                value telling you whether there are more items to be processed. In general,
                                you should test this before calling <span class="code">iter.next()</span>.</li>


                            <li>
                                <span class="codedef">iter.remove()</span> &mdash; if you call this
                                after calling <span class="code">iter.next()</span>, it will remove the item that you just saw
                                from the collection.   Note that this method has <b>no parameter</b>.  It removes
                                the item that was most recently returned by <span class="code">iter.next()</span>.
                                This might produce an <span class="classname">UnsupportedOperationException</span>,
                                if the collection does not support removal of items.</li>

                        </ul>


                        <p>Using iterators, we can write code for printing all the items in
                            <b>any</b> collection. Suppose, for example, that <span class="code">coll</span> is of type
                            <span class="classname">Collection&lt;String&gt;</span>. In that case, the
                            value returned by <span class="code">coll.iterator()</span> is of type <span class="classname">Iterator&lt;String&gt;</span>,
                            and we can say:</p>


                        <pre><code class="java">Iterator&lt;String&gt; iter;          // Declare the iterator variable.
iter = coll.iterator();         // Get an iterator for the collection.
while ( iter.hasNext() ) {
   String item = iter.next();   // Get the next item.
   System.out.println(item);
}</code></pre>


                        <p>The same general form will work for other types of processing. For example,
                            the following code will remove all <span class="code">null</span> values from any
                            collection of type <span class="classname">Collection&lt;Color&gt;</span>
                            (as long as that collection supports removal of values):</p>


                        <pre><code class="java">Iterator&lt;Color&gt; iter = coll.iterator():
while ( iter.hasNext() ) {
    Color item = iter.next();
    if (item == null)
       iter.remove();
}</code></pre>


                        <p>(Note, by the way, that when <span class="classname">Collection&lt;T&gt;</span>,
                            <span class="classname">Iterator&lt;T&gt;</span>, or any other parameterized type is
                            used in actual code, they are always used with actual types such as
                            <span class="classname">String</span> or <span class="classname">Color</span> in place
                            of the "formal type parameter"&nbsp;<span class="classname">T</span>.
                            An iterator of type <span class="classname">Iterator&lt;String&gt;</span> is used
                            to iterate through a collection of <span class="classname">Strings</span>;
                            an iterator of type <span class="classname">Iterator&lt;Color&gt;</span> is used
                            to iterate through a collection of <span class="classname">Color</span>;
                            and so on.)</p>


                        <p>An iterator is often used to apply the same operation to all the elements
                            in a collection.  In many cases, it's possible to avoid the use of iterators
                            for this purpose by using a for-each loop.  The for-each loop was discussed in <a href="ch07-01-ArrayDetails.html">Subsection&nbsp;7.1.1</a>
                            for use with arrays and in <a href="ch07-03-ArrayLists.html">Subsection&nbsp;7.3.3</a> for use with ArrayLists.
                            But in fact, a for-each loop can be used to iterate through any collection.  For
                            a collection <span class="code">coll</span> of type <span class="classname">Collection&lt;T&gt;</span>,
                            a for-each loop takes the form:</p>


                        <pre><code class="java">for ( T x : coll ) { // "for each object x, of type T, in coll"
   //  process x
}</code></pre>


                        <p>Here, <span class="code">x</span> is the loop control variable.  Each object in
                            <span class="code">coll</span> will be assigned to <span class="code">x</span> in turn, and the
                            body of the loop will be executed for each object.  Since objects in
                            <span class="code">coll</span> are of type <span class="classname">T</span>, <span class="code">x</span>
                            is declared to be of type <span class="classname">T</span>.  For example, if
                            <span class="code">namelist</span> is of type <span class="classname">Collection&lt;String&gt;</span>,
                            we can print out all the names in the collection with:</p>


                        <pre><code class="java">for ( String name : namelist ) {
   System.out.println( name );
}</code></pre>


                        <p>This for-each loop could, of course, be written as a <span class="code">while</span> loop
                            using an iterator, but the for-each loop is much easier to follow.</p>


                        <h3 id="Equality and Comparison"><a class="header" href="#Equality and Comparison">Equality and Comparison</a></h3>

                        <p>There are several methods in the <span class="classname">Collection</span> interface that test objects for equality.
                            For example, the methods <span class="code">coll.contains(object)</span>
                            and <span class="code">coll.remove(object)</span> look for an item in the collection that is
                            equal to <span class="code">object</span>. However, equality is not such a simple matter. The
                            obvious technique for testing equality&mdash;using the <span class="code">==</span> operator&mdash;does
                            not usually give a reasonable answer when applied to objects. The
                            <span class="code">==</span> operator tests whether two objects are identical in the sense that
                            they share the same location in memory. Usually, however, we want to consider
                            two objects to be equal if they represent the same value, which is a very
                            different thing. Two values of type <span class="classname">String</span> should be considered equal
                            if they contain the same sequence of characters. The question of whether those
                            characters are stored in the same location in memory is irrelevant. Two values
                            of type <span class="classname">Date</span> should be considered equal if they represent the same
                            time.</p>


                        <p>We have seen that the <span class="classname">Object</span> class defines the <span class="ptype">boolean</span>-valued method
                            <span class="code">equals(Object)</span> for testing whether one object is equal to another.
                            This method is used by many, but not by all, collection classes for deciding whether
                            two objects are to be considered the same. In the <span class="classname">Object</span> class,
                            <span class="code">obj1.equals(obj2)</span> is defined to be the same as <span class="code">obj1&nbsp;==&nbsp;obj2</span>.
                            However, for many sub-classes of <span class="code">Object</span>, this definition is not
                            reasonable, and it should be overridden. The <span class="classname">String</span> class, for
                            example, overrides <span class="code">equals()</span> so that for a <span class="classname">String</span>
                            <span class="code">str</span>, the value of <span class="code">str.equals(obj)</span> is <span class="code">true</span> when <span class="code">obj</span> is also a
                            <span class="classname">String</span> and <span class="code">obj</span> contains the same sequence of characters as
                            <span class="code">str</span>.</p>


                        <p>If you write your own class, you might want to define an <span class="code">equals()</span>
                            method in that class to get the correct behavior when objects are tested for
                            equality. For example, a <span class="classname">Card</span> class that will work correctly when used
                            in collections could be defined as:</p>


                        <pre><code class="java">public class Card {  // Class to represent playing cards.

   private int suit;  // Number from 0 to 3 that codes for the suit --
                      // spades, diamonds, clubs or hearts.
   private int value; // Number from 1 to 13 that represents the value.

   public boolean equals(Object obj) {
       try {
          Card other = (Card)obj;  // Type-cast obj to a Card.
          if (suit == other.suit &amp;&amp; value == other.value) {
                // The other card has the same suit and value as
                // this card, so they should be considered equal.
             return true;
          }
          else {
             return false;
          }
       }
       catch (Exception e) {
              // This will catch the NullPointerException that occurs if obj
              // is null and the ClassCastException that occurs if obj is
              // not of type Card.  In these cases, obj is not equal to
              // this Card, so return false.
           return false;
       }
    }

    .
    . // other methods and constructors
    .
}</code></pre>


                        <p>Without the <span class="code">equals()</span> method in this class, methods such as
                            <span class="code">contains()</span> and <span class="code">remove()</span> from the interface <span class="classname">Collection&lt;Card&gt;</span>
                            will not work as expected.</p>


                        <p>A similar concern arises when items in a collection are sorted. Sorting
                            refers to arranging a sequence of items in ascending order, according to some
                            criterion. The problem is that there is no natural notion of ascending order
                            for arbitrary objects. Before objects can be sorted, some method must be
                            defined for comparing them. Objects that are meant to be compared should
                            implement the interface <span class="code">java.lang.Comparable</span>.
                            In fact, <span class="classname">Comparable</span> is defined as a parameterized interface,
                            <span class="classname">Comparable&lt;T&gt;</span>,
                            which represents the ability to be compared to an object of type <span class="classname">T</span>.
                            The interface <span class="classname">Comparable&lt;T&gt;</span> defines one method:</p>


                        <pre><code class="java">public int compareTo( T obj )</code></pre>


                        <p>The value returned by <span class="code">obj1.compareTo(obj2)</span> should be
                            negative if and only if <span class="code">obj1</span> comes before <span class="code">obj2</span>,
                            when the objects are arranged in ascending order. It should be positive if
                            and only if <span class="code">obj1</span> comes after <span class="code">obj2</span>.
                            A return value of zero means that the objects are considered to be the same
                            for the purposes of this comparison.  This does not necessarily mean that
                            the objects are equal in the sense that <span class="code">obj1.equals(obj2)</span> is true.
                            But in general, classes that implement <span class="classname">Comparable</span>
                            should try to define <span class="code">.equals()</span>
                            and <span class="code">compareTo()</span> so that <span class="code">obj1.equals(obj2)</span>
                            and <span class="code">obj1.compareTo(obj2)&nbsp;==&nbsp;0</span> always have the same value.
                            (Some classes in the JCF use <span class="code">compareTo()</span> rather
                            than <span class="code">equals()</span> to test objects for equality.)</p>


                        <p>The <span class="classname">String</span> class implements the
                            interface <span class="classname">Comparable&lt;String&gt;</span> and
                            defines <span class="code">compareTo</span> in a reasonable
                            way. In this case, the return value of <span class="code">compareTo</span> is zero
                            if and only if the two strings that are being compared are equal.
                            If you define your own class and want to be able to sort objects belonging
                            to that class, you should do the same. For example:</p>


                        <pre><code class="java">/**
 * Represents a full name consisting of a first name and a last name.
 */
public class FullName implements Comparable&lt;FullName&gt; {

   private String firstName, lastName;  // Non-null first and last names.

   public FullName(String first, String last) {  // Constructor.
      if (first == null || last == null)
         throw new IllegalArgumentException("Names must be non-null.");
      firstName = first;
      lastName = last;
   }

   public boolean equals(Object obj) {
      try {
         FullName other = (FullName)obj;  // Type-cast obj to type FullName
         return firstName.equals(other.firstName)
                                &amp;&amp; lastName.equals(other.lastName);
      }
      catch (Exception e) {
         return false;  // if obj is null or is not of type FullName
      }
   }

   public int compareTo( FullName other ) {
      int compareLast = lastName.compareTo(other.lastName);
      if ( compareLast &lt; 0 ) {
             // If lastName comes before the last name of
             // the other object, then this FullName comes
             // before the other FullName.  Return a negative
             // value to indicate this.
         return -1;
      }
      else if ( compareLast &gt; 0 ) {
             // If lastName comes after the last name of
             // the other object, then this FullName comes
             // after the other FullName.  Return a positive
             // value to indicate this.
         return 1;
      }
      else {
             // Last names are the same, so base the comparison on
             // the first names, using compareTo from class String.
         return firstName.compareTo(other.firstName);
      }
   }

   .
   . // other methods
   .
}</code></pre>


                        <p>I find it a little odd that the class here is declared as "<span class="code">class
FullName implements Comparable&lt;FullName&gt;</span>", with "FullName"
                            repeated as a type parameter in the name of the interface.  However, it does
                            make sense.  It means that we are going to compare objects that belong to
                            the class <span class="classname">FullName</span> to other objects <b>of the same type</b>.
                            Even though this is the only reasonable thing to do, that fact is not
                            obvious to the Java compiler&mdash;and the type parameter in
                            <span class="classname">Comparable&lt;FullName&gt;</span> is there for the
                            compiler.</p>


                        <p>(We have previously encountered <span class="classname">FullName</span> as
                            a record class, in <a href="ch07-04-Records.html">Subsection&nbsp;7.4.1</a>.  Remember that record
                            classes can implement interfaces, so we could define a <span class="classname">FullName</span>
                            record class to implement <span class="classname">Comparable&lt;FullName&gt;</span>.
                            In the record class, the <span class="code">equals()</span> method would already be
                            defined appropriately.)</p>


                        <p>There is another way to allow for comparison of objects in Java, and that is
                            to provide a separate object that is capable of making the comparison. The
                            object must implement the interface <span class="classname">Comparator&lt;T&gt;</span>,
                            where <span class="classname">T</span> is the type of the objects that are to be compared.
                            The interface <span class="classname">Comparator&lt;T&gt;</span> defines the method:</p>


                        <pre><code class="java">public int compare( T obj1, T obj2 )</code></pre>


                        <p>This method compares two objects of type <span class="classname">T</span>
                            and returns a value that is negative, or positive, or
                            zero, depending on whether <span class="code">obj1</span> comes before
                            <span class="code">obj2</span>, or comes after <span class="code">obj2</span>,
                            or is considered to be the same as <span class="code">obj2</span> for the purposes of this comparison.
                            Comparators are useful for comparing objects that do not implement the
                            <span class="classname">Comparable</span> interface and for defining several different orderings on
                            the same collection of objects.  Since <span class="classname">Comparator</span> is
                            a functional interface, comparators are often defined by lambda expressions
                            (see <a href="ch04-05-Lambda.html">Section&nbsp;4.5</a>).</p>


                        <p>Note that it can often make sense to use a <span class="classname">Comparator</span>
                            for which <span class="code">obj1.equals(obj2)</span> does not always have the same
                            value as <span class="code">compare(obj1,obj2)&nbsp;==&nbsp;0</span>.  For example, when sorting
                            addresses by zip code, you would use a <span class="classname">Comparator</span> that looks
                            at the zip code field in the addresses that it compares.</p>


                        <p>In the next two sections, we'll see how <span class="classname">Comparable</span> and
                            <span class="classname">Comparator</span> are used in the context of collections and maps.</p>

                        <h3 id="Generics and Wrapper Classes"><a class="header" href="#Generics and Wrapper Classes">Generics and Wrapper Classes</a></h3>

                        <p>As noted in <a href="ch07-03-ArrayLists.html">Section&nbsp;7.3</a>
                            about <span class="classname">ArrayLists</span>, Java's generic programming does not apply to the primitive
                            types. This is because generic data structures can only hold objects, and values of
                            primitive type are not objects.  However, the "wrapper classes" that were
                            introduced in <a href="ch07-03-ArrayLists.html">Subsection&nbsp;7.3.2</a> make it possible to get around
                            this restriction to a great extent.</p>


                        <p>Recall that each primitive type has an associated wrapper class:
                            class <span class="classname">Integer</span> for type <span class="ptype">int</span>,
                            class <span class="classname">Boolean</span> for type <span class="ptype">boolean</span>,
                            class <span class="classname">Character</span> for type <span class="ptype">char</span>,
                            and so on.</p>


                        <p>An object of type <span class="classname">Integer</span> contains
                            a value of type <span class="ptype">int</span>.  The object serves as a
                            "wrapper" for the primitive type value, which allows it to be
                            used in contexts where objects are required, such as in generic data
                            structures.  For example, a list of <span class="classname">Integers</span>
                            can be stored in a variable of type <span class="classname">ArrayList&lt;Integer&gt;</span>,
                            and interfaces such as <span class="classname">Collection&lt;Integer&gt;</span> and
                            <span class="classname">Set&lt;Integer&gt;</span> are defined.  Furthermore,
                            class <span class="classname">Integer</span> defines <span class="code">equals()</span>,
                            <span class="code">compareTo()</span>, and <span class="code">toString()</span> methods that
                            do what you would expect (that is, that compare and write out the
                            corresponding primitive type values in the usual way).
                            Similar remarks apply for all the wrapper classes.</p>


                        <p>Recall also that Java does automatic conversions between a primitive type and
                            the corresponding wrapper type.  (These conversions, which are called
                            autoboxing and unboxing, were also introduced in <a href="ch07-03-ArrayLists.html">Subsection&nbsp;7.3.3</a>.)
                            This means that once you have created a generic data structure to hold
                            objects belonging to one of the wrapper classes, you can use the data structure
                            pretty much as if it actually contained primitive type values.  For
                            example, if <span class="code">numbers</span> is a variable of type <span class="classname">Collection&lt;Integer&gt;</span>,
                            it is legal to call <span class="code">numbers.add(17)</span> or <span class="code">numbers.remove(42)</span>.
                            You can't literally add the primitive type value 17 to <span class="code">numbers</span>, but
                            Java will automatically convert the 17 to the corresponding wrapper object,
                            <span class="code">Integer.valueOf(17)</span>, and the wrapper object will be added to
                            the collection.  (The creation of the object does add some time and memory
                            overhead to the operation, and you should keep that in mind in situations
                            where efficiency is important.  An array of <span class="ptype">int</span> is more
                            efficient than an <span class="classname">ArrayList&lt;Integer&gt;</span>.)</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch10-00-GenericProgrammingandCollectionClasses.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch10-02-ListsandSets.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch10-00-GenericProgrammingandCollectionClasses.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch10-02-ListsandSets.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </body>
</html>
