<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Binary Trees - Introduction to Programming Using Java</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

<link rel="stylesheet" href="code-class.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html" >Introduction to Programming Using Java</a></li><li class="chapter-item expanded affix "><a href="preface.html">Preface</a></li><li class="chapter-item expanded "><a href="ch01-00-Overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-FetchExecuteCycle.html"><strong aria-hidden="true">1.1.</strong> Fetch and Execute Cycle</a></li><li class="chapter-item expanded "><a href="ch01-02-AsynchronousEvents.html"><strong aria-hidden="true">1.2.</strong> Asynchronous Events</a></li><li class="chapter-item expanded "><a href="ch01-03-JavaVirtualMachine.html"><strong aria-hidden="true">1.3.</strong> The Java Virtual Machine</a></li><li class="chapter-item expanded "><a href="ch01-04-FundamentalBuildingBlocks.html"><strong aria-hidden="true">1.4.</strong> Fundamentals</a></li><li class="chapter-item expanded "><a href="ch01-05-OOP.html"><strong aria-hidden="true">1.5.</strong> Object Oriented Programming</a></li><li class="chapter-item expanded "><a href="ch01-06-ModernUserInterface.html"><strong aria-hidden="true">1.6.</strong> Modern User Interface</a></li><li class="chapter-item expanded "><a href="ch01-07-InternetAndBeyond.html"><strong aria-hidden="true">1.7.</strong> Internet and Beyond</a></li><li class="chapter-item expanded "><a href="ch01-08-Quiz.html"><strong aria-hidden="true">1.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-NameAndThings.html"><strong aria-hidden="true">2.</strong> Name and Things</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-BasicJavaApplication.html"><strong aria-hidden="true">2.1.</strong> Basic Java Application</a></li><li class="chapter-item expanded "><a href="ch02-02-VariablesAndTypes.html"><strong aria-hidden="true">2.2.</strong> Variables and Types</a></li><li class="chapter-item expanded "><a href="ch02-03-ObjectsAndSubroutines.html"><strong aria-hidden="true">2.3.</strong> Objects and Subroutines</a></li><li class="chapter-item expanded "><a href="ch02-04-TextInputAndOutput.html"><strong aria-hidden="true">2.4.</strong> Text Input and Output</a></li><li class="chapter-item expanded "><a href="ch02-05-DetailsOfExpressions.html"><strong aria-hidden="true">2.5.</strong> Details of Expressions</a></li><li class="chapter-item expanded "><a href="ch02-06-ProgrammingEnvironments.html"><strong aria-hidden="true">2.6.</strong> Programming and Environments</a></li><li class="chapter-item expanded "><a href="ch02-07-Exercises.html"><strong aria-hidden="true">2.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch02-08-Quiz.html"><strong aria-hidden="true">2.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-Control.html"><strong aria-hidden="true">3.</strong> Control</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-BlocksLoopsBranches.html"><strong aria-hidden="true">3.1.</strong> Blocks, Loops and Branches</a></li><li class="chapter-item expanded "><a href="ch03-02-AlgorithmDevelopment.html"><strong aria-hidden="true">3.2.</strong> Algorithm Development</a></li><li class="chapter-item expanded "><a href="ch03-03-While.html"><strong aria-hidden="true">3.3.</strong> while and do...while</a></li><li class="chapter-item expanded "><a href="ch03-04-For.html"><strong aria-hidden="true">3.4.</strong> The for statement</a></li><li class="chapter-item expanded "><a href="ch03-05-If.html"><strong aria-hidden="true">3.5.</strong> The If Statement</a></li><li class="chapter-item expanded "><a href="ch03-06-Switch.html"><strong aria-hidden="true">3.6.</strong> The Switch Statement</a></li><li class="chapter-item expanded "><a href="ch03-07-ExceptionsTryCatch.html"><strong aria-hidden="true">3.7.</strong> Exceptions and try...catch</a></li><li class="chapter-item expanded "><a href="ch03-08-Arrays.html"><strong aria-hidden="true">3.8.</strong> Arrays: An Introduction</a></li><li class="chapter-item expanded "><a href="ch03-09-GUI.html"><strong aria-hidden="true">3.9.</strong> GUI: An Introduction</a></li><li class="chapter-item expanded "><a href="ch03-10-Exercises.html"><strong aria-hidden="true">3.10.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch03-11-Quiz.html"><strong aria-hidden="true">3.11.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-Subroutines.html"><strong aria-hidden="true">4.</strong> Subroutines</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-BlackBoxes.html"><strong aria-hidden="true">4.1.</strong> Black Boxes</a></li><li class="chapter-item expanded "><a href="ch04-02-StaticSubroutines.html"><strong aria-hidden="true">4.2.</strong> Static Subroutines and Variables</a></li><li class="chapter-item expanded "><a href="ch04-03-Parameters.html"><strong aria-hidden="true">4.3.</strong> Parameters</a></li><li class="chapter-item expanded "><a href="ch04-04-ReturnValues.html"><strong aria-hidden="true">4.4.</strong> Return Values</a></li><li class="chapter-item expanded "><a href="ch04-05-Lambda.html"><strong aria-hidden="true">4.5.</strong> Lambda Expressions</a></li><li class="chapter-item expanded "><a href="ch04-06-APIPackagesModulesJavadoc.html"><strong aria-hidden="true">4.6.</strong> API, Packages, Modules and Javadoc</a></li><li class="chapter-item expanded "><a href="ch04-07-MoreOnProgramDesign.html"><strong aria-hidden="true">4.7.</strong> More on Program Design</a></li><li class="chapter-item expanded "><a href="ch04-08-TruthAboutDeclarations.html"><strong aria-hidden="true">4.8.</strong> Truth about Declarations</a></li><li class="chapter-item expanded "><a href="ch04-09-Exercises.html"><strong aria-hidden="true">4.9.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch04-10-Quiz.html"><strong aria-hidden="true">4.10.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-ObjectsClasses.html"><strong aria-hidden="true">5.</strong> Objects and Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-ObjectsAndInstanceMethods.html"><strong aria-hidden="true">5.1.</strong> Objects and Instance Methods</a></li><li class="chapter-item expanded "><a href="ch05-02-ConstructorObjectInit.html"><strong aria-hidden="true">5.2.</strong> Constructor and Object Initialization</a></li><li class="chapter-item expanded "><a href="ch05-03-ProgrammingWithObjects.html"><strong aria-hidden="true">5.3.</strong> Programming with Objects</a></li><li class="chapter-item expanded "><a href="ch05-04-AnExample.html"><strong aria-hidden="true">5.4.</strong> An Example</a></li><li class="chapter-item expanded "><a href="ch05-05-InheritanceAndPolymorphism.html"><strong aria-hidden="true">5.5.</strong> Inheritance and Polymorphism</a></li><li class="chapter-item expanded "><a href="ch05-06-thisandsuper.html"><strong aria-hidden="true">5.6.</strong> this and super</a></li><li class="chapter-item expanded "><a href="ch05-07-Interfaces.html"><strong aria-hidden="true">5.7.</strong> Interfaces</a></li><li class="chapter-item expanded "><a href="ch05-08-NestedClasses.html"><strong aria-hidden="true">5.8.</strong> Nested Classes</a></li><li class="chapter-item expanded "><a href="ch05-09-Exercises.html"><strong aria-hidden="true">5.9.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch05-10-Quiz.html"><strong aria-hidden="true">5.10.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-GUIProgramming.html"><strong aria-hidden="true">6.</strong> Introduction to GUI Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-BasicJavaFXApp.html"><strong aria-hidden="true">6.1.</strong> A Basic JavaFX Application</a></li><li class="chapter-item expanded "><a href="ch06-02-BasicClasses.html"><strong aria-hidden="true">6.2.</strong> Basic Classes</a></li><li class="chapter-item expanded "><a href="ch06-03-BasicEvents.html"><strong aria-hidden="true">6.3.</strong> Basic Events</a></li><li class="chapter-item expanded "><a href="ch06-04-BasicControls.html"><strong aria-hidden="true">6.4.</strong> Basic Controls</a></li><li class="chapter-item expanded "><a href="ch06-05-BasicLayout.html"><strong aria-hidden="true">6.5.</strong> Basic Layout</a></li><li class="chapter-item expanded "><a href="ch06-06-CompetePrograms.html"><strong aria-hidden="true">6.6.</strong> Complete Programs</a></li><li class="chapter-item expanded "><a href="ch06-07-Exercises.html"><strong aria-hidden="true">6.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch06-08-Quiz.html"><strong aria-hidden="true">6.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-ArraysArraylistsRecords.html"><strong aria-hidden="true">7.</strong> Arrays, ArrayLists and Records</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-ArrayDetails.html"><strong aria-hidden="true">7.1.</strong> Array Details</a></li><li class="chapter-item expanded "><a href="ch07-02-ArrayProcessing.html"><strong aria-hidden="true">7.2.</strong> Array Processing</a></li><li class="chapter-item expanded "><a href="ch07-03-ArrayLists.html"><strong aria-hidden="true">7.3.</strong> ArrayLists</a></li><li class="chapter-item expanded "><a href="ch07-04-Records.html"><strong aria-hidden="true">7.4.</strong> Records</a></li><li class="chapter-item expanded "><a href="ch07-05-SearchingAndSorting.html"><strong aria-hidden="true">7.5.</strong> Searching and Sorting</a></li><li class="chapter-item expanded "><a href="ch07-06-2DArrays.html"><strong aria-hidden="true">7.6.</strong> 2D Arrays</a></li><li class="chapter-item expanded "><a href="ch07-07-Exercises.html"><strong aria-hidden="true">7.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch07-08-Quiz.html"><strong aria-hidden="true">7.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-CorrectnessRobustnessEfficiency.html"><strong aria-hidden="true">8.</strong> Correctness, Robustness, Efficiency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-IntroductionCorrectnessandRobustness.html"><strong aria-hidden="true">8.1.</strong> Introduction to Correctness and Robustness</a></li><li class="chapter-item expanded "><a href="ch08-02-WritingCorrectPrograms.html"><strong aria-hidden="true">8.2.</strong> Writing Correct Programs</a></li><li class="chapter-item expanded "><a href="ch08-03-ExceptionsAndtrycatch.html"><strong aria-hidden="true">8.3.</strong> Exceptions and try..catch</a></li><li class="chapter-item expanded "><a href="ch08-04-AssertionsAnnotations.html"><strong aria-hidden="true">8.4.</strong> Assertions and Annotations</a></li><li class="chapter-item expanded "><a href="ch08-05-AnalysisofAlgorithms.html"><strong aria-hidden="true">8.5.</strong> Analysis of Algorithms</a></li><li class="chapter-item expanded "><a href="ch08-06-Exercises.html"><strong aria-hidden="true">8.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch08-07-Quiz.html"><strong aria-hidden="true">8.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-LinkedDataStructuresRecursion.html"><strong aria-hidden="true">9.</strong> Linked Data Structures and Recursion</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-Recursion.html"><strong aria-hidden="true">9.1.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="ch09-02-LinkedDataStructures.html"><strong aria-hidden="true">9.2.</strong> Linked Data Structures</a></li><li class="chapter-item expanded "><a href="ch09-03-StacksQueuesADTs.html"><strong aria-hidden="true">9.3.</strong> Stacks, Queues and ADTs</a></li><li class="chapter-item expanded "><a class="active" href="ch09-04-BinaryTrees.html"><strong aria-hidden="true">9.4.</strong> Binary Trees</a></li><li class="chapter-item expanded "><a href="ch09-05-SimpleRecursiveDescentParser.html"><strong aria-hidden="true">9.5.</strong> A Simple Recursive Descent Parser</a></li><li class="chapter-item expanded "><a href="ch09-06-Exercises.html"><strong aria-hidden="true">9.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch09-07-Quiz.html"><strong aria-hidden="true">9.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-GenericProgrammingandCollectionClasses.html"><strong aria-hidden="true">10.</strong> Generic Programmingand Collection Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-GenericProgramming.html"><strong aria-hidden="true">10.1.</strong> Generic Programming</a></li><li class="chapter-item expanded "><a href="ch10-02-ListsandSets.html"><strong aria-hidden="true">10.2.</strong> Lists and Sets</a></li><li class="chapter-item expanded "><a href="ch10-03-Maps.html"><strong aria-hidden="true">10.3.</strong> Maps</a></li><li class="chapter-item expanded "><a href="ch10-04-JCF.html"><strong aria-hidden="true">10.4.</strong> Programming with the JCF</a></li><li class="chapter-item expanded "><a href="ch10-05-WritingGenericClassesandMethods.html"><strong aria-hidden="true">10.5.</strong> Writing Generic Classes and Methods</a></li><li class="chapter-item expanded "><a href="ch10-06-StreamAPI.html"><strong aria-hidden="true">10.6.</strong> Stream APIs</a></li><li class="chapter-item expanded "><a href="ch10-07-Exercises.html"><strong aria-hidden="true">10.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch10-08-Quiz.html"><strong aria-hidden="true">10.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-IOStreamsFilesNetworking.html"><strong aria-hidden="true">11.</strong> I/O Streams, Files, and Networking</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-IOStreamsReadersAndWriters.html"><strong aria-hidden="true">11.1.</strong> I/O Streams, Readers, and Writers</a></li><li class="chapter-item expanded "><a href="ch11-02-Files.html"><strong aria-hidden="true">11.2.</strong> Files</a></li><li class="chapter-item expanded "><a href="ch11-03-ProgrammingWithFiles.html"><strong aria-hidden="true">11.3.</strong> Programming With Files</a></li><li class="chapter-item expanded "><a href="ch11-04-Networking.html"><strong aria-hidden="true">11.4.</strong> Networking</a></li><li class="chapter-item expanded "><a href="ch11-05-XML.html"><strong aria-hidden="true">11.5.</strong> A Brief Introduction to XML</a></li><li class="chapter-item expanded "><a href="ch11-06-Exercises.html"><strong aria-hidden="true">11.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch11-07-Quiz.html"><strong aria-hidden="true">11.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-ThreadsandMultiprocessing.html"><strong aria-hidden="true">12.</strong> Threads and Multiprocessing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-IntroductiontoThreads.html"><strong aria-hidden="true">12.1.</strong> Introduction to Threads</a></li><li class="chapter-item expanded "><a href="ch12-02-ProgrammingwithThreads.html"><strong aria-hidden="true">12.2.</strong> Programming with Threads</a></li><li class="chapter-item expanded "><a href="ch12-03-ThreadsandParallelProcessing.html"><strong aria-hidden="true">12.3.</strong> Threads and Parallel Processing</a></li><li class="chapter-item expanded "><a href="ch12-04-ThreadsandNetworking.html"><strong aria-hidden="true">12.4.</strong> Threads and Networking</a></li><li class="chapter-item expanded "><a href="ch12-05-NetworkProgrammingExample.html"><strong aria-hidden="true">12.5.</strong> Network Programming Example</a></li><li class="chapter-item expanded "><a href="ch12-06-Exercises.html"><strong aria-hidden="true">12.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch12-07-Quiz.html"><strong aria-hidden="true">12.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-GUIProgrammingContinued.html"><strong aria-hidden="true">13.</strong> GUI Programming Continued</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-PropertiesandBindings.html"><strong aria-hidden="true">13.1.</strong> Properties and Bindings</a></li><li class="chapter-item expanded "><a href="ch13-02-FancierGraphics.html"><strong aria-hidden="true">13.2.</strong> Fancier Graphics</a></li><li class="chapter-item expanded "><a href="ch13-03-ComplexComponentsandMVC.html"><strong aria-hidden="true">13.3.</strong> Complex Components and MVC</a></li><li class="chapter-item expanded "><a href="ch13-04-MostlyWindowsandDialogs.html"><strong aria-hidden="true">13.4.</strong> Mostly Windows and Dialogs</a></li><li class="chapter-item expanded "><a href="ch13-05-FinishingTouches.html"><strong aria-hidden="true">13.5.</strong> Finishing Touches</a></li><li class="chapter-item expanded "><a href="ch13-06-Exercises.html"><strong aria-hidden="true">13.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch13-07-Quiz.html"><strong aria-hidden="true">13.7.</strong> Quiz</a></li></ol><li class="chapter-item expanded "><a href="appendix-00.html"> Appendix</a></li><li class="chapter-item expanded "><a href="glossary-00.html"> Glossary</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="Java">Java</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Introduction to Programming Using Java</h1>

                    <div class="right-buttons">

                        <a href="https://github.com/Xayarsh/Java-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Binary Trees"><a class="header" href="#Binary Trees">Binary Trees</a></h2>
                        <p>
                            We have seen in the two previous sections how
                            objects can be linked into lists. When an object contains two pointers to
                            objects of the same type, structures can be created that are much more
                            complicated than linked lists. In this section, we'll look at one of the most
                            basic and useful structures of this type: <span class="newword">binary trees</span>.
                            Each of the objects in a binary tree contains two pointers,
                            typically called <span class="code">left</span> and <span class="code">right</span>. In addition to these
                            pointers, of course, the nodes can contain other types of data. For example, a
                            binary tree of integers would be made up of objects of the following type:</p>


                        <pre><code class="java">class TreeNode {
   int item;        // The data in this node.
   TreeNode left;   // Pointer to the left subtree.
   TreeNode right;  // Pointer to the right subtree.
}</code></pre>


                        <p>The <span class="code">left</span> and
                            <span class="code">right</span> pointers in a <span class="code">TreeNode</span> can be <span class="code">null</span> or can
                            point to other objects of type <span class="code">TreeNode</span>. A node that points to another
                            node is said to be the <span class="newword">parent</span> of that node, and
                            the node it points to is called a <span class="newword">child</span>.  In a binary
                            tree, a child is either a "left child" or a "right child," and a node can
                            have a right child even if it has no left child.  In the
                            picture below, for example, node 3 is the parent of node 6, and nodes 4
                            and 5 are children of node 2. Not every linked structure made up of tree nodes
                            is a binary tree. A binary tree must have the following properties: There is
                            exactly one node in the tree which has no parent; this node is called the
                            <span class="newword">root</span> of the tree. Every other node in the tree has
                            exactly one parent. Finally, there can be no loops in a binary tree. That is,
                            it is not possible to follow a chain of pointers starting at some node and
                            arriving back at the same node.</p>


                        <p align="center">
                            <img src="./images/binary-tree.png" width="258" height="348" alt="TreeNodes linked to make a tree"></p>


                        <p>A node that has no children is called a <span class="newword">leaf</span>. A
                            leaf node can be recognized by the fact that both the left and right pointers
                            in the node are <span class="code">null</span>. In the standard picture of a binary tree, the
                            root node is shown at the top and the leaf nodes at the bottom&mdash;which doesn't
                            show much respect for the analogy to real trees. But at least you can see the
                            branching, tree-like structure that gives a binary tree its name.</p>

                        
                        <h3 id="Tree Traversal"><a class="header" href="#Tree Traversal">Tree Traversal</a></h3>
                       

                        <p>Consider any node in a binary tree. Look at that node together with all its
                            descendants (that is, its children, the children of its children, and so on).
                            This set of nodes forms a binary tree, which is called a
                            <span class="newword">subtree</span> of the original tree. For example, in the picture,
                            nodes 2, 4, and 5 form a subtree. This subtree is called the
                            <span class="newword">left subtree</span> of the root. Similarly, nodes 3 and 6 make up the
                            <span class="newword">right subtree</span> of the root. We can consider any
                            non-empty binary tree to be made up of a root node, a left subtree, and a right
                            subtree. Either or both of the subtrees can be empty. This is a recursive
                            definition, matching the recursive definition of the <span class="classname">TreeNode</span> class.
                            So it should not be a surprise that recursive subroutines are often used to
                            process trees.</p>


                        <p>Consider the problem of counting the nodes in a binary tree.  As an exercise,
                            you might try to come up with a non-recursive algorithm to do the counting,
                            but you shouldn't expect to find one easily.  The
                            heart of the problem is keeping track of which nodes remain to be counted. It's not
                            so easy to do this, and in fact it's not even possible without an auxiliary
                            data structure such as a stack or queue. With recursion, however, the algorithm
                            is almost trivial. Either the tree is empty or it consists of a root and two
                            subtrees. If the tree is empty, the number of nodes is zero. (This is the base
                            case of the recursion.) Otherwise, use recursion to count the nodes in each
                            subtree. Add the results from the subtrees together, and add one to count the
                            root. This gives the total number of nodes in the tree. Written out in
                            Java:</p>


                        <pre><code class="java">/**
 * Count the nodes in the binary tree to which root points, and
 * return the answer.  If root is null, the answer is zero.
 */
static int countNodes( TreeNode root ) {
   if ( root == null ) {  // Base case:  empty tree.
      return 0;  // An empty tree contains no nodes.
   }
   else {  // Recursive case:  root node plus two subtrees.
      int count = 1;   // Start by counting the root.
      count += countNodes(root.left);  // Add the number of nodes
                                       //     in the left subtree.
      count += countNodes(root.right); // Add the number of nodes
                                       //    in the right subtree.
      return count;  // Return the total.
   }
} // end countNodes()</code></pre>


                        <p>Or, consider the problem of printing the items in a binary tree. If the tree
                            is empty, there is nothing to do. If the tree is non-empty, then it consists of
                            a root and two subtrees. Print the item in the root and use recursion to print
                            the items in the subtrees. Here is a subroutine that prints all the items on
                            one line of output:</p>


                        <pre><code class="java">/**
 * Print all the items in the tree to which root points.
 * The item in the root is printed first, followed by the
 * items in the left subtree and then the items in the
 * right subtree.
 */
static void preorderPrint( TreeNode root ) {
   if ( root != null ) {  // (Otherwise, there's nothing to print.)
      System.out.print( root.item + " " );  // Print the root item.
      preorderPrint( root.left );   // Print items in left subtree.
      preorderPrint( root.right );  // Print items in right subtree.
   }
} // end preorderPrint()</code></pre>


                        <p>This routine is called "preorderPrint" because it uses a
                            <span class="newword">preorder traversal</span> of the tree. In a preorder traversal, the
                            root node of the tree is processed first, then the left subtree is traversed,
                            then the right subtree. In a <span class="newword">postorder traversal</span>,
                            the left subtree is traversed, then the right subtree, and then the root node
                            is processed. And in an <span class="newword">inorder traversal</span>, the
                            left subtree is traversed first, then the root node is processed, then the
                            right subtree is traversed. Subroutines that use postorder and inorder
                            traversal to print the contents of a tree differ from <span class="code">preorderPrint()</span> only in the placement of the
                            statement that outputs the root item:</p>


                        <pre><code class="java">/**
 * Print all the items in the tree to which root points.
 * <span class="newcode">The items in the left subtree are printed first, followed</span>
 * <span class="newcode">by the items in the right subtree and then the item</span>
 * <span class="newcode">in the root node.</span>
 */
static void postorderPrint( TreeNode root ) {
   if ( root != null ) {  // (Otherwise, there's nothing to print.)
      postorderPrint( root.left );   // Print items in left subtree.
      postorderPrint( root.right );  // Print items in right subtree.
      <span class="newcode">System.out.print( root.item + " " );  // Print the root item.</span>
   }
} // end postorderPrint()


/**
 * Print all the items in the tree to which root points.
 * <span class="newcode">The items in the left subtree are printed first, followed</span>
 * <span class="newcode">by the item in the root node and then the items</span>
 * <span class="newcode">in the right subtree.</span>
 */
static void inorderPrint( TreeNode root ) {
   if ( root != null ) {  // (Otherwise, there's nothing to print.)
      inorderPrint( root.left );   // Print items in left subtree.
      <span class="newcode">System.out.print( root.item + " " );  // Print the root item.</span>
      inorderPrint( root.right );  // Print items in right subtree.
   }
} // end inorderPrint()</code></pre>


                        <p>Each of these subroutines can be applied to the binary tree shown in the
                            illustration at the beginning of this section. The order in which the items are
                            printed differs in each case:</p>


                        <pre><code class="java">preorderPrint outputs:   1  2  4  5  3  6

postorderPrint outputs:  4  5  2  6  3  1

inorderPrint outputs:    4  2  5  1  3  6</code></pre>


                        <p>In <span class="code">preorderPrint</span>, for example, the item at the root of the tree,
                            <span class="code">1</span>, is output before anything else. But the preorder printing also
                            applies to each of the subtrees of the root. The root item of the left subtree,
                            <span class="code">2</span>, is printed before the other items in that subtree, <span class="code">4</span> and
                            <span class="code">5</span>. As for the right subtree of the root, <span class="code">3</span> is output before
                            <span class="code">6</span>. A preorder traversal applies at all levels in the tree. The other
                            two traversal orders can be analyzed similarly.</p>

                        <h3 id="Binary Sort Trees"><a class="header" href="#Binary Sort Trees">Binary Sort Trees</a></h3>
                    
                        <p>One of the examples in <a href="ch09-02-LinkedDataStructures.html">Section&nbsp;9.2</a> was a linked list of
                            strings, in which the strings were kept in increasing order. While a linked
                            list works well for a small number of strings, it becomes inefficient for a
                            large number of items. When inserting an item into the list, searching for that
                            item's position requires looking at, on average, half the items in the list.
                            Finding an item in the list requires a similar amount of time. If the strings
                            are stored in a sorted array instead of in a linked list, then searching
                            becomes more efficient because binary search can be used.
                            However, inserting a new item into the array
                            is still inefficient since it means moving, on average, half of the items in
                            the array to make a space for the new item. A binary tree can be used to store
                            an ordered list in a way that makes both searching
                            and insertion efficient. A binary tree used in this way is called a
                            <span class="newword">binary sort tree</span> or <span class="newword">BST</span>.</p>


                        <p>A binary sort tree is a binary tree with the following property: For every
                            node in the tree, the item in that node is greater than or equal to every item in the left
                            subtree of that node, and it is less than or equal to all the items in the
                            right subtree of that node. Here for example is a binary sort tree containing
                            items of type <span class="classname">String</span>. (In this picture, I haven't bothered to draw all
                            the pointer variables. Non-null pointers are shown as arrows.)</p>


                        <p align="center">
                            <img src="./images/binary-sort-tree.png" width="392" height="303" alt="A binary sort tree"></p>



                        <p>Binary sort trees have this useful property: An inorder traversal of the
                            tree will process the items in increasing order. In fact, this is really just
                            another way of expressing the definition. For example, if an inorder traversal
                            is used to print the items in the tree shown above, then the items will be in
                            alphabetical order. The definition of an inorder traversal guarantees that all
                            the items in the left subtree of "judy" are printed before "judy", and all the
                            items in the right subtree of "judy" are printed after "judy". But the binary
                            sort tree property guarantees that the items in the left subtree of "judy" are
                            precisely those that precede "judy" in alphabetical order, and all the items in
                            the right subtree follow "judy" in alphabetical order. So, we know that "judy"
                            is output in its proper alphabetical position. But the same argument applies to
                            the subtrees. "Bill" will be output after "alice" and before "fred" and its
                            descendants. "Fred" will be output after "dave" and before "jane" and "joe".
                            And so on.</p>


                        <p>Suppose that we want to search for a given item in a binary search tree.
                            Compare that item to the root item of the tree. If they are equal, we're done.
                            If the item we are looking for is less than the root item, then we need to
                            search the left subtree of the root&mdash;the right subtree can be eliminated
                            because it only contains items that are greater than or equal to the root.
                            Similarly, if the item we are looking for is greater than the item in the root,
                            then we only need to look in the right subtree. In either case, the same
                            procedure can then be applied to search the subtree. Inserting a new item is
                            similar: Start by searching the tree for the position where the new item
                            belongs. When that position is found, create a new node and attach it to the
                            tree at that position.</p>


                        <p>Searching and inserting are efficient operations on a binary search tree,
                            provided that the tree is close to being <span class="newword">balanced</span>.
                            A binary tree is balanced if for each node, the left subtree of that node
                            contains approximately the same number of nodes as the right subtree. In a
                            perfectly balanced tree, the two numbers differ by at most one. Not all binary
                            trees are balanced, but if the tree is created by inserting items in a random
                            order, there is a high
                            probability that the tree is approximately balanced. (If the order of insertion
                            is not random, however, it's quite possible for the tree to be very unbalanced.)
                            During a search of any
                            binary sort tree, every comparison eliminates one of two subtrees from further
                            consideration. If the tree is balanced, that means cutting the number of items
                            still under consideration in half. This is exactly the same as the binary
                            search algorithm, and the result is a similarly efficient algorithm.</p>


                        <p>In terms of asymptotic analysis (<a href="ch08-05-AnalysisofAlgorithms.html">Section&nbsp;8.5</a>), searching, inserting,
                            and deleting in a binary search tree have average case run time Θ(log(n)).
                            The problem size, n, is the number of items in the tree, and the average is
                            taken over all the different orders in which the items could have been inserted into the tree.
                            As long as the actual insertion order is random, the actual run time can be expected
                            to be close to the average.  However, the worst case run time for binary
                            search tree operations is Θ(n), which is much worse than Θ(log(n)).
                            The worst case occurs for  particular insertion orders.  For example,
                            if the items are inserted into the tree in order of increasing size, then every
                            item that is inserted moves always to the right as it moves down the tree.
                            The result is a "tree" that looks more like a linked list, since it consists
                            of a linear string of nodes strung together by their <span class="code">right</span> child
                            pointers.  Operations on such a tree have the same performance as operations
                            on a linked list.  Now, there are data structures that are similar to simple binary
                            sort trees, except that insertion and deletion of nodes are implemented in
                            a way that will always keep the tree balanced, or almost balanced.  For
                            these data structures, searching, inserting, and deleting have both average case
                            and worst case run times that are Θ(log(n)).  Here, however, we will
                            look at only the simple versions of inserting and searching.</p>


                        <p>The sample program <span class="sourceref"><a href="./source/chapter9/SortTreeDemo.java">SortTreeDemo.java</a></span> is a demonstration of
                            binary sort trees. The program includes subroutines that implement inorder
                            traversal, searching, and insertion. We'll look at the latter two subroutines
                            below. The <span class="code">main()</span> routine tests the subroutines by letting you type in
                            strings to be inserted into the tree.</p>


                        <p>In <span class="classname">SortTreeDemo</span>, nodes in the binary tree are represented using the
                            following static nested class, which includes a simple constructor to make creating nodes
                            easier:</p>


                        <pre><code class="java">
/**
 * An object of type TreeNode represents one node in a binary tree of strings.
 */
private static class TreeNode {
   String item;      // The data in this node.
   TreeNode left;    // Pointer to left subtree.
   TreeNode right;   // Pointer to right subtree.
   TreeNode(String str) {
          // Constructor.  Make a node containing str.
          // Note that left and right pointers are null.
      item = str;
   }
}  // end class TreeNode</code></pre>


                        <p>A static member variable of type <span class="classname">TreeNode</span> points to the binary sort
                            tree that is used by the program:</p>


                        <pre><code class="java">private static TreeNode root;  // Pointer to the root node in the tree.
                               // When the tree is empty, root is null.</code></pre>


                        <p>A recursive subroutine named <span class="code">treeContains</span> is used to search for a
                            given item in the tree. This routine implements the search algorithm for binary
                            trees that was outlined above:</p>


                        <pre><code class="java">/**
 * Return true if item is one of the items in the binary
 * sort tree to which root points.  Return false if not.
 */
static boolean treeContains( TreeNode root, String item ) {
   if ( root == null ) {
          // Tree is empty, so it certainly doesn't contain item.
      return false;
   }
   else if ( item.equals(root.item) ) {
          // Yes, the item has been found in the root node.
      return true;
   }
   else if ( item.compareTo(root.item) &lt; 0 ) {
          // If the item occurs, it must be in the left subtree.
      return treeContains( root.left, item );
   }
   else {
          // If the item occurs, it must be in the right subtree.
      return treeContains( root.right, item );
   }
}  // end treeContains()</code></pre>


                        <p>When this routine is called in the <span class="code">main()</span> routine, the first
                            parameter is the static member variable <span class="code">root</span>, which points to the root
                            of the entire binary sort tree.</p>


                        <p>It's worth noting that recursion is not really essential in this case. A
                            simple, non-recursive algorithm for searching a binary sort tree follows
                            the rule: Start at the root and move down the tree until you find the item or reach a null pointer.
                            Since the search follows a single path down the tree, it can be implemented as
                            a <span class="code">while</span> loop. Here is a non-recursive version of the search routine:</p>


                        <pre><code class="java">private static boolean treeContainsNR( TreeNode root, String item ) {
   TreeNode runner;  // For "running" down the tree.
   runner = root;    // Start at the root node.
   while (true) {
      if (runner == null) {
            // We've fallen off the tree without finding item.
         return false;
      }
      else if ( item.equals(runner.item) ) {
            // We've found the item.
         return true;
      }
      else if ( item.compareTo(runner.item) &lt; 0 ) {
            // If the item occurs, it must be in the left subtree.
            // So, advance the runner down one level to the left.
         runner = runner.left;
      }
      else {
            // If the item occurs, it must be in the right subtree.
            // So, advance the runner down one level to the right.
         runner = runner.right;
      }
   }  // end while
} // end treeContainsNR();</code></pre>


                        <p>The subroutine for inserting a new item into the tree turns out to be more
                            similar to the non-recursive search routine than to the recursive. The
                            insertion routine has to handle the case where the tree is empty. In that case,
                            the value of <span class="code">root</span> must be changed to point to a node that contains the
                            new item:</p>


                        <pre><code class="java">root = new TreeNode( newItem ); </code></pre>


                        <p>But this means, effectively, that the root can't be passed as a parameter to
                            the subroutine, because it is impossible for a subroutine to change the value
                            stored in an actual parameter. (I should note that this is something that
                            <b>is</b> possible in other languages.) Recursion uses parameters in an
                            essential way. There are ugly ways to work around the problem, but the easiest thing
                            is just to use a non-recursive insertion routine that accesses the static
                            member variable <span class="code">root</span> directly. One difference between inserting an
                            item and searching for an item is that we have to be careful not to fall off
                            the tree. That is, we have to stop searching just <b>before</b> <span class="code">runner</span>
                            becomes <span class="code">null</span>. When we get to an empty spot in the tree, that's where
                            we have to insert the new node:</p>


                        <pre><code class="java">/**
 * Add the item to the binary sort tree to which the global variable
 * "root" refers.  (Note that root can't be passed as  a parameter to
 * this routine because the value of root might change, and a change
 * in the value of a formal parameter does not change the actual parameter.)
 */
private static void treeInsert(String newItem) {
   if ( root == null ) {
          // The tree is empty.  Set root to point to a new node containing
          // the new item.  This becomes the only node in the tree.
      root = new TreeNode( newItem );
      return;
   }
   TreeNode runner;  // Runs down the tree to find a place for newItem.
   runner = root;   // Start at the root.
   while (true) {
      if ( newItem.compareTo(runner.item) &lt; 0 ) {
             // Since the new item is less than the item in runner,
             // it belongs in the left subtree of runner.  If there
             // is an open space at runner.left, add a new node there.
             // Otherwise, advance runner down one level to the left.
         if ( runner.left == null ) {
            runner.left = new TreeNode( newItem );
            return;  // New item has been added to the tree.
         }
         else
            runner = runner.left;
      }
      else {
             // Since the new item is greater than or equal to the item in
             // runner, it belongs in the right subtree of runner.  If there
             // is an open space at runner.right, add a new node there.
             // Otherwise, advance runner down one level to the right.
         if ( runner.right == null ) {
            runner.right = new TreeNode( newItem );
            return;  // New item has been added to the tree.
         }
         else
            runner = runner.right;
      }
   } // end while
}  // end treeInsert()</code></pre>

                        
                        <h3 id="Expression Trees"><a class="header" href="#Expression Trees">Expression Trees</a></h3>

                        <p>Another application of trees is to store mathematical expressions such as
                            <span class="code">15*(x+y)</span> or <span class="code">sqrt(42)+7</span> in a convenient form. Let's stick for
                            the moment to expressions made up of numbers and the operators <span class="code">+</span>, <span class="code">-</span>,
                            <span class="code">*</span>, and <span class="code">/</span>. Consider the expression
                            <span class="code">3*((7+1)/4)+(17-5)</span>. This expression is made up of two subexpressions,
                            <span class="code">3*((7+1)/4)</span> and <span class="code">(17-5)</span>, combined with the operator "<span class="code">+</span>". When
                            the expression is represented as a binary tree, the root node holds the
                            operator <span class="code">+</span>, while the subtrees of the root node represent the subexpressions
                            <span class="code">3*((7+1)/4)</span> and <span class="code">(17-5)</span>. Every node in the tree holds either a
                            number or an operator. A node that holds a number is a leaf node of the tree. A
                            node that holds an operator has two subtrees representing the operands to which
                            the operator applies. The tree is shown in the illustration below. I will refer
                            to a tree of this type as an <span class="newword">expression tree</span>.</p>


                        <p>Given an expression tree, it's easy to find the value of the expression that
                            it represents. Each node in the tree has an associated value. If the node is a
                            leaf node, then its value is simply the number that the node contains. If the
                            node contains an operator, then the associated value is computed by first
                            finding the values of its child nodes and then applying the operator to those
                            values. The process is shown by the upward-directed arrows in the illustration. The value
                            computed for the root node is the value of the expression as a whole. There are
                            other uses for expression trees. For example, a postorder traversal of the tree
                            will output the postfix form of the expression.</p>


                        <p align="center">
                            <img src="./images/expression-tree.png" width="430" height="429" alt="An expression tree"></p>



                        <p>An expression tree contains two types of nodes: nodes that contain numbers
                            and nodes that contain operators. Furthermore, we might want to add other types
                            of nodes to make the trees more useful, such as nodes that contain variables.
                            If we want to work with expression trees in Java, how can we deal with this
                            variety of nodes? One way&mdash;which will be frowned upon by object-oriented
                            purists&mdash;is to include an instance variable in each node object to record
                            which type of node it is:</p>


                        <pre><code class="java">enum NodeType { NUMBER, OPERATOR }   // Possible kinds of node.

class ExpNode {  // A node in an expression tree.

    NodeType kind;  // Which type of node is this?
    double number;  // The value in a node of type NUMBER.
    char op;        // The operator in a node of type OPERATOR.
    ExpNode left;   // Pointers to subtrees,
    ExpNode right;  //     in a node of type OPERATOR.

    ExpNode( double val ) {
          // Constructor for making a node of type NUMBER.
       kind = NodeType.NUMBER;
       number = val;
    }

    ExpNode( char op, ExpNode left, ExpNode right ) {
          // Constructor for making a node of type OPERATOR.
       kind = NodeType.OPERATOR;
       this.op = op;
       this.left = left;
       this.right = right;
    }

 } // end class ExpNode</code></pre>


                        <p>Given this definition, the following recursive subroutine will find the
                            value of an expression tree:</p>


                        <pre><code class="java">static double getValue( ExpNode node ) {
       // Return the value of the expression represented by
       // the tree to which node refers.  Node must be non-null.
    if ( node.kind == NodeType.NUMBER ) {
          // The value of a NUMBER node is the number it holds.
       return node.number;
    }
    else {  // The kind must be OPERATOR.
            // Get the values of the operands and combine them
            //    using the operator.
       double leftVal = getValue( node.left );
       double rightVal = getValue( node.right );
       switch ( node.op ) {
          case '+':  return leftVal + rightVal;
          case '-':  return leftVal - rightVal;
          case '*':  return leftVal * rightVal;
          case '/':  return leftVal / rightVal;
          default:   return Double.NaN;  // Bad operator.
       }
    }
 } // end getValue()</code></pre>


                        <p>Although this approach works, a more object-oriented approach is to note
                            that since there are two types of nodes, there should be two classes to
                            represent them, perhaps named <span class="classname">ConstNode</span> and <span class="classname">BinOpNode</span>. To represent the
                            general idea of a node in an expression tree, we need another class,
                            <span class="classname">ExpNode</span>. Both <span class="classname">ConstNode</span> and <span class="classname">BinOpNode</span> will be
                            subclasses of <span class="classname">ExpNode</span>. Since any actual node will be either a
                            <span class="code">ConstNode</span> or a <span class="classname">BinOpNode</span>, <span class="classname">ExpNode</span> should be an
                            abstract class. (See <a href="ch05-05-InheritanceAndPolymorphism.html">Subsection&nbsp;5.5.5</a>.) Since one of the
                            things we want to do with nodes is find their values, each class should have an
                            instance method for finding the value:</p>


                        <pre><code class="java">abstract class ExpNode {
       // Represents a node of any type in an expression tree.

    abstract double value();  // Return the value of this node.

} // end class ExpNode


class ConstNode extends ExpNode {
       // Represents a node that holds a number.

    double number;  // The number in the node.

    ConstNode( double val ) {
          // Constructor.  Create a node to hold val.
       number = val;
    }

    double value() {
          // The value is just the number that the node holds.
       return number;
    }

 } // end class ConstNode


 class BinOpNode extends ExpNode {
       // Represents a node that holds an operator.

    char op;        // The operator.
    ExpNode left;   // The left operand.
    ExpNode right;  // The right operand.

    BinOpNode( char op, ExpNode left, ExpNode right ) {
          // Constructor.  Create a node to hold the given data.
       this.op = op;
       this.left = left;
       this.right = right;
    }

    double value() {
          // To get the value, compute the value of the left and
          // right operands, and combine them with the operator.
        double leftVal = left.value();
        double rightVal = right.value();
        switch ( op ) {
            case '+':  return leftVal + rightVal;
            case '-':  return leftVal - rightVal;
            case '*':  return leftVal * rightVal;
            case '/':  return leftVal / rightVal;
            default:   return Double.NaN;  // Bad operator.
         }
    }

 } // end class BinOpNode</code></pre>


                        <p>Note that the left and right operands of a <span class="classname">BinOpNode</span> are of type
                            <span class="classname">ExpNode</span>, not <span class="classname">BinOpNode</span>. This allows the operand to be either
                            a <span class="classname">ConstNode</span> or another <span class="classname">BinOpNode</span>&mdash;or any other type of
                            <span class="classname">ExpNode</span> that we might eventually create. Since every <span class="classname">ExpNode</span>
                            has a <span class="code">value()</span> method, we can call <span class="code">left.value()</span> to compute the
                            value of the left operand. If <span class="code">left</span> is in fact a <span class="classname">ConstNode</span>,
                            this will call the <span class="code">value()</span> method in the <span class="classname">ConstNode</span> class. If
                            it is in fact a <span class="classname">BinOpNode</span>, then <span class="code">left.value()</span> will call the
                            <span class="code">value()</span> method in the <span class="classname">BinOpNode</span> class. Each node knows how to
                            compute its own value.</p>


                        <p>Although it might seem more complicated at first, the object-oriented
                            approach has some real advantages. For one thing, it doesn't waste memory. In the
                            original <span class="classname">ExpNode</span> class, only some of the instance variables in each
                            node were actually used, and we needed an extra instance variable to keep track
                            of the type of node. More important, though, is the fact that new types of
                            nodes can be added more cleanly, since it can be done by creating a new
                            subclass of <span class="classname">ExpNode</span> rather than by modifying an existing class.</p>


                        <p>We'll return to the topic of expression trees in the next section, where
                            we'll see how to create an expression tree to represent a given expression.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch09-03-StacksQueuesADTs.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch09-05-SimpleRecursiveDescentParser.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch09-03-StacksQueuesADTs.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch09-05-SimpleRecursiveDescentParser.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </body>
</html>
