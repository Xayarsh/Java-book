<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Linked Data Structures - Introduction to Programming Using Java</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

<link rel="stylesheet" href="code-class.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html" >Introduction to Programming Using Java</a></li><li class="chapter-item expanded affix "><a href="preface.html">Preface</a></li><li class="chapter-item expanded "><a href="ch01-00-Overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-FetchExecuteCycle.html"><strong aria-hidden="true">1.1.</strong> Fetch and Execute Cycle</a></li><li class="chapter-item expanded "><a href="ch01-02-AsynchronousEvents.html"><strong aria-hidden="true">1.2.</strong> Asynchronous Events</a></li><li class="chapter-item expanded "><a href="ch01-03-JavaVirtualMachine.html"><strong aria-hidden="true">1.3.</strong> The Java Virtual Machine</a></li><li class="chapter-item expanded "><a href="ch01-04-FundamentalBuildingBlocks.html"><strong aria-hidden="true">1.4.</strong> Fundamentals</a></li><li class="chapter-item expanded "><a href="ch01-05-OOP.html"><strong aria-hidden="true">1.5.</strong> Object Oriented Programming</a></li><li class="chapter-item expanded "><a href="ch01-06-ModernUserInterface.html"><strong aria-hidden="true">1.6.</strong> Modern User Interface</a></li><li class="chapter-item expanded "><a href="ch01-07-InternetAndBeyond.html"><strong aria-hidden="true">1.7.</strong> Internet and Beyond</a></li><li class="chapter-item expanded "><a href="ch01-08-Quiz.html"><strong aria-hidden="true">1.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-NameAndThings.html"><strong aria-hidden="true">2.</strong> Name and Things</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-BasicJavaApplication.html"><strong aria-hidden="true">2.1.</strong> Basic Java Application</a></li><li class="chapter-item expanded "><a href="ch02-02-VariablesAndTypes.html"><strong aria-hidden="true">2.2.</strong> Variables and Types</a></li><li class="chapter-item expanded "><a href="ch02-03-ObjectsAndSubroutines.html"><strong aria-hidden="true">2.3.</strong> Objects and Subroutines</a></li><li class="chapter-item expanded "><a href="ch02-04-TextInputAndOutput.html"><strong aria-hidden="true">2.4.</strong> Text Input and Output</a></li><li class="chapter-item expanded "><a href="ch02-05-DetailsOfExpressions.html"><strong aria-hidden="true">2.5.</strong> Details of Expressions</a></li><li class="chapter-item expanded "><a href="ch02-06-ProgrammingEnvironments.html"><strong aria-hidden="true">2.6.</strong> Programming and Environments</a></li><li class="chapter-item expanded "><a href="ch02-07-Exercises.html"><strong aria-hidden="true">2.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch02-08-Quiz.html"><strong aria-hidden="true">2.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-Control.html"><strong aria-hidden="true">3.</strong> Control</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-BlocksLoopsBranches.html"><strong aria-hidden="true">3.1.</strong> Blocks, Loops and Branches</a></li><li class="chapter-item expanded "><a href="ch03-02-AlgorithmDevelopment.html"><strong aria-hidden="true">3.2.</strong> Algorithm Development</a></li><li class="chapter-item expanded "><a href="ch03-03-While.html"><strong aria-hidden="true">3.3.</strong> while and do...while</a></li><li class="chapter-item expanded "><a href="ch03-04-For.html"><strong aria-hidden="true">3.4.</strong> The for statement</a></li><li class="chapter-item expanded "><a href="ch03-05-If.html"><strong aria-hidden="true">3.5.</strong> The If Statement</a></li><li class="chapter-item expanded "><a href="ch03-06-Switch.html"><strong aria-hidden="true">3.6.</strong> The Switch Statement</a></li><li class="chapter-item expanded "><a href="ch03-07-ExceptionsTryCatch.html"><strong aria-hidden="true">3.7.</strong> Exceptions and try...catch</a></li><li class="chapter-item expanded "><a href="ch03-08-Arrays.html"><strong aria-hidden="true">3.8.</strong> Arrays: An Introduction</a></li><li class="chapter-item expanded "><a href="ch03-09-GUI.html"><strong aria-hidden="true">3.9.</strong> GUI: An Introduction</a></li><li class="chapter-item expanded "><a href="ch03-10-Exercises.html"><strong aria-hidden="true">3.10.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch03-11-Quiz.html"><strong aria-hidden="true">3.11.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-Subroutines.html"><strong aria-hidden="true">4.</strong> Subroutines</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-BlackBoxes.html"><strong aria-hidden="true">4.1.</strong> Black Boxes</a></li><li class="chapter-item expanded "><a href="ch04-02-StaticSubroutines.html"><strong aria-hidden="true">4.2.</strong> Static Subroutines and Variables</a></li><li class="chapter-item expanded "><a href="ch04-03-Parameters.html"><strong aria-hidden="true">4.3.</strong> Parameters</a></li><li class="chapter-item expanded "><a href="ch04-04-ReturnValues.html"><strong aria-hidden="true">4.4.</strong> Return Values</a></li><li class="chapter-item expanded "><a href="ch04-05-Lambda.html"><strong aria-hidden="true">4.5.</strong> Lambda Expressions</a></li><li class="chapter-item expanded "><a href="ch04-06-APIPackagesModulesJavadoc.html"><strong aria-hidden="true">4.6.</strong> API, Packages, Modules and Javadoc</a></li><li class="chapter-item expanded "><a href="ch04-07-MoreOnProgramDesign.html"><strong aria-hidden="true">4.7.</strong> More on Program Design</a></li><li class="chapter-item expanded "><a href="ch04-08-TruthAboutDeclarations.html"><strong aria-hidden="true">4.8.</strong> Truth about Declarations</a></li><li class="chapter-item expanded "><a href="ch04-09-Exercises.html"><strong aria-hidden="true">4.9.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch04-10-Quiz.html"><strong aria-hidden="true">4.10.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-ObjectsClasses.html"><strong aria-hidden="true">5.</strong> Objects and Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-ObjectsAndInstanceMethods.html"><strong aria-hidden="true">5.1.</strong> Objects and Instance Methods</a></li><li class="chapter-item expanded "><a href="ch05-02-ConstructorObjectInit.html"><strong aria-hidden="true">5.2.</strong> Constructor and Object Initialization</a></li><li class="chapter-item expanded "><a href="ch05-03-ProgrammingWithObjects.html"><strong aria-hidden="true">5.3.</strong> Programming with Objects</a></li><li class="chapter-item expanded "><a href="ch05-04-AnExample.html"><strong aria-hidden="true">5.4.</strong> An Example</a></li><li class="chapter-item expanded "><a href="ch05-05-InheritanceAndPolymorphism.html"><strong aria-hidden="true">5.5.</strong> Inheritance and Polymorphism</a></li><li class="chapter-item expanded "><a href="ch05-06-thisandsuper.html"><strong aria-hidden="true">5.6.</strong> this and super</a></li><li class="chapter-item expanded "><a href="ch05-07-Interfaces.html"><strong aria-hidden="true">5.7.</strong> Interfaces</a></li><li class="chapter-item expanded "><a href="ch05-08-NestedClasses.html"><strong aria-hidden="true">5.8.</strong> Nested Classes</a></li><li class="chapter-item expanded "><a href="ch05-09-Exercises.html"><strong aria-hidden="true">5.9.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch05-10-Quiz.html"><strong aria-hidden="true">5.10.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-GUIProgramming.html"><strong aria-hidden="true">6.</strong> Introduction to GUI Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-BasicJavaFXApp.html"><strong aria-hidden="true">6.1.</strong> A Basic JavaFX Application</a></li><li class="chapter-item expanded "><a href="ch06-02-BasicClasses.html"><strong aria-hidden="true">6.2.</strong> Basic Classes</a></li><li class="chapter-item expanded "><a href="ch06-03-BasicEvents.html"><strong aria-hidden="true">6.3.</strong> Basic Events</a></li><li class="chapter-item expanded "><a href="ch06-04-BasicControls.html"><strong aria-hidden="true">6.4.</strong> Basic Controls</a></li><li class="chapter-item expanded "><a href="ch06-05-BasicLayout.html"><strong aria-hidden="true">6.5.</strong> Basic Layout</a></li><li class="chapter-item expanded "><a href="ch06-06-CompetePrograms.html"><strong aria-hidden="true">6.6.</strong> Complete Programs</a></li><li class="chapter-item expanded "><a href="ch06-07-Exercises.html"><strong aria-hidden="true">6.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch06-08-Quiz.html"><strong aria-hidden="true">6.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-ArraysArraylistsRecords.html"><strong aria-hidden="true">7.</strong> Arrays, ArrayLists and Records</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-ArrayDetails.html"><strong aria-hidden="true">7.1.</strong> Array Details</a></li><li class="chapter-item expanded "><a href="ch07-02-ArrayProcessing.html"><strong aria-hidden="true">7.2.</strong> Array Processing</a></li><li class="chapter-item expanded "><a href="ch07-03-ArrayLists.html"><strong aria-hidden="true">7.3.</strong> ArrayLists</a></li><li class="chapter-item expanded "><a href="ch07-04-Records.html"><strong aria-hidden="true">7.4.</strong> Records</a></li><li class="chapter-item expanded "><a href="ch07-05-SearchingAndSorting.html"><strong aria-hidden="true">7.5.</strong> Searching and Sorting</a></li><li class="chapter-item expanded "><a href="ch07-06-2DArrays.html"><strong aria-hidden="true">7.6.</strong> 2D Arrays</a></li><li class="chapter-item expanded "><a href="ch07-07-Exercises.html"><strong aria-hidden="true">7.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch07-08-Quiz.html"><strong aria-hidden="true">7.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-CorrectnessRobustnessEfficiency.html"><strong aria-hidden="true">8.</strong> Correctness, Robustness, Efficiency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-IntroductionCorrectnessandRobustness.html"><strong aria-hidden="true">8.1.</strong> Introduction to Correctness and Robustness</a></li><li class="chapter-item expanded "><a href="ch08-02-WritingCorrectPrograms.html"><strong aria-hidden="true">8.2.</strong> Writing Correct Programs</a></li><li class="chapter-item expanded "><a href="ch08-03-ExceptionsAndtrycatch.html"><strong aria-hidden="true">8.3.</strong> Exceptions and try..catch</a></li><li class="chapter-item expanded "><a href="ch08-04-AssertionsAnnotations.html"><strong aria-hidden="true">8.4.</strong> Assertions and Annotations</a></li><li class="chapter-item expanded "><a href="ch08-05-AnalysisofAlgorithms.html"><strong aria-hidden="true">8.5.</strong> Analysis of Algorithms</a></li><li class="chapter-item expanded "><a href="ch08-06-Exercises.html"><strong aria-hidden="true">8.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch08-07-Quiz.html"><strong aria-hidden="true">8.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-LinkedDataStructuresRecursion.html"><strong aria-hidden="true">9.</strong> Linked Data Structures and Recursion</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-Recursion.html"><strong aria-hidden="true">9.1.</strong> Recursion</a></li><li class="chapter-item expanded "><a class="active" href="ch09-02-LinkedDataStructures.html"><strong aria-hidden="true">9.2.</strong> Linked Data Structures</a></li><li class="chapter-item expanded "><a href="ch09-03-StacksQueuesADTs.html"><strong aria-hidden="true">9.3.</strong> Stacks, Queues and ADTs</a></li><li class="chapter-item expanded "><a href="ch09-04-BinaryTrees.html"><strong aria-hidden="true">9.4.</strong> Binary Trees</a></li><li class="chapter-item expanded "><a href="ch09-05-SimpleRecursiveDescentParser.html"><strong aria-hidden="true">9.5.</strong> A Simple Recursive Descent Parser</a></li><li class="chapter-item expanded "><a href="ch09-06-Exercises.html"><strong aria-hidden="true">9.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch09-07-Quiz.html"><strong aria-hidden="true">9.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-GenericProgrammingandCollectionClasses.html"><strong aria-hidden="true">10.</strong> Generic Programmingand Collection Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-GenericProgramming.html"><strong aria-hidden="true">10.1.</strong> Generic Programming</a></li><li class="chapter-item expanded "><a href="ch10-02-ListsandSets.html"><strong aria-hidden="true">10.2.</strong> Lists and Sets</a></li><li class="chapter-item expanded "><a href="ch10-03-Maps.html"><strong aria-hidden="true">10.3.</strong> Maps</a></li><li class="chapter-item expanded "><a href="ch10-04-JCF.html"><strong aria-hidden="true">10.4.</strong> Programming with the JCF</a></li><li class="chapter-item expanded "><a href="ch10-05-WritingGenericClassesandMethods.html"><strong aria-hidden="true">10.5.</strong> Writing Generic Classes and Methods</a></li><li class="chapter-item expanded "><a href="ch10-06-StreamAPI.html"><strong aria-hidden="true">10.6.</strong> Stream APIs</a></li><li class="chapter-item expanded "><a href="ch10-07-Exercises.html"><strong aria-hidden="true">10.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch10-08-Quiz.html"><strong aria-hidden="true">10.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-IOStreamsFilesNetworking.html"><strong aria-hidden="true">11.</strong> I/O Streams, Files, and Networking</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-IOStreamsReadersAndWriters.html"><strong aria-hidden="true">11.1.</strong> I/O Streams, Readers, and Writers</a></li><li class="chapter-item expanded "><a href="ch11-02-Files.html"><strong aria-hidden="true">11.2.</strong> Files</a></li><li class="chapter-item expanded "><a href="ch11-03-ProgrammingWithFiles.html"><strong aria-hidden="true">11.3.</strong> Programming With Files</a></li><li class="chapter-item expanded "><a href="ch11-04-Networking.html"><strong aria-hidden="true">11.4.</strong> Networking</a></li><li class="chapter-item expanded "><a href="ch11-05-XML.html"><strong aria-hidden="true">11.5.</strong> A Brief Introduction to XML</a></li><li class="chapter-item expanded "><a href="ch11-06-Exercises.html"><strong aria-hidden="true">11.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch11-07-Quiz.html"><strong aria-hidden="true">11.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-ThreadsandMultiprocessing.html"><strong aria-hidden="true">12.</strong> Threads and Multiprocessing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-IntroductiontoThreads.html"><strong aria-hidden="true">12.1.</strong> Introduction to Threads</a></li><li class="chapter-item expanded "><a href="ch12-02-ProgrammingwithThreads.html"><strong aria-hidden="true">12.2.</strong> Programming with Threads</a></li><li class="chapter-item expanded "><a href="ch12-03-ThreadsandParallelProcessing.html"><strong aria-hidden="true">12.3.</strong> Threads and Parallel Processing</a></li><li class="chapter-item expanded "><a href="ch12-04-ThreadsandNetworking.html"><strong aria-hidden="true">12.4.</strong> Threads and Networking</a></li><li class="chapter-item expanded "><a href="ch12-05-NetworkProgrammingExample.html"><strong aria-hidden="true">12.5.</strong> Network Programming Example</a></li><li class="chapter-item expanded "><a href="ch12-06-Exercises.html"><strong aria-hidden="true">12.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch12-07-Quiz.html"><strong aria-hidden="true">12.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-GUIProgrammingContinued.html"><strong aria-hidden="true">13.</strong> GUI Programming Continued</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-PropertiesandBindings.html"><strong aria-hidden="true">13.1.</strong> Properties and Bindings</a></li><li class="chapter-item expanded "><a href="ch13-02-FancierGraphics.html"><strong aria-hidden="true">13.2.</strong> Fancier Graphics</a></li><li class="chapter-item expanded "><a href="ch13-03-ComplexComponentsandMVC.html"><strong aria-hidden="true">13.3.</strong> Complex Components and MVC</a></li><li class="chapter-item expanded "><a href="ch13-04-MostlyWindowsandDialogs.html"><strong aria-hidden="true">13.4.</strong> Mostly Windows and Dialogs</a></li><li class="chapter-item expanded "><a href="ch13-05-FinishingTouches.html"><strong aria-hidden="true">13.5.</strong> Finishing Touches</a></li><li class="chapter-item expanded "><a href="ch13-06-Exercises.html"><strong aria-hidden="true">13.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch13-07-Quiz.html"><strong aria-hidden="true">13.7.</strong> Quiz</a></li></ol><li class="chapter-item expanded "><a href="appendix-00.html"> Appendix</a></li><li class="chapter-item expanded "><a href="glossary-00.html"> Glossary</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="Java">Java</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Introduction to Programming Using Java</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Xayarsh/Java-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Linked Data Structures"><a class="header" href="#Linked Data Structures">Linked Data Structures</a></h2>
                        <p>
                            Every useful object contains instance variables.
                            When the type of an instance variable is given by a class or interface name,
                            the variable can hold a reference to another object. Such a reference is also
                            called a pointer, and we say that the variable <span class="newword">points to</span>
                            the object. (Of course, any variable that can contain a reference to
                            an object can also contain the special value <span class="code">null</span>, which points to
                            nowhere.) When one object contains an instance variable that points to another
                            object, we think of the objects as being "linked" by the pointer. Data
                            structures of great complexity can be constructed by linking objects
                            together.</p>

                        
                       <h3 id="Recursive Linking"><a class="header" href="#Recursive Linking">Recursive Linking</a></h3>

                        <p>Something interesting happens when an object contains an instance variable
                            that can refer to another object of the same type. In that case, the definition
                            of the object's class is recursive. Such recursion arises naturally in many
                            cases. For example, consider a class designed to represent employees at a
                            company. Suppose that every employee except the boss has a supervisor, who is
                            another employee of the company. Then the <span class="classname">Employee</span> class would
                            naturally contain an instance variable of type <span class="classname">Employee</span> that points to
                            the employee's supervisor:</p>


                        <pre><code class="java">
/**
 * An object of type Employee holds data about one employee.
 */
public class Employee {
       
   String name;          // Name of the employee.
   
   Employee supervisor;  // The employee's supervisor.

      .
      .  // (Other instance variables and methods.)
      .
      
} // end class Employee</code></pre>


                        <p>If <span class="code">emp</span> is a variable of type <span class="classname">Employee</span>, then
                            <span class="code">emp.supervisor</span> is another variable of type <span class="classname">Employee</span>. If
                            <span class="code">emp</span> refers to the boss, then the value of <span class="code">emp.supervisor</span>
                            should be <span class="code">null</span> to indicate the fact that the boss has no supervisor.
                            If we wanted to print out the name of the employee's supervisor, for example,
                            we could use the following Java statement:</p>


                        <pre><code class="java">if ( emp.supervisor == null) {
   System.out.println( emp.name + " is the boss and has no supervisor!" );
}
else {
   System.out.print( "The supervisor of " + emp.name + " is " );
   System.out.println( emp.supervisor.name );
}</code></pre>


                        <p>Now, suppose that we want to know how many levels of supervisors there are
                            between a given employee and the boss. We just have to follow the chain of
                            command through a series of <span class="code">supervisor</span> links, and count how many steps
                            it takes to get to the boss:</p>


                        <pre><code class="java">if ( emp.supervisor == null ) {
   System.out.println( emp.name + " is the boss!" );
}
else {
   Employee runner;  // For "running" up the chain of command.
   runner = emp.supervisor;
   if ( runner.supervisor == null) {
      System.out.println( emp.name  + " reports directly to the boss." );
   }
   else {
      int count = 0;
      while ( runner.supervisor != null ) {
         count++;  // Count the supervisor on this level.
         runner = runner.supervisor; // Move up to the next level.
      }
      System.out.println( "There are " + count
                             + " supervisors between " + emp.name
                             + " and the boss." );
   }
}</code></pre>


                        <p>As the <span class="code">while</span> loop is executed, <span class="code">runner</span> points in turn to
                            the original employee (<span class="code">emp</span>), then to <span class="code">emp's</span> supervisor, then to
                            the supervisor of <span class="code">emp's</span> supervisor, and so on. The <span class="code">count</span>
                            variable is incremented each time <span class="code">runner</span> "visits" a new employee. The
                            loop ends when <span class="code">runner.supervisor</span> is <span class="code">null</span>, which indicates
                            that <span class="code">runner</span> has reached the boss. At that point, <span class="code">count</span> has
                            counted the number of steps between <span class="code">emp</span> and the boss.</p>


                        <p>In this example, the <span class="code">supervisor</span> variable is quite natural and
                            useful. In fact, data structures that are built by linking objects together are
                            so useful that they are a major topic of study in computer science. We'll be
                            looking at a few typical examples. In this section and the
                            <a href="ch09-03-StacksQueuesADTs.html">next</a>, we'll be looking at <span class="newword">linked lists</span>.
                            A linked list consists of a chain of objects of the same type,
                            linked together by pointers from one object to the next. This is much like the
                            chain of supervisors between <span class="code">emp</span> and the boss in the above example.
                            It's also possible to have more complex situations, in which one object can contain
                            links to several other objects. We'll look at an example of this in <a href="ch09-04-BinaryTrees.html">Section&nbsp;9.4</a>.</p>


                        <p align="center">
                            <img src="./images/linked-data-structures.png" width="432" height="340" alt="Some linked data structures"></p>


                       <h3 id="Linked Lists"><a class="header" href="#Linked Lists">Linked Lists</a></h3>

                        <p>For most of the examples in the rest of this section, linked lists will be constructed out of
                            objects belonging to the class <span class="classname">Node</span> which is defined as follows:</p>


                        <pre><code class="java">class Node {
   String item;
   Node next;
}</code></pre>


                        <p>The term <span class="newword">node</span> is often used to refer to one of
                            the objects in a linked data structure. Objects of type <span class="classname">Node</span> can be
                            chained together as shown in the top part of the above illustration. Each node holds
                            a <span class="classname">String</span> and a pointer to the next node in the list (if any).
                            The last node in such a list can always be identified by the fact that the instance variable
                            <span class="code">next</span> in the last node holds the value <span class="code">null</span> instead of a
                            pointer to another node.  The purpose of the chain of nodes is to represent a list
                            of strings.  The first string in the list is stored in the first node, the second
                            string is stored in the second node, and so on.  The pointers and the node objects
                            are used to build the structure, but the data that we want to represent
                            is the list of strings.  Of course, we could just as easily represent a list of integers or
                            a list of <span class="classname">Colors</span> or a list of any other type of data
                            by changing the type of the <span class="code">item</span> that is stored in each node.</p>



                        <p>Although the <span class="classname">Nodes</span> in this example are very simple, we can use them
                            to illustrate the common operations on linked lists. Typical operations include
                            deleting nodes from the list, inserting new nodes into the list, and searching
                            for a specified <span class="classname">String</span> among the <span class="code">items</span> in the list. We will
                            look at subroutines to perform all of these operations, among others.</p>


                        <p>For a linked list to be used in a program, that program needs a variable
                            that refers to the first node in the list. It only needs a pointer to the first
                            node since all the other nodes in the list can be accessed by starting at the
                            first node and following links along the list from one node to the next.
                            In my examples, I will always use a variable named <span class="code">head</span>, of
                            type <span class="classname">Node</span>, that points to the first node in the linked list. When the
                            list is empty, the value of <span class="code">head</span> is null.</p>


                        <p align="center">
                            <img src="./images/list-with-head.png" width="459" height="113" alt="A variable pointing to the first node of a list"></p>


                       <h3 id="Basic Linked List Processing"><a class="header" href="#Basic Linked List Processing">Basic Linked List Processing</a></h3>

                        <p>It is very common to want to process all the items in a linked list in some way.  The common
                            pattern is to start at the head of the list, then move from each node to the next
                            by following the pointer in the node, stopping when the <span class="code">null</span> that marks
                            the end of the list is reached.  If <span class="code">head</span> is a variable of
                            type <span class="classname">Node</span> that points to the first node in the list, then
                            the general form of the code for processing all the items in a linked list is:</p>


                        <pre><code class="java">Node runner;    // A pointer that will be used to traverse the list.
runner = head;  // Start with runner pointing to the head of the list.
while ( runner != null ) {     // Continue until null is encountered.
   process( runner.item );     // Do something with the item in the current node.
   runner = runner.next;       // Move on to the next node in the list.
}</code></pre>


                        <p>Our only access to the list is
                            through the variable <span class="code">head</span>, so we start by getting a copy of the value
                            in <span class="code">head</span> with the assignment statement <span class="code">runner&nbsp;=&nbsp;head</span>.
                            We need a <b>copy</b> of <span class="code">head</span> because we are going to change the value
                            of <span class="code">runner</span>.
                            We can't change the value of <span class="code">head</span>, or we would lose our only access to
                            the list! The variable <span class="code">runner</span> will point to each node of the list in
                            turn.   When <span class="code">runner</span> points to one of the nodes in the list,
                            <span class="code">runner.next</span> is a pointer to the next node in the list, so the assignment
                            statement <span class="code">runner&nbsp;= runner.next</span> moves the pointer along the  list
                            from each node to the next.  We know that we've reached the end of the list when
                            <span class="code">runner</span> becomes equal to <span class="code">null</span>.
                            Note that our list-processing code works even for an empty list, since for an empty list the value
                            of <span class="code">head</span> is <span class="code">null</span> and the body of the while loop is not executed
                            at all.  As an example, we can print all the strings in a list of <span class="classname">Strings</span>
                            by saying:</p>


                        <pre><code class="java">Node runner = head;
while ( runner != null ) {
   System.out.println( runner.item );
   runner = runner.next;
}</code></pre>


                        <p>The <span class="code">while</span> loop can, by the way, be rewritten as a <span class="code">for</span> loop.
                            Remember that even though the loop control variable in a <span class="code">for</span> loop is often
                            numerical, that is not a requirement.  Here is a <span class="code">for</span> loop that is equivalent
                            to the above <span class="code">while</span> loop:</p>


                        <pre><code class="java">for ( Node runner = head; runner != null; runner = runner.next ) {
   System.out.println( runner.item );
}</code></pre>


                        <p>Similarly, we can traverse a list of integers to add up all the numbers in the list.
                            A linked list of integers can be constructed using the class</p>


                        <pre><code class="java">public class IntNode {
   int item;       // One of the integers in the list.
   IntNode next;   // Pointer to the next node in the list.
}</code></pre>


                        <p>If <span class="code">head</span> is a variable of type <span class="classname">IntNode</span> that points
                            to a linked list of integers, we can find the sum of the integers in the list using:</p>


                        <pre><code class="java">int sum = 0;
IntNode runner = head;
while ( runner != null ) {
   sum = sum + runner.item;   // Add current item to the sum.
   runner = runner.next;
}
System.out.println("The sum of the list of items is " + sum);</code></pre>


                        <p>It is also possible to use recursion to process a linked list.  Recursion is
                            rarely the natural way to process a list, since it's so easy to use a loop to
                            traverse the list.  However, understanding how to apply recursion to lists can
                            help with understanding the recursive processing of more complex data structures.
                            A non-empty linked list can be thought of as consisting of two parts: the
                            <span class="newword">head</span> of the list, which is just the first node in the list,
                            and the <span class="newword">tail</span> of the list, which consists of the remainder
                            of the list after the head.  Note that the tail is itself a linked list
                            and that it is shorter than the original list (by one node).  This is a natural
                            setup for recursion, where the problem of processing a list can be divided into
                            processing the head and recursively processing the tail.  The base case occurs
                            in the case of an empty list (or sometimes in the case of a list of length one).
                            For example, here is a recursive algorithm for adding up the numbers in a linked list of
                            integers:</p>


                        <pre><code class="java">if the list is empty then
   return 0 (since there are no numbers to be added up)
otherwise
   let listsum = the number in the head node 
   let tailsum be the sum of the numbers in the tail list (recursively)
   add tailsum to listsum
   return listsum</code></pre>


                        <p>One remaining question is, how do we get the tail of a non-empty linked list?  If
                            <span class="code">head</span> is a variable that points to the head node of the list,
                            then <span class="code">head.next</span> is a variable that points to the second node
                            of the list&mdash;and that node is in fact the first node of the tail.  So, we
                            can view <span class="code">head.next</span> as a pointer to the tail of the list.
                            One special case is when the original list consists of a single node.
                            In that case, the tail of the list is empty, and <span class="code">head.next</span> is
                            <span class="code">null</span>.  Since an empty list is represented by a null pointer,
                            <span class="code">head.next</span> represents the tail of the list even in this special
                            case.  This allows us to write a recursive list-summing function in Java
                            as</p>


                        <pre><code class="java">/**
 *  Compute the sum of all the integers in a linked list of integers.
 *  @param head a pointer to the first node in the linked list
 */
public static int addItemsInList( IntNode head ) {
   if ( head == null ) {
         // Base case:  The list is empty,  so the sum is zero.
      return 0;
   }
   else {
         // Recursive case:  The list is non-empty.  Find the sum of
         // the tail list, and add that to the item in the head node.
         // (Note that this case could be written simply as
         //     return head.item + addItemsInList( head.next );)
      int listsum = head.item;
      int tailsum = addItemsInList( head.next );
      listsum = listsum + tailsum;
      return listsum;
   }
}</code></pre>


                        <p>I will finish by presenting a list-processing problem that is easy to solve with recursion,
                            but quite tricky to solve without it.  The problem is to print out all the strings in a
                            linked list of strings in the <b>reverse</b> of the order in which they occur in the
                            list.  Note that when we do this, the item in the head of a list is printed out after
                            all the items in the tail of the list.  This leads to the following recursive routine.
                            You should convince yourself that it works, and you should think about trying to do the
                            same thing without using recursion:</p>


                        <pre><code class="java">public static void printReversed( Node head ) {
   if ( head == null ) {
         // Base case:  The list is empty, and there is nothing to print.
      return;
   }
   else {
         // Recursive case:  The list is non-empty.
      printReversed( head.next );  // Print strings from tail, in reverse order.
      System.out.println( head.item );  // Then print string from head node.
   }
}</code></pre>


                        <p>In the rest of this section, we'll look at a few more advanced operations on
                            a linked list of strings.  The subroutines that we consider are instance methods
                            in a class that I wrote named <span class="classname">StringList</span>.  An object of type <span class="classname">StringList</span>
                            represents a linked list of
                            strings. The class has a private instance
                            variable named <span class="code">head</span> of type <span class="classname">Node</span> that points
                            to the first node in the list, or is null if the list is empty.  Instance
                            methods in class <span class="classname">StringList</span> access <span class="code">head</span>
                            as a global variable.  The source code for <span class="classname">StringList</span> is in
                            the file <span class="sourceref"><a href="./source/chapter9/StringList.java">StringList.java</a></span>, and it is used in a
                            sample program named <span class="sourceref"><a href="./source/chapter9/ListDemo.java">ListDemo.java</a></span>, so you can
                            take a look at the code in context if you want.</p>


                        <p>One of the methods in the <span class="classname">StringList</span> class searches the list,
                            looking for a specified string.  If the string that we are looking for is <span class="code">searchItem</span>,
                            then we have to compare <span class="code">searchItem</span> to each
                            <span class="code">item</span> in the list.   This is an example of basic list traversal and
                            processing. However, in this case, we can stop processing if we find the
                            item that we are looking for.</p>


                        <pre><code class="java">/**
 * Searches the list for a specified item. 
 * @param searchItem the item that is to be searched for
 * @return true if searchItem is one of the items in the list or false if
 *    searchItem does not occur in the list.
 */
public boolean find(String searchItem) {

   Node runner;    // A pointer for traversing the list.

   runner = head;  // Start by looking at the head of the list.
                   //   (head is an instance variable! )
   
   while ( runner != null ) {
         // Go through the list looking at the string in each
         // node.  If the string is the one we are looking for,
         // return true, since the string has been found in the list.
      if ( runner.item.equals(searchItem) )
         return true;
      runner = runner.next;  // Move on to the next node.
   }

   // At this point, we have looked at all the items in the list
   // without finding searchItem.  Return false to indicate that
   // the item does not exist in the list.

   return false;

} // end find()</code></pre>



                        <p>It is possible that the list is empty, that is, that the value of
                            <span class="code">head</span> is <span class="code">null</span>. We should be careful that this case is handled
                            properly. In the above code, if <span class="code">head</span> is <span class="code">null</span>, then the body
                            of the <span class="code">while</span> loop is never executed at all, so no nodes are processed
                            and the return value is <span class="code">false</span>.  This is exactly what we want when the
                            list is empty, since the <span class="code">searchItem</span> can't occur in an empty list.</p>
                       
                       <h3 id="Inserting into a Linked List"><a class="header" href="#Inserting into a Linked List">Inserting into a Linked List</a></h3>

                        <p>The problem of inserting a new item into a linked list is more difficult, at least
                            in the case where the item is inserted into the middle of the list.  (In
                            fact, it's probably the most difficult operation on linked data structures that
                            you'll encounter in this chapter.)  In the <span class="classname">StringList</span> class, the
                            <span class="code">items</span> in the nodes of the linked list are kept in increasing order.
                            When a new item is inserted into the list, it must be inserted at the correct
                            position according to this ordering. This means that, usually, we will have to
                            insert the new item somewhere in the middle of the list, between two existing
                            nodes. To do this, it's convenient to have two variables of type <span class="classname">Node</span>,
                            which refer to the existing nodes that will lie on either side of the new node.
                            In the following illustration, these variables are <span class="code">previous</span> and
                            <span class="code">runner</span>. Another variable, <span class="code">newNode</span>, refers to the new node. In
                            order to do the insertion, the link from <span class="code">previous</span> to <span class="code">runner</span>
                            must be "broken," and new links from <span class="code">previous</span> to <span class="code">newNode</span> and
                            from <span class="code">newNode</span> to <span class="code">runner</span> must be added:</p>


                        <p align="center">
                            <img src="./images/insert-in-list.png" width="433" height="289" alt="inserting a node"></p>


                        <p>Once we have <span class="code">previous</span> and <span class="code">runner</span> pointing to the right nodes,
                            the command "<span class="code">previous.next&nbsp;= newNode;</span>" can be used to make
                            <span class="code">previous.next</span> point to the new node.
                            And the command "<span class="code">newNode.next&nbsp;= runner</span>" will set
                            <span class="code">newNode.next</span> to point to the correct place.   However, before we can use
                            these commands, we need to set up <span class="code">runner</span> and <span class="code">previous</span> as
                            shown in the illustration. The idea is to start at the first node of the list,
                            and then move along the list past all the items that are less than the new
                            item. While doing this, we have to be aware of the danger of "falling off the
                            end of the list." That is, we can't continue if <span class="code">runner</span> reaches the end
                            of the list and becomes <span class="code">null</span>. If <span class="code">insertItem</span> is the item that
                            is to be inserted, and if we assume that it does, in fact, belong somewhere in
                            the middle of the list, then the following code would correctly position
                            <span class="code">previous</span> and <span class="code">runner</span>:</p>


                        <pre><code class="java">Node runner, previous;
previous = head;     // Start at the beginning of the list.  
runner = head.next;
while ( runner != null &amp;&amp; runner.item.compareTo(insertItem) &lt; 0 ) {
   previous = runner;  // "previous = previous.next" would also work
   runner = runner.next;
}</code></pre>


                        <p>(This uses the <span class="code">compareTo()</span> instance method from the <span class="classname">String</span>
                            class to test whether the item in the node is less than the item that is being
                            inserted. See <a href="ch02-03-ObjectsAndSubroutines.html">Subsection&nbsp;2.3.3</a>.)</p>


                        <p>This is fine, except that the assumption that the new node is inserted into
                            the middle of the list is not always valid. It might be that
                            <span class="code">insertItem</span> is less than the first item of the list. In that case, the
                            new node must be inserted at the head of the list. This can be done with the
                            instructions</p>


                        <pre><code class="java">newNode.next = head;   // Make newNode.next point to the old head.
head = newNode;        // Make newNode the new head of the list.</code></pre>


                        <p>It is also possible that the list is empty. In that case, <span class="code">newNode</span>
                            will become the first and only node in the list. This can be accomplished
                            simply by setting <span class="code">head = newNode</span>. The following <span class="code">insert()</span>
                            method from the <span class="classname">StringList</span> class covers all of these
                            possibilities:</p>


                        <pre><code class="java">/**
 * Insert a specified item into the list, keeping the list in order.
 * @param insertItem the item that is to be inserted.
 */
public void insert(String insertItem) {

   Node newNode;          // A Node to contain the new item.
   newNode = new Node();
   newNode.item = insertItem;  // (N.B.  newNode.next is null.)

   if ( head == null ) {
          // The new item is the first (and only) one in the list.
          // Set head to point to it.
      head = newNode;
   }
   else if ( head.item.compareTo(insertItem) &gt;= 0 ) {
          // The new item is less than the first item in the list,
          // so it has to be inserted at the head of the list.
      newNode.next = head;
      head = newNode;
   }
   else {
          // The new item belongs somewhere after the first item
          // in the list.  Search for its proper position and insert it.
      Node runner;     // A node for traversing the list.
      Node previous;   // Always points to the node preceding runner.
      runner = head.next;   // Start by looking at the SECOND position.
      previous = head;
      while ( runner != null &amp;&amp; runner.item.compareTo(insertItem) &lt; 0 ) {
             // Move previous and runner along the list until runner
             // falls off the end or hits a list element that is
             // greater than or equal to insertItem.  When this 
             // loop ends, previous indicates the position where
             // insertItem must be inserted.
         previous = runner;
         runner = runner.next;
      }
      newNode.next = runner;     // Insert newNode after previous.
      previous.next = newNode;
   }

}  // end insert()</code></pre>


                        <p>If you were paying close attention to the above discussion, you might have
                            noticed that there is one special case which is not mentioned. What happens if
                            the new node has to be inserted at the <b>end</b> of the list? This will happen if all
                            the items in the list are less than the new item. In fact, this case is already
                            handled correctly by the subroutine, in the last part of the <span class="code">if</span>
                            statement. If <span class="code">insertItem</span> is greater than all the items in the list, then
                            the <span class="code">while</span> loop will end when <span class="code">runner</span> has traversed the entire
                            list and become <span class="code">null</span>. However, when that happens, <span class="code">previous</span>
                            will be left pointing to the last node in the list. Setting <span class="code">previous.next&nbsp;= newNode</span>
                            adds <span class="code">newNode</span> onto the end of the list. Since
                            <span class="code">runner</span> is <span class="code">null</span>, the command <span class="code">newNode.next = runner</span>
                            sets <span class="code">newNode.next</span> to <span class="code">null</span>, which is exactly what is
                            needed to mark the end of the list.</p>


                       <h3 id="Deleting from a Linked List"><a class="header" href="#Deleting from a Linked List">Deleting from a Linked List</a></h3>


                        <p>The delete operation is similar to insert, although a little simpler. There
                            are still special cases to consider. When the first node in the list is to be
                            deleted, then the value of <span class="code">head</span> has to be changed to point to what was
                            previously the second node in the list. Since <span class="code">head.next</span> refers to the
                            second node in the list, this can be done by setting <span class="code">head&nbsp;=&nbsp;head.next</span>.
                            (Once again, you should check that this works when <span class="code">head.next</span> is
                            <span class="code">null</span>, that is, when there is no second node in the list. In that case,
                            the list becomes empty.)</p>


                        <p>If the node that is being deleted is in the middle of the list, then we can
                            set up <span class="code">previous</span> and <span class="code">runner</span> with <span class="code">runner</span> pointing to
                            the node that is to be deleted and with <span class="code">previous</span> pointing to the node
                            that precedes that node in the list. Once that is done, the command
                            "<span class="code">previous.next&nbsp;= runner.next</span>;" will delete the node. The deleted node
                            will be garbage collected.  I encourage you to draw a picture for yourself to illustrate
                            this operation.  Here is the complete code for the <span class="code">delete()</span> method:</p>


                        <pre><code class="java">/**
 * Delete a specified item from the list, if that item is present.
 * If multiple copies of the item are present in the list, only
 * the one that comes first in the list is deleted.
 * @param deleteItem the item to be deleted
 * @return true if the item was found and deleted, or false if the item
 *    was not in the list.
 */
public boolean delete(String deleteItem) {

   if ( head == null ) {
          // The list is empty, so it certainly doesn't contain deleteString.
      return false;
   }
   else if ( head.item.equals(deleteItem) ) {
           // The string is the first item of the list.  Remove it.
      head = head.next;
      return true;
   }
   else {
          // The string, if it occurs at all, is somewhere beyond the 
          // first element of the list.  Search the list.
      Node runner;     // A node for traversing the list.
      Node previous;   // Always points to the node preceding runner.
      runner = head.next;   // Start by looking at the SECOND list node.
      previous = head;
      while ( runner != null &amp;&amp; runner.item.compareTo(deleteItem) &lt; 0 ) {
             // Move previous and runner along the list until runner
             // falls off the end or hits a list element that is
             // greater than or equal to deleteItem.  When this 
             // loop ends, runner indicates the position where
             // deleteItem must be, if it is in the list.
         previous = runner;
         runner = runner.next;
      }
      if ( runner != null &amp;&amp; runner.item.equals(deleteItem) ) {
             // Runner points to the node that is to be deleted.
             // Remove it by changing the pointer in the previous node.
         previous.next = runner.next;
         return true;
      }
      else {
             // The item does not exist in the list.
         return false;
      }
   }

} // end delete()</code></pre>


                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch09-01-Recursion.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch09-03-StacksQueuesADTs.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch09-01-Recursion.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch09-03-StacksQueuesADTs.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </body>
</html>
