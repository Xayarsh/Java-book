<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Programming with the Java Collection Framework - Introduction to Programming Using Java</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

<link rel="stylesheet" href="code-class.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html" >Introduction to Programming Using Java</a></li><li class="chapter-item expanded affix "><a href="preface.html">Preface</a></li><li class="chapter-item expanded "><a href="ch01-00-Overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-FetchExecuteCycle.html"><strong aria-hidden="true">1.1.</strong> Fetch and Execute Cycle</a></li><li class="chapter-item expanded "><a href="ch01-02-AsynchronousEvents.html"><strong aria-hidden="true">1.2.</strong> Asynchronous Events</a></li><li class="chapter-item expanded "><a href="ch01-03-JavaVirtualMachine.html"><strong aria-hidden="true">1.3.</strong> The Java Virtual Machine</a></li><li class="chapter-item expanded "><a href="ch01-04-FundamentalBuildingBlocks.html"><strong aria-hidden="true">1.4.</strong> Fundamentals</a></li><li class="chapter-item expanded "><a href="ch01-05-OOP.html"><strong aria-hidden="true">1.5.</strong> Object Oriented Programming</a></li><li class="chapter-item expanded "><a href="ch01-06-ModernUserInterface.html"><strong aria-hidden="true">1.6.</strong> Modern User Interface</a></li><li class="chapter-item expanded "><a href="ch01-07-InternetAndBeyond.html"><strong aria-hidden="true">1.7.</strong> Internet and Beyond</a></li><li class="chapter-item expanded "><a href="ch01-08-Quiz.html"><strong aria-hidden="true">1.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-NameAndThings.html"><strong aria-hidden="true">2.</strong> Name and Things</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-BasicJavaApplication.html"><strong aria-hidden="true">2.1.</strong> Basic Java Application</a></li><li class="chapter-item expanded "><a href="ch02-02-VariablesAndTypes.html"><strong aria-hidden="true">2.2.</strong> Variables and Types</a></li><li class="chapter-item expanded "><a href="ch02-03-ObjectsAndSubroutines.html"><strong aria-hidden="true">2.3.</strong> Objects and Subroutines</a></li><li class="chapter-item expanded "><a href="ch02-04-TextInputAndOutput.html"><strong aria-hidden="true">2.4.</strong> Text Input and Output</a></li><li class="chapter-item expanded "><a href="ch02-05-DetailsOfExpressions.html"><strong aria-hidden="true">2.5.</strong> Details of Expressions</a></li><li class="chapter-item expanded "><a href="ch02-06-ProgrammingEnvironments.html"><strong aria-hidden="true">2.6.</strong> Programming and Environments</a></li><li class="chapter-item expanded "><a href="ch02-07-Exercises.html"><strong aria-hidden="true">2.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch02-08-Quiz.html"><strong aria-hidden="true">2.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-Control.html"><strong aria-hidden="true">3.</strong> Control</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-BlocksLoopsBranches.html"><strong aria-hidden="true">3.1.</strong> Blocks, Loops and Branches</a></li><li class="chapter-item expanded "><a href="ch03-02-AlgorithmDevelopment.html"><strong aria-hidden="true">3.2.</strong> Algorithm Development</a></li><li class="chapter-item expanded "><a href="ch03-03-While.html"><strong aria-hidden="true">3.3.</strong> while and do...while</a></li><li class="chapter-item expanded "><a href="ch03-04-For.html"><strong aria-hidden="true">3.4.</strong> The for statement</a></li><li class="chapter-item expanded "><a href="ch03-05-If.html"><strong aria-hidden="true">3.5.</strong> The If Statement</a></li><li class="chapter-item expanded "><a href="ch03-06-Switch.html"><strong aria-hidden="true">3.6.</strong> The Switch Statement</a></li><li class="chapter-item expanded "><a href="ch03-07-ExceptionsTryCatch.html"><strong aria-hidden="true">3.7.</strong> Exceptions and try...catch</a></li><li class="chapter-item expanded "><a href="ch03-08-Arrays.html"><strong aria-hidden="true">3.8.</strong> Arrays: An Introduction</a></li><li class="chapter-item expanded "><a href="ch03-09-GUI.html"><strong aria-hidden="true">3.9.</strong> GUI: An Introduction</a></li><li class="chapter-item expanded "><a href="ch03-10-Exercises.html"><strong aria-hidden="true">3.10.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch03-11-Quiz.html"><strong aria-hidden="true">3.11.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-Subroutines.html"><strong aria-hidden="true">4.</strong> Subroutines</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-BlackBoxes.html"><strong aria-hidden="true">4.1.</strong> Black Boxes</a></li><li class="chapter-item expanded "><a href="ch04-02-StaticSubroutines.html"><strong aria-hidden="true">4.2.</strong> Static Subroutines and Variables</a></li><li class="chapter-item expanded "><a href="ch04-03-Parameters.html"><strong aria-hidden="true">4.3.</strong> Parameters</a></li><li class="chapter-item expanded "><a href="ch04-04-ReturnValues.html"><strong aria-hidden="true">4.4.</strong> Return Values</a></li><li class="chapter-item expanded "><a href="ch04-05-Lambda.html"><strong aria-hidden="true">4.5.</strong> Lambda Expressions</a></li><li class="chapter-item expanded "><a href="ch04-06-APIPackagesModulesJavadoc.html"><strong aria-hidden="true">4.6.</strong> API, Packages, Modules and Javadoc</a></li><li class="chapter-item expanded "><a href="ch04-07-MoreOnProgramDesign.html"><strong aria-hidden="true">4.7.</strong> More on Program Design</a></li><li class="chapter-item expanded "><a href="ch04-08-TruthAboutDeclarations.html"><strong aria-hidden="true">4.8.</strong> Truth about Declarations</a></li><li class="chapter-item expanded "><a href="ch04-09-Exercises.html"><strong aria-hidden="true">4.9.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch04-10-Quiz.html"><strong aria-hidden="true">4.10.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-ObjectsClasses.html"><strong aria-hidden="true">5.</strong> Objects and Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-ObjectsAndInstanceMethods.html"><strong aria-hidden="true">5.1.</strong> Objects and Instance Methods</a></li><li class="chapter-item expanded "><a href="ch05-02-ConstructorObjectInit.html"><strong aria-hidden="true">5.2.</strong> Constructor and Object Initialization</a></li><li class="chapter-item expanded "><a href="ch05-03-ProgrammingWithObjects.html"><strong aria-hidden="true">5.3.</strong> Programming with Objects</a></li><li class="chapter-item expanded "><a href="ch05-04-AnExample.html"><strong aria-hidden="true">5.4.</strong> An Example</a></li><li class="chapter-item expanded "><a href="ch05-05-InheritanceAndPolymorphism.html"><strong aria-hidden="true">5.5.</strong> Inheritance and Polymorphism</a></li><li class="chapter-item expanded "><a href="ch05-06-thisandsuper.html"><strong aria-hidden="true">5.6.</strong> this and super</a></li><li class="chapter-item expanded "><a href="ch05-07-Interfaces.html"><strong aria-hidden="true">5.7.</strong> Interfaces</a></li><li class="chapter-item expanded "><a href="ch05-08-NestedClasses.html"><strong aria-hidden="true">5.8.</strong> Nested Classes</a></li><li class="chapter-item expanded "><a href="ch05-09-Exercises.html"><strong aria-hidden="true">5.9.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch05-10-Quiz.html"><strong aria-hidden="true">5.10.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-GUIProgramming.html"><strong aria-hidden="true">6.</strong> Introduction to GUI Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-BasicJavaFXApp.html"><strong aria-hidden="true">6.1.</strong> A Basic JavaFX Application</a></li><li class="chapter-item expanded "><a href="ch06-02-BasicClasses.html"><strong aria-hidden="true">6.2.</strong> Basic Classes</a></li><li class="chapter-item expanded "><a href="ch06-03-BasicEvents.html"><strong aria-hidden="true">6.3.</strong> Basic Events</a></li><li class="chapter-item expanded "><a href="ch06-04-BasicControls.html"><strong aria-hidden="true">6.4.</strong> Basic Controls</a></li><li class="chapter-item expanded "><a href="ch06-05-BasicLayout.html"><strong aria-hidden="true">6.5.</strong> Basic Layout</a></li><li class="chapter-item expanded "><a href="ch06-06-CompetePrograms.html"><strong aria-hidden="true">6.6.</strong> Complete Programs</a></li><li class="chapter-item expanded "><a href="ch06-07-Exercises.html"><strong aria-hidden="true">6.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch06-08-Quiz.html"><strong aria-hidden="true">6.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-ArraysArraylistsRecords.html"><strong aria-hidden="true">7.</strong> Arrays, ArrayLists and Records</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-ArrayDetails.html"><strong aria-hidden="true">7.1.</strong> Array Details</a></li><li class="chapter-item expanded "><a href="ch07-02-ArrayProcessing.html"><strong aria-hidden="true">7.2.</strong> Array Processing</a></li><li class="chapter-item expanded "><a href="ch07-03-ArrayLists.html"><strong aria-hidden="true">7.3.</strong> ArrayLists</a></li><li class="chapter-item expanded "><a href="ch07-04-Records.html"><strong aria-hidden="true">7.4.</strong> Records</a></li><li class="chapter-item expanded "><a href="ch07-05-SearchingAndSorting.html"><strong aria-hidden="true">7.5.</strong> Searching and Sorting</a></li><li class="chapter-item expanded "><a href="ch07-06-2DArrays.html"><strong aria-hidden="true">7.6.</strong> 2D Arrays</a></li><li class="chapter-item expanded "><a href="ch07-07-Exercises.html"><strong aria-hidden="true">7.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch07-08-Quiz.html"><strong aria-hidden="true">7.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-CorrectnessRobustnessEfficiency.html"><strong aria-hidden="true">8.</strong> Correctness, Robustness, Efficiency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-IntroductionCorrectnessandRobustness.html"><strong aria-hidden="true">8.1.</strong> Introduction to Correctness and Robustness</a></li><li class="chapter-item expanded "><a href="ch08-02-WritingCorrectPrograms.html"><strong aria-hidden="true">8.2.</strong> Writing Correct Programs</a></li><li class="chapter-item expanded "><a href="ch08-03-ExceptionsAndtrycatch.html"><strong aria-hidden="true">8.3.</strong> Exceptions and try..catch</a></li><li class="chapter-item expanded "><a href="ch08-04-AssertionsAnnotations.html"><strong aria-hidden="true">8.4.</strong> Assertions and Annotations</a></li><li class="chapter-item expanded "><a href="ch08-05-AnalysisofAlgorithms.html"><strong aria-hidden="true">8.5.</strong> Analysis of Algorithms</a></li><li class="chapter-item expanded "><a href="ch08-06-Exercises.html"><strong aria-hidden="true">8.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch08-07-Quiz.html"><strong aria-hidden="true">8.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-LinkedDataStructuresRecursion.html"><strong aria-hidden="true">9.</strong> Linked Data Structures and Recursion</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-Recursion.html"><strong aria-hidden="true">9.1.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="ch09-02-LinkedDataStructures.html"><strong aria-hidden="true">9.2.</strong> Linked Data Structures</a></li><li class="chapter-item expanded "><a href="ch09-03-StacksQueuesADTs.html"><strong aria-hidden="true">9.3.</strong> Stacks, Queues and ADTs</a></li><li class="chapter-item expanded "><a href="ch09-04-BinaryTrees.html"><strong aria-hidden="true">9.4.</strong> Binary Trees</a></li><li class="chapter-item expanded "><a href="ch09-05-SimpleRecursiveDescentParser.html"><strong aria-hidden="true">9.5.</strong> A Simple Recursive Descent Parser</a></li><li class="chapter-item expanded "><a href="ch09-06-Exercises.html"><strong aria-hidden="true">9.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch09-07-Quiz.html"><strong aria-hidden="true">9.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-GenericProgrammingandCollectionClasses.html"><strong aria-hidden="true">10.</strong> Generic Programmingand Collection Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-GenericProgramming.html"><strong aria-hidden="true">10.1.</strong> Generic Programming</a></li><li class="chapter-item expanded "><a href="ch10-02-ListsandSets.html"><strong aria-hidden="true">10.2.</strong> Lists and Sets</a></li><li class="chapter-item expanded "><a href="ch10-03-Maps.html"><strong aria-hidden="true">10.3.</strong> Maps</a></li><li class="chapter-item expanded "><a class="active" href="ch10-04-JCF.html"><strong aria-hidden="true">10.4.</strong> Programming with the JCF</a></li><li class="chapter-item expanded "><a href="ch10-05-WritingGenericClassesandMethods.html"><strong aria-hidden="true">10.5.</strong> Writing Generic Classes and Methods</a></li><li class="chapter-item expanded "><a href="ch10-06-StreamAPI.html"><strong aria-hidden="true">10.6.</strong> Stream APIs</a></li><li class="chapter-item expanded "><a href="ch10-07-Exercises.html"><strong aria-hidden="true">10.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch10-08-Quiz.html"><strong aria-hidden="true">10.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-IOStreamsFilesNetworking.html"><strong aria-hidden="true">11.</strong> I/O Streams, Files, and Networking</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-IOStreamsReadersAndWriters.html"><strong aria-hidden="true">11.1.</strong> I/O Streams, Readers, and Writers</a></li><li class="chapter-item expanded "><a href="ch11-02-Files.html"><strong aria-hidden="true">11.2.</strong> Files</a></li><li class="chapter-item expanded "><a href="ch11-03-ProgrammingWithFiles.html"><strong aria-hidden="true">11.3.</strong> Programming With Files</a></li><li class="chapter-item expanded "><a href="ch11-04-Networking.html"><strong aria-hidden="true">11.4.</strong> Networking</a></li><li class="chapter-item expanded "><a href="ch11-05-XML.html"><strong aria-hidden="true">11.5.</strong> A Brief Introduction to XML</a></li><li class="chapter-item expanded "><a href="ch11-06-Exercises.html"><strong aria-hidden="true">11.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch11-07-Quiz.html"><strong aria-hidden="true">11.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-ThreadsandMultiprocessing.html"><strong aria-hidden="true">12.</strong> Threads and Multiprocessing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-IntroductiontoThreads.html"><strong aria-hidden="true">12.1.</strong> Introduction to Threads</a></li><li class="chapter-item expanded "><a href="ch12-02-ProgrammingwithThreads.html"><strong aria-hidden="true">12.2.</strong> Programming with Threads</a></li><li class="chapter-item expanded "><a href="ch12-03-ThreadsandParallelProcessing.html"><strong aria-hidden="true">12.3.</strong> Threads and Parallel Processing</a></li><li class="chapter-item expanded "><a href="ch12-04-ThreadsandNetworking.html"><strong aria-hidden="true">12.4.</strong> Threads and Networking</a></li><li class="chapter-item expanded "><a href="ch12-05-NetworkProgrammingExample.html"><strong aria-hidden="true">12.5.</strong> Network Programming Example</a></li><li class="chapter-item expanded "><a href="ch12-06-Exercises.html"><strong aria-hidden="true">12.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch12-07-Quiz.html"><strong aria-hidden="true">12.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-GUIProgrammingContinued.html"><strong aria-hidden="true">13.</strong> GUI Programming Continued</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-PropertiesandBindings.html"><strong aria-hidden="true">13.1.</strong> Properties and Bindings</a></li><li class="chapter-item expanded "><a href="ch13-02-FancierGraphics.html"><strong aria-hidden="true">13.2.</strong> Fancier Graphics</a></li><li class="chapter-item expanded "><a href="ch13-03-ComplexComponentsandMVC.html"><strong aria-hidden="true">13.3.</strong> Complex Components and MVC</a></li><li class="chapter-item expanded "><a href="ch13-04-MostlyWindowsandDialogs.html"><strong aria-hidden="true">13.4.</strong> Mostly Windows and Dialogs</a></li><li class="chapter-item expanded "><a href="ch13-05-FinishingTouches.html"><strong aria-hidden="true">13.5.</strong> Finishing Touches</a></li><li class="chapter-item expanded "><a href="ch13-06-Exercises.html"><strong aria-hidden="true">13.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch13-07-Quiz.html"><strong aria-hidden="true">13.7.</strong> Quiz</a></li></ol><li class="chapter-item expanded "><a href="appendix-00.html"> Appendix</a></li><li class="chapter-item expanded "><a href="glossary-00.html"> Glossary</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="Java">Java</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Introduction to Programming Using Java</h1>

                    <div class="right-buttons">

                        <a href="https://github.com/Xayarsh/Java-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Programming with the Java Collection Framework"><a class="header" href="#Programming with the Java Collection Framework">Programming with the Java Collection Framework</a></h2>
                        <h3 id="Symbol Tables"><a class="header" href="#Symbol Tables">Symbol Tables</a></h3>
                        <p>We begin with a straightforward but important application of maps. When a
                            compiler reads the source code of a program, it encounters definitions of
                            variables, subroutines, and classes. The names of these things can be used
                            later in the program. The compiler has to remember the definition of each name,
                            so that it can recognize the name and apply the definition when the name is
                            encountered later in the program. This is a natural application for a
                            <span class="classname">Map</span>. The name can be used as a key in the map. The value associated to
                            the key is the definition of the name, encoded somehow as an object. A map that
                            is used in this way is called a <span class="newword">symbol table</span>.</p>


                        <p>In a compiler, the values in a symbol table can be quite complicated, since
                            the compiler has to deal with names for various sorts of things, and it needs a
                            different type of information for each different type of name. We will keep
                            things simple by looking at a symbol table in another context. Suppose that we
                            want a program that can evaluate expressions entered by the user, and suppose
                            that the expressions can contain variables, in addition to operators, numbers,
                            and parentheses. For this to make sense, we need some way of assigning values
                            to variables. When a variable is used in an expression, we need to retrieve the
                            variable's value. A symbol table can be used to store the data that we need.
                            The keys for the symbol table are variable names. The value associated with a
                            key is the value of that variable, which is of type <span class="ptype">double</span>.
                            The symbol table will be an object of type <span class="classname">Map&lt;String,Double&gt;</span>.
                            (Remember that primitive types such as <span class="ptype">double</span> can't be used
                            as type parameters; a wrapper class such as <span class="classname">Double</span> must
                            be used instead.  See <a href="ch10-01-GenericProgramming.html">Subsection&nbsp;10.1.7</a>.)</p>


                        <p>To demonstrate the idea, we'll use a rather simple-minded program in which
                            the user types commands such as:</p>


                        <pre><code class="java">let x = 3 + 12
print 2 + 2
print 10*x +17
let rate = 0.06
print 1000*(1+rate)</code></pre>


                        <p>The program is an interpreter for a very simple language.
                            The only two commands that the program understands are "print" and "let".
                            When a "print" command is executed, the computer evaluates the expression and
                            displays the value. If the expression contains a variable, the computer has to
                            look up the value of that variable in the symbol table. A "let" command is used
                            to give a value to a variable. The computer has to store the value of the
                            variable in the symbol table. (Note: The "variables" I am talking about here
                            are not variables in the Java program. The Java program is executing a sort of
                            program typed in by the user. I am talking about variables in the user's
                            program. The user gets to make up variable names, so there is no way for the
                            Java program to know in advance what the variables will be.)</p>


                        <p>In <a href="ch09-05-SimpleRecursiveDescentParser.html">Subsection&nbsp;9.5.2</a>, we saw how to write a program,
                            <span class="sourceref"><a href="./source/chapter9/SimpleParser2.java">SimpleParser2.java</a></span>, that can
                            evaluate expressions that do not contain variables. Here, I will discuss
                            another example program,
                            <span class="sourceref"><a href="./source/chapter10/SimpleInterpreter.java">SimpleInterpreter.java</a></span>, that is based on the older
                            program. I will only talk about the parts that are relevant to the symbol
                            table.</p>



                        <p>The program uses a <span class="classname">HashMap</span> as the symbol table. A <span class="classname">TreeMap</span>
                            could also be used, but since the program does not need to access the variables
                            in alphabetical order, we don't need to have the keys stored in sorted order.
                            The symbol table in the program is represented by a variable named
                            <span class="code">symbolTable</span> of type <span class="classname">HashMap&lt;String,Double&gt;</span>.
                            At the beginning of the program, the symbol table object is created with the command:
                        </p>


                        <pre><code class="java">symbolTable = new HashMap&lt;&gt;();</code></pre>


                        <p>This creates a map that initially contains no key/value associations.
                            To execute a "let" command, the program uses the symbol table's <span class="code">put()</span> method to
                            associate a value with the variable name. Suppose that the name of the variable
                            is given by a <span class="classname">String</span>, <span class="code">varName</span>, and the value
                            of the variable is stored in a variable, <span class="code">val</span>, of type <span class="ptype">double</span>.
                            The following command would then set the value associated with the variable
                            in the symbol table:</p>


                        <pre><code class="java">symbolTable.put( varName, val );</code></pre>


                        <p>In the program <span class="sourceref"><a href="./source/chapter10/SimpleInterpreter.java">SimpleInterpreter.java</a></span>, you'll find this in the
                            method named <span class="code">doLetCommand()</span>.
                            The actual value that is stored in the symbol table is an object of
                            type <span class="classname">Double</span>.  We can use the <span class="ptype">double</span>
                            value <span class="code">val</span> in the call to <span class="code">put</span> because Java does
                            an automatic conversion of type <span class="ptype">double</span> to <span class="classname">Double</span>
                            when necessary.</p>



                        <p>Just for fun, I decided to pre-define two
                            variables named "pi" and "e" whose values are the usual mathematical constants
                            Ï€ and <i>e</i>. In Java, the values of these constants are given by
                            <span class="code">Math.PI</span> and <span class="code">Math.E</span>. To make these variables available to the
                            user of the program, they are added to the symbol table with the commands:</p>


                        <pre><code class="java">symbolTable.put( "pi", Math.PI );
symbolTable.put( "e", Math.E );</code></pre>


                        <p>When the program encounters a variable while evaluating an expression, the
                            symbol table's <span class="code">get()</span> method is used to retrieve its value.
                            The function <span class="code">symbolTable.get(varName)</span> returns a value of
                            type <span class="classname">Double</span>.  It is possible that the return value
                            is <span class="code">null</span>; this will happen if no value has ever been assigned
                            to <span class="code">varName</span> in the symbol table.  It's important to check this
                            possibility.  It indicates that the user is trying to use a variable that
                            the user has not defined.  The program considers this to be an error,
                            so the processing looks something like this:</p>


                        <pre><code class="java">Double val = symbolTable.get(varName);
if (val == null) {
   ... // Throw an exception:  Undefined variable.
}
// The value associated to varName is val.doubleValue()</code></pre>


                        <p>You will find this code, more or less, in a
                            method named <span class="code">primaryValue()</span> in <span class="sourceref"><a href="./source/chapter10/SimpleInterpreter.java">SimpleInterpreter.java</a></span>.</p>


                        <p>As you can see from this example, <span class="classname">Maps</span> are very useful
                            and are really quite easy to use.</p>


                        <h3 id="Sets Inside a Map"><a class="header" href="#Sets Inside a Map">Sets Inside a Map</a></h3>

                        <p>The objects in a collection or map can be of any type. They can even be
                            collections. Here's an example where it's natural to store sets as the value
                            objects in a map.</p>


                        <p>Consider the problem of making an index for a book. An index consists of a
                            list of terms that appear in the book. Next to each term is a list of the pages
                            on which that term appears. To represent an index in a program, we need a data
                            structure that can hold a list of terms, along with a list of pages for each
                            term. Adding new data should be easy and efficient. When it's time to print the
                            index, it should be easy to access the terms in alphabetical order. There are
                            many ways this could be done, but I'd like to use Java's generic data
                            structures and let them do as much of the work as possible.</p>


                        <p>We can think of an index as a <span class="classname">Map</span> that associates a list of page
                            references to each term. The terms are keys, and the value associated with a
                            given key is the list of page references for that term. A <span class="classname">Map</span> can be
                            either a <span class="classname">TreeMap</span> or a <span class="classname">HashMap</span>,
                            but only a <span class="classname">TreeMap</span>
                            will make it easy to access the terms in sorted order. The value associated
                            with a term is a list of page references. How can we represent such a value? If
                            you think about it, you see that it's not really a list in the sense of Java's
                            generic classes. If you look in any index, you'll see that a list of page
                            references has no duplicates, so it's really a set rather than a list.
                            Furthermore, the page references for a given term are always printed in
                            increasing order, so we want a sorted set. This means that we should use a
                            <span class="classname">TreeSet</span> to represent each list of page references. The values that we
                            really want to put in this set are of type <span class="ptype">int</span>, but once again we have
                            to deal with the fact that generic data structures can only hold objects, so we
                            must use the wrapper class, <span class="classname">Integer</span>, for the objects in the set.</p>


                        <p>To summarize, an index will be represented by a <span class="classname">TreeMap</span>. The keys
                            for the map will be terms, which are of type <span class="classname">String</span>. The values in the
                            map will be <span class="classname">TreeSets</span> that contain <span class="classname">Integers</span>
                            representing page numbers.  The parameterized type that
                            we should use for the sets is <span class="classname">TreeSet&lt;Integer&gt;</span>.
                            For the <span class="classname">TreeMap</span> that represents the index as a whole,
                            the key type is <span class="classname">String</span> and the value type is
                            <span class="classname">TreeSet&lt;Integer&gt;</span>.  This means that the index has type
                        </p>


                        <pre><code class="java">TreeMap&lt; String, TreeSet&lt;Integer&gt; &gt;</code></pre>


                        <p>This is just the usual <span class="classname">TreeMap&lt;K,V&gt;</span> with
                            <span class="code">K=String</span> and <span class="code">V=TreeSet&lt;Integer&gt;</span>.  A type name
                            as complicated as this one can look intimidating, but if you think about
                            the data structure that we want to represent, it makes sense.</p>


                        <p>To make an index, we need to start with an empty <span class="classname">TreeMap</span>. We then work
                            through the book, and we insert into the map every reference that we want to be in the index.
                            We then need to print out the data from the
                            map. Let's leave aside the question of how we find the references
                            to put in the index, and just look at how the <span class="classname">TreeMap</span> is used.
                            It can be created with the commands:</p>


                        <pre><code class="java">TreeMap&lt;String,TreeSet&lt;Integer&gt;&gt;  index; // Declare the variable.
index = new TreeMap&lt;&gt;();  // Create the map object.</code></pre>


                        <p>(Note that even for this complex type, the type parameters can be omitted
                            from the constructor.)</p>


                        <p>Now, suppose that we find a reference to some <span class="code">term</span>
                            (of type <span class="classname">String</span>) on some <span class="code">pageNum</span>
                            (of type <span class="ptype">int</span>). We need to
                            insert this information into the index. To do this, we should look up the term
                            in the index, using <span class="code">index.get(term)</span>. The return value is either
                            <span class="code">null</span> or is the set of page references that we have previously found for the
                            term. If the return value is <span class="code">null</span>, then this is the first page
                            reference for the term, so we should add the term to the index, with a new set
                            that contains the page reference we've just found. If the return value is
                            non-<span class="code">null</span>, we already have a set of page references, and we should just add the new page
                            reference to the set. Here is a subroutine that does this:</p>


                        <pre><code class="java">
/**
 * Add a page reference to the index.
 */
void addReference(String term, int pageNum) {
   TreeSet&lt;Integer&gt; references; // The set of page references that we
                                //    have so far for the term.
   references = index.get(term);
   if (references == null){
          // This is the first reference that we have
          // found for the term.  Make a new set containing
          // the page number and add it to the index, with
          // the term as the key.
       TreeSet&lt;Integer&gt; firstRef = new TreeSet&lt;&gt;();
       firstRef.add( pageNum );  // pageNum is "autoboxed" to give an Integer!
       index.put(term,firstRef);
   }
   else {
         // references is the set of page references
         // that we have found previously for the term.
         // Add the new page number to that set.  This
         // set is already associated to term in the index.
      references.add( pageNum );
   }
}</code></pre>


                        <p>The only other thing we need to do with the index is print it out.  We want
                            to iterate through the index and print out each term, together with the
                            set of page references for that term.  We could use an <span class="classname">Iterator</span>
                            to iterate through the index, but it's much easier to do it with a for-each
                            loop.  The loop will iterate through the entry set of the map (see <a href="ch10-03-Maps.html">Subsection&nbsp;10.3.2</a>).
                            Each "entry" is a key/value pair from the map; the key is a term and the value
                            is the associated set of page references.
                            Inside the for-each loop, we will have to print out a set of <span class="classname">Integers</span>,
                            which can also be done with a for-each loop.  So, here we have an example of
                            nested for-each loops.  (You might try to do the same thing entirely with
                            iterators; doing so should give you some appreciation for the for-each loop!)
                            Here is a subroutine that will print the index:
                        </p>



                        <pre><code class="java">/**
 * Print each entry in the index.
 */
void printIndex() {

    for ( Map.Entry&lt;String,TreeSet&lt;Integer&gt;&gt;  entry :  index.entrySet() ) {

        String term = entry.getKey();
        TreeSet&lt;Integer&gt; pageSet = entry.getValue();

        System.out.print( term + ": " );
        for ( int page : pageSet ) {
            System.out.print( page + " " );
        }
        System.out.println();

    }

}</code></pre>


                        <p>The hardest thing here is the name of the type <span class="code">Map.Entry&lt;String,TreeSet&lt;Integer&gt;&gt;</span>!
                            Remember that the entries in a map of type <span class="classname">Map&lt;K,V&gt;</span> have
                            type <span class="classname">Map.Entry&lt;K,V&gt;</span>, so the type parameters in
                            <span class="code">Map.Entry&lt;String,TreeSet&lt;Integer&gt;&gt;</span> are simply copied
                            from the declaration of <span class="code">index</span>.  Another thing to note is that
                            I used a loop control variable, <span class="code">page</span>, of type <span class="classname">int</span>
                            to iterate through the elements of <span class="code">pageSet</span>,
                            which is of type <span class="classname">TreeSet&lt;Integer&gt;</span>.  You might have expected
                            <span class="code">page</span> to be of type <span class="classname">Integer</span>, not <span class="ptype">int</span>,
                            and in fact <span class="classname">Integer</span> would have worked just as well here.
                            However, <span class="ptype">int</span> does work, because of automatic type conversion:
                            It's legal to assign a value of type <span class="classname">Integer</span> to a variable
                            of type <span class="ptype">int</span>.  (To be honest, I was sort of surprised that this worked
                            when I first tried it!)</p>


                        <p>This is not a lot of code, considering the complexity of the operations.
                            I have not written a complete indexing program, but  <a href="ch10-07-Exercises.html">Exercise&nbsp;10.6</a>
                            presents a problem that is almost identical to the indexing problem.</p>


                        <p>(By the way, the <span class="code">printIndex()</span> method could have used <span class="code">var</span>
                            to declare all of its local variables.  This would have avoided the complex type names,
                            but you would still need to be aware of the types, since you have to
                            know what methods, such as <span class="code">entry.getKey()</span>, can be used with the variables.)</p>





                        <p>By the way, in this example, I would prefer to print each list of page references with
                            the integers separated by commas.  In the
                            <span class="code">printIndex()</span> method given above, they are separated by spaces.
                            There is an extra space after the last page reference in the list, but it does
                            no harm since it's invisible in the printout.  An extra comma at the end
                            of the list would be annoying.  The lists should be in a form such as "<span class="code">17,42,105</span>" and
                            not "<span class="code">17,42,105,</span>".  The problem is, how to leave that last comma out.
                            Unfortunately, this is not so easy to do
                            with a for-each loop.  It might be fun to look at a few ways to solve this problem.
                            One alternative is to use an iterator:</p>


                        <pre><code class="java">Iterator&lt;Integer&gt;  iter = pageSet.iterator();
int firstPage = iter.next();  // In this program, we know the set has
                              // at least one element.
System.out.print(firstPage);
while ( iter.hasNext() ) {
   int nextPage = iter.next();
   System.out.print("," + nextPage);
}</code></pre>


                        <p>Another possibility is to use the fact that the <span class="classname">TreeSet</span> class
                            defines a method <span class="code">first()</span> that returns the first item in the set, that is,
                            the one that is smallest in terms of the ordering that is used to compare items in the set.
                            (It also defines the method <span class="code">last()</span>.)  We can solve our problem using
                            this method and a for-each loop:</p>


                        <pre><code class="java">int firstPage = pageSet.first();  // Find out the first page number in the set.
for ( int page : pageSet ) {
   if ( page != firstPage )
      System.out.print(","); // Output comma only if this is not the first page.
   System.out.print(page);
}</code></pre>


                        <p>Finally, here is an elegant solution using a subset view of the tree.
                            (See <a href="ch10-03-Maps.html">Subsection&nbsp;10.3.2</a>.)  Actually, this solution might be
                            a bit extreme:</p>


                        <pre><code class="java">int firstPage = pageSet.first();  // Get first item, which we know exists.
System.out.print(firstPage);      // Print first item, with no comma.
for ( int page : pageSet.tailSet( firstPage+1 ) ) // Process remaining items.
   System.out.print( "," + page );</code></pre>


                        <h3 id="Using a Comparator"><a class="header" href="#Using a Comparator">Using a Comparator</a></h3>

                        <p>There is a potential problem with our solution to the indexing problem. If
                            the terms in the index can contain both upper case and lower case letters, then
                            the terms will <b>not</b> be in alphabetical order! The ordering on <span class="classname">String</span> is
                            not alphabetical. It is based on the Unicode codes of the characters in the
                            string. The codes for all the upper case letters are less than the codes for
                            the lower case letters. So, for example, terms beginning with "Z" come before
                            terms beginning with "a". If the terms are restricted to use lower case letters
                            only (or upper case only), then the ordering would be alphabetical. But suppose
                            that we allow both upper and lower case, and that we insist on alphabetical
                            order. In that case, our index can't use the usual ordering for
                            <span class="code">Strings</span>. Fortunately, it's possible to specify a different method to
                            be used for comparing the keys of a map. This is a typical use for a
                            <span class="classname">Comparator</span>.</p>


                        <p>Recall that an object that implements the interface <span class="classname">Comparator&lt;T&gt;</span>
                            defines a method for comparing two objects of type&nbsp;<span class="classname">T</span>:</p>


                        <pre><code class="java">public int compare( T obj1, T obj2 )</code></pre>


                        <p>This method  should return an integer
                            that is negative, zero, or positive, depending on whether <span class="code">obj1</span> is less
                            than, equal to, or greater than <span class="code">obj2</span>. We want to
                            compare two <span class="classname">Strings</span> ignoring case.
                            The <span class="classname">String</span>
                            class already includes a method that does that, <span class="code">compareToIgnoreCase()</span>.
                            But to use a non-default comparison in a <span class="classname">TreeMap</span>,
                            we need an object of type <span class="classname">Comparator&lt;String&gt;</span>. Since
                            <span class="classname">Comparator</span> is a functional interface, an easy
                            way to specify the comparator is to use a lambda expression:</p>


                        <pre><code class="java">(a,b) -&gt; a.compareToIgnoreCase(b)</code></pre>


                        <p>To solve our indexing problem, we just need to pass this comparator as
                            a parameter to the <span class="classname">TreeMap</span> constructor:</p>


                        <pre><code class="java">index = new TreeMap&lt;&gt;( (a,b) -&gt; a.compareToIgnoreCase(b) );</code></pre>


                        <p>In fact, since the lambda expression is just calling a method that already
                            exists in the <span class="classname">String</span> class, it could actually be
                            given as a method reference (see <a href="ch04-05-Lambda.html">Subsection&nbsp;4.5.4</a>):</p>


                        <pre><code class="java">index = new TreeMap&lt;&gt;( String::compareToIgnoreCase );</code></pre>


                        <p>This does work.  However, there one technicality. Suppose, for example,
                            that the indexing program calls <span class="code">addReference("aardvark",56)</span> and that it later
                            calls <span class="code">addReference("Aardvark",102)</span>. The words "aardvark" and
                            "Aardvark" differ only in that one of them begins with an upper case letter;
                            when converted to lower case, they are the same.
                            When we insert them into the index, do they count as two different terms or as
                            one term? The answer depends on the way that a <span class="classname">TreeMap</span> tests objects
                            for equality. In fact, <span class="classname">TreeMaps</span> and <span class="classname">TreeSets</span> always use a
                            <span class="classname">Comparator</span> object or a <span class="code">compareTo</span> method to test for equality.
                            They do <b>not</b> use the <span class="code">equals()</span> method for this purpose.
                            The <span class="classname">Comparator</span> that is
                            used for the <span class="classname">TreeMap</span> in this example returns the value zero when it is
                            used to compare "aardvark" and "Aardvark", so the <span class="classname">TreeMap</span> considers
                            them to be the same. Page references to "aardvark" and "Aardvark" are combined
                            into a single list, and when the index is printed it will contain only the first
                            version of the word that was encountered by the program.  This is probably
                            acceptable behavior in this example. If
                            not, some other technique must be used to sort the terms into alphabetical
                            order.</p>



                        <h3 id="Word Counting"><a class="header" href="#Word Counting">Word Counting</a></h3>

                        <p>The final example in this section also deals with storing information
                            about words.  The problem here is to make a list of all the words that
                            occur in a file, along with the number of times that each word occurs.
                            The file will be selected by the user.  The output of the program
                            will consist of two lists.  Each list contains all the words from
                            the file, along with the number of times that the word occurred.
                            One list is sorted alphabetically, and the other is sorted according to
                            the number of occurrences, with the most common words at the top and
                            the least common at the bottom.  The problem here is a generalization
                            of <a href="ch07-07-Exercises.html">Exercise&nbsp;7.6</a>, which asked you to make an
                            alphabetical list of all the words in a file, without counting
                            the number of occurrences.</p>


                        <p>My word counting program can be found in the file <span class="sourceref"><a href="./source/chapter10/WordCount.java">WordCount.java</a></span>.
                            As the program reads an input file, it must keep track of how many times it
                            encounters each word. We could simply throw all the words, with duplicates,
                            into a list and count them later. But that would require a lot of extra storage space and
                            would not be very efficient. A better method is to keep a counter for each
                            word. The first time the word is encountered, the counter is initialized to&nbsp;1.
                            On subsequent encounters, the counter is incremented. To keep track of the data
                            for one word, the program uses a simple class that holds a word and the counter
                            for that word. The class is a <span class="code">static</span> nested class:</p>


                        <pre><code class="java">/**
 * Represents the data we need about a word:  the word and
 * the number of times it has been encountered.
 */
private static class WordData {
   String word;
   int count;
   WordData(String w) {
         // Constructor for creating a WordData object when
         // we encounter a new word.
      word = w;
      count = 1;  // The initial value of count is 1.
   }
} // end class WordData</code></pre>


                        <p>The program has to store all the <span class="classname">WordData</span> objects in some sort of
                            data structure. We want to be able to add new words efficiently. Given a word,
                            we need to check whether a <span class="classname">WordData</span> object already exists for that
                            word, and if it does, we need to find that object so that we can increment its
                            counter. A <span class="classname">Map</span> can be used to implement these operations. Given a
                            word, we want to look up a <span class="classname">WordData</span> object in the <span class="classname">Map</span>. This
                            means that the word is the <b>key</b>, and the <span class="classname">WordData</span> object is
                            the <b>value.</b> (It might seem strange that the key is also one of the
                            instance variables in the value object, but in fact this is a very
                            common situation: The value object contains all the information about some
                            entity, and the key is one of those pieces of information; the partial information
                            in the key is used to retrieve the full information in the value object.) After reading the
                            file, we want to output the words in alphabetical order, so we should use a
                            <span class="classname">TreeMap</span> rather than a <span class="classname">HashMap</span>. This program converts all
                            words to lower case so that the default ordering on <span class="code">Strings</span> will put
                            the words in alphabetical order.  The data is stored in a variable named
                            <span class="code">words</span> of type <span class="classname">TreeMap&lt;String,WordData&gt;</span>.
                            The variable is declared and the map object is created with the statement:</p>


                        <pre><code class="java">TreeMap&lt;String,WordData&gt; words = new TreeMap&lt;&gt;();</code></pre>


                        <p>When the program reads a word from a file, it calls <span class="code">words.get(word)</span>
                            to find out if that word is already in the map. If the return value is
                            <span class="code">null</span>, then this is the first time the word has been encountered, so a
                            new <span class="classname">WordData</span> object is created and inserted into the map with the
                            command <span class="code">words.put(word, new WordData(word))</span>. If
                            <span class="code">words.get(word)</span> is not <span class="code">null</span>,
                            then its value is the <span class="classname">WordData</span>
                            object for this word, and the program only has to increment the counter in that
                            object.  The program uses a method <span class="code">readNextWord()</span>, which was
                            given in <a href="ch07-07-Exercises.html">Exercise&nbsp;7.6</a>, to read one word from the file.
                            This method returns <span class="code">null</span> when the end of the file is encountered.
                            Here is the complete code segment that reads the file and collects the
                            data:</p>


                        <pre><code class="java">String word = readNextWord();
while (word != null) {
   word = word.toLowerCase();  // convert word to lower case
   WordData data = words.get(word);
   if (data == null)
      words.put( word, new WordData(word) );
   else
      data.count++;
   word = readNextWord();
}</code></pre>


                        <p>After reading the words and printing them out in alphabetical order, the
                            program has to sort the words by frequency and print them again. To do
                            the sorting using a generic algorithm, we can copy the <span class="classname">WordData</span>
                            objects into a list and then use the generic method
                            <span class="code">Collections.sort(list,comparator)</span>, which specifies a comparator
                            as its second parameter.  Since we want to sort the data into <b>decreasing</b> order
                            by count, we want a comparator for two <span class="classname">WordData</span> values <span class="code">a</span>
                            and <span class="code">b</span> that puts <span class="code">a</span> before <span class="code">b</span> if
                            <span class="code">a.count&nbsp;&gt;&nbsp;b.count</span>.  You should check that the
                            following lambda expression defines a comparator that will work here:</p>


                        <pre><code class="java">(a,b) -&gt; b.count - a.count</code></pre>


                        <p>The <span class="classname">WordData</span> objects that we need are
                            the values in the map, <span class="code">words</span>.  Recall that <span class="code">words.values()</span> returns a
                            <span class="classname">Collection</span> that contains all the values from the map. The constructor for the
                            <span class="classname">ArrayList</span> class lets you specify a collection to be copied into the
                            list when it is created. So, we can use the following commands to create a list of type
                            <span class="classname">ArrayList&lt;WordData&gt;</span> containing the word
                            data and then sort that list according to frequency:</p>


                        <pre><code class="java">ArrayList&lt;WordData&gt; wordsByFrequency = new ArrayList&lt;&gt;( words.values() );
Collections.sort( wordsByFrequency, (a,b) -&gt; b.count - a.count );</code></pre>


                        <p>You should notice that these two lines replace a lot of code! It requires
                            some practice to think in terms of generic data structures and algorithms, but
                            the payoff is significant in terms of saved time and effort.</p>


                        <p>The only remaining problem is to print the data. We have
                            to print the data from all the <span class="classname">WordData</span> objects twice, first in
                            alphabetical order and then sorted according to frequency count. The data is in
                            alphabetical order in the <span class="classname">TreeMap</span>, or more precisely, in the values of
                            the <span class="classname">TreeMap</span>.  We can use a for-each loop to
                            print the data in the collection <span class="code">words.values()</span>, and the words will appear
                            in alphabetical order.  Another for-each loop can be used to print the
                            data in the list <span class="code">wordsByFrequency</span>, and the words will be printed
                            in order of decreasing frequency.  Here is the code that does it:</p>


                        <pre><code class="java">TextIO.putln("List of words in alphabetical order"
      + " (with counts in parentheses):\n");
for ( WordData data : words.values() )
   TextIO.putln("   " + data.word + " (" + data.count + ")");

TextIO.putln("\n\nList of words by frequency of occurrence:\n");
for ( WordData data : wordsByFrequency )
   TextIO.putln("   " + data.word + " (" + data.count + ")");</code></pre>


                        <p>You can find the complete word-counting program in the file
                            <span class="sourceref"><a href="./source/chapter10/WordCount.java">WordCount.java</a></span>.  Note that for reading and writing
                            files, it uses the file I/O capabilities of <span class="sourceref"><a href="./source/chapter10/textio/TextIO.java">TextIO.java</a></span>,
                            which were discussed in <a href="ch02-04-TextInputAndOutput.html">Subsection&nbsp;2.4.4</a>.</p>


                        <p>By the way, if you run the WordCount program on a reasonably large file
                            and take a look at the output,
                            it will illustrate something about the <span class="code">Collections.sort()</span> method.
                            The second list of words in the output is ordered by frequency, but if you
                            look at a group of words that all have the same frequency, you will see that
                            the words in that group are in alphabetical order.  The method
                            <span class="code">Collections.sort()</span> was applied to sort the words by frequency,
                            but before it was applied, the words were already in alphabetical order.
                            When <span class="code">Collections.sort()</span> rearranged the words, it did not
                            change the ordering of words that have the same frequency, so they were
                            still in alphabetical order within the group of words with that frequency.  This is
                            because the algorithm used by <span class="code">Collections.sort()</span> is a
                            <span class="newword">stable</span> sorting algorithm.  A sorting algorithm is
                            said to be stable if it satisfies the following condition:  When the algorithm
                            is used to sort a list according to some property of the items in the
                            list, then the sort does not change the relative order of items that
                            have the same value of that property.  That is, if item&nbsp;B comes
                            after item&nbsp;A in the list before the sort, and if both items have
                            the same value for the property that is being used as the basis for
                            sorting, then item&nbsp;B will still come after item&nbsp;A after the
                            sorting has been done.  Neither SelectionSort nor QuickSort are stable
                            sorting algorithms.  Insertion sort is stable, but
                            is not very fast.  Merge sort, the sorting algorithm used by <span class="code">Collections.sort()</span>,
                            is both stable and fast.</p>


                        <p>I hope that the programming examples in this section have convinced you
                            of the usefulness of the Java Collection Framework!</p>


                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch10-03-Maps.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch10-05-WritingGenericClassesandMethods.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch10-03-Maps.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch10-05-WritingGenericClassesandMethods.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </body>
</html>
