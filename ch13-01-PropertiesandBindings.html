<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Properties and Bindings - Introduction to Programming Using Java</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

<link rel="stylesheet" href="code-class.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html" >Introduction to Programming Using Java</a></li><li class="chapter-item expanded affix "><a href="preface.html">Preface</a></li><li class="chapter-item expanded "><a href="ch01-00-Overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-FetchExecuteCycle.html"><strong aria-hidden="true">1.1.</strong> Fetch and Execute Cycle</a></li><li class="chapter-item expanded "><a href="ch01-02-AsynchronousEvents.html"><strong aria-hidden="true">1.2.</strong> Asynchronous Events</a></li><li class="chapter-item expanded "><a href="ch01-03-JavaVirtualMachine.html"><strong aria-hidden="true">1.3.</strong> The Java Virtual Machine</a></li><li class="chapter-item expanded "><a href="ch01-04-FundamentalBuildingBlocks.html"><strong aria-hidden="true">1.4.</strong> Fundamentals</a></li><li class="chapter-item expanded "><a href="ch01-05-OOP.html"><strong aria-hidden="true">1.5.</strong> Object Oriented Programming</a></li><li class="chapter-item expanded "><a href="ch01-06-ModernUserInterface.html"><strong aria-hidden="true">1.6.</strong> Modern User Interface</a></li><li class="chapter-item expanded "><a href="ch01-07-InternetAndBeyond.html"><strong aria-hidden="true">1.7.</strong> Internet and Beyond</a></li><li class="chapter-item expanded "><a href="ch01-08-Quiz.html"><strong aria-hidden="true">1.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-NameAndThings.html"><strong aria-hidden="true">2.</strong> Name and Things</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-BasicJavaApplication.html"><strong aria-hidden="true">2.1.</strong> Basic Java Application</a></li><li class="chapter-item expanded "><a href="ch02-02-VariablesAndTypes.html"><strong aria-hidden="true">2.2.</strong> Variables and Types</a></li><li class="chapter-item expanded "><a href="ch02-03-ObjectsAndSubroutines.html"><strong aria-hidden="true">2.3.</strong> Objects and Subroutines</a></li><li class="chapter-item expanded "><a href="ch02-04-TextInputAndOutput.html"><strong aria-hidden="true">2.4.</strong> Text Input and Output</a></li><li class="chapter-item expanded "><a href="ch02-05-DetailsOfExpressions.html"><strong aria-hidden="true">2.5.</strong> Details of Expressions</a></li><li class="chapter-item expanded "><a href="ch02-06-ProgrammingEnvironments.html"><strong aria-hidden="true">2.6.</strong> Programming and Environments</a></li><li class="chapter-item expanded "><a href="ch02-07-Exercises.html"><strong aria-hidden="true">2.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch02-08-Quiz.html"><strong aria-hidden="true">2.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-Control.html"><strong aria-hidden="true">3.</strong> Control</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-BlocksLoopsBranches.html"><strong aria-hidden="true">3.1.</strong> Blocks, Loops and Branches</a></li><li class="chapter-item expanded "><a href="ch03-02-AlgorithmDevelopment.html"><strong aria-hidden="true">3.2.</strong> Algorithm Development</a></li><li class="chapter-item expanded "><a href="ch03-03-While.html"><strong aria-hidden="true">3.3.</strong> while and do...while</a></li><li class="chapter-item expanded "><a href="ch03-04-For.html"><strong aria-hidden="true">3.4.</strong> The for statement</a></li><li class="chapter-item expanded "><a href="ch03-05-If.html"><strong aria-hidden="true">3.5.</strong> The If Statement</a></li><li class="chapter-item expanded "><a href="ch03-06-Switch.html"><strong aria-hidden="true">3.6.</strong> The Switch Statement</a></li><li class="chapter-item expanded "><a href="ch03-07-ExceptionsTryCatch.html"><strong aria-hidden="true">3.7.</strong> Exceptions and try...catch</a></li><li class="chapter-item expanded "><a href="ch03-08-Arrays.html"><strong aria-hidden="true">3.8.</strong> Arrays: An Introduction</a></li><li class="chapter-item expanded "><a href="ch03-09-GUI.html"><strong aria-hidden="true">3.9.</strong> GUI: An Introduction</a></li><li class="chapter-item expanded "><a href="ch03-10-Exercises.html"><strong aria-hidden="true">3.10.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch03-11-Quiz.html"><strong aria-hidden="true">3.11.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-Subroutines.html"><strong aria-hidden="true">4.</strong> Subroutines</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-BlackBoxes.html"><strong aria-hidden="true">4.1.</strong> Black Boxes</a></li><li class="chapter-item expanded "><a href="ch04-02-StaticSubroutines.html"><strong aria-hidden="true">4.2.</strong> Static Subroutines and Variables</a></li><li class="chapter-item expanded "><a href="ch04-03-Parameters.html"><strong aria-hidden="true">4.3.</strong> Parameters</a></li><li class="chapter-item expanded "><a href="ch04-04-ReturnValues.html"><strong aria-hidden="true">4.4.</strong> Return Values</a></li><li class="chapter-item expanded "><a href="ch04-05-Lambda.html"><strong aria-hidden="true">4.5.</strong> Lambda Expressions</a></li><li class="chapter-item expanded "><a href="ch04-06-APIPackagesModulesJavadoc.html"><strong aria-hidden="true">4.6.</strong> API, Packages, Modules and Javadoc</a></li><li class="chapter-item expanded "><a href="ch04-07-MoreOnProgramDesign.html"><strong aria-hidden="true">4.7.</strong> More on Program Design</a></li><li class="chapter-item expanded "><a href="ch04-08-TruthAboutDeclarations.html"><strong aria-hidden="true">4.8.</strong> Truth about Declarations</a></li><li class="chapter-item expanded "><a href="ch04-09-Exercises.html"><strong aria-hidden="true">4.9.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch04-10-Quiz.html"><strong aria-hidden="true">4.10.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-ObjectsClasses.html"><strong aria-hidden="true">5.</strong> Objects and Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-ObjectsAndInstanceMethods.html"><strong aria-hidden="true">5.1.</strong> Objects and Instance Methods</a></li><li class="chapter-item expanded "><a href="ch05-02-ConstructorObjectInit.html"><strong aria-hidden="true">5.2.</strong> Constructor and Object Initialization</a></li><li class="chapter-item expanded "><a href="ch05-03-ProgrammingWithObjects.html"><strong aria-hidden="true">5.3.</strong> Programming with Objects</a></li><li class="chapter-item expanded "><a href="ch05-04-AnExample.html"><strong aria-hidden="true">5.4.</strong> An Example</a></li><li class="chapter-item expanded "><a href="ch05-05-InheritanceAndPolymorphism.html"><strong aria-hidden="true">5.5.</strong> Inheritance and Polymorphism</a></li><li class="chapter-item expanded "><a href="ch05-06-thisandsuper.html"><strong aria-hidden="true">5.6.</strong> this and super</a></li><li class="chapter-item expanded "><a href="ch05-07-Interfaces.html"><strong aria-hidden="true">5.7.</strong> Interfaces</a></li><li class="chapter-item expanded "><a href="ch05-08-NestedClasses.html"><strong aria-hidden="true">5.8.</strong> Nested Classes</a></li><li class="chapter-item expanded "><a href="ch05-09-Exercises.html"><strong aria-hidden="true">5.9.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch05-10-Quiz.html"><strong aria-hidden="true">5.10.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-GUIProgramming.html"><strong aria-hidden="true">6.</strong> Introduction to GUI Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-BasicJavaFXApp.html"><strong aria-hidden="true">6.1.</strong> A Basic JavaFX Application</a></li><li class="chapter-item expanded "><a href="ch06-02-BasicClasses.html"><strong aria-hidden="true">6.2.</strong> Basic Classes</a></li><li class="chapter-item expanded "><a href="ch06-03-BasicEvents.html"><strong aria-hidden="true">6.3.</strong> Basic Events</a></li><li class="chapter-item expanded "><a href="ch06-04-BasicControls.html"><strong aria-hidden="true">6.4.</strong> Basic Controls</a></li><li class="chapter-item expanded "><a href="ch06-05-BasicLayout.html"><strong aria-hidden="true">6.5.</strong> Basic Layout</a></li><li class="chapter-item expanded "><a href="ch06-06-CompetePrograms.html"><strong aria-hidden="true">6.6.</strong> Complete Programs</a></li><li class="chapter-item expanded "><a href="ch06-07-Exercises.html"><strong aria-hidden="true">6.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch06-08-Quiz.html"><strong aria-hidden="true">6.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-ArraysArraylistsRecords.html"><strong aria-hidden="true">7.</strong> Arrays, ArrayLists and Records</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-ArrayDetails.html"><strong aria-hidden="true">7.1.</strong> Array Details</a></li><li class="chapter-item expanded "><a href="ch07-02-ArrayProcessing.html"><strong aria-hidden="true">7.2.</strong> Array Processing</a></li><li class="chapter-item expanded "><a href="ch07-03-ArrayLists.html"><strong aria-hidden="true">7.3.</strong> ArrayLists</a></li><li class="chapter-item expanded "><a href="ch07-04-Records.html"><strong aria-hidden="true">7.4.</strong> Records</a></li><li class="chapter-item expanded "><a href="ch07-05-SearchingAndSorting.html"><strong aria-hidden="true">7.5.</strong> Searching and Sorting</a></li><li class="chapter-item expanded "><a href="ch07-06-2DArrays.html"><strong aria-hidden="true">7.6.</strong> 2D Arrays</a></li><li class="chapter-item expanded "><a href="ch07-07-Exercises.html"><strong aria-hidden="true">7.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch07-08-Quiz.html"><strong aria-hidden="true">7.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-CorrectnessRobustnessEfficiency.html"><strong aria-hidden="true">8.</strong> Correctness, Robustness, Efficiency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-IntroductionCorrectnessandRobustness.html"><strong aria-hidden="true">8.1.</strong> Introduction to Correctness and Robustness</a></li><li class="chapter-item expanded "><a href="ch08-02-WritingCorrectPrograms.html"><strong aria-hidden="true">8.2.</strong> Writing Correct Programs</a></li><li class="chapter-item expanded "><a href="ch08-03-ExceptionsAndtrycatch.html"><strong aria-hidden="true">8.3.</strong> Exceptions and try..catch</a></li><li class="chapter-item expanded "><a href="ch08-04-AssertionsAnnotations.html"><strong aria-hidden="true">8.4.</strong> Assertions and Annotations</a></li><li class="chapter-item expanded "><a href="ch08-05-AnalysisofAlgorithms.html"><strong aria-hidden="true">8.5.</strong> Analysis of Algorithms</a></li><li class="chapter-item expanded "><a href="ch08-06-Exercises.html"><strong aria-hidden="true">8.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch08-07-Quiz.html"><strong aria-hidden="true">8.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-LinkedDataStructuresRecursion.html"><strong aria-hidden="true">9.</strong> Linked Data Structures and Recursion</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-Recursion.html"><strong aria-hidden="true">9.1.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="ch09-02-LinkedDataStructures.html"><strong aria-hidden="true">9.2.</strong> Linked Data Structures</a></li><li class="chapter-item expanded "><a href="ch09-03-StacksQueuesADTs.html"><strong aria-hidden="true">9.3.</strong> Stacks, Queues and ADTs</a></li><li class="chapter-item expanded "><a href="ch09-04-BinaryTrees.html"><strong aria-hidden="true">9.4.</strong> Binary Trees</a></li><li class="chapter-item expanded "><a href="ch09-05-SimpleRecursiveDescentParser.html"><strong aria-hidden="true">9.5.</strong> A Simple Recursive Descent Parser</a></li><li class="chapter-item expanded "><a href="ch09-06-Exercises.html"><strong aria-hidden="true">9.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch09-07-Quiz.html"><strong aria-hidden="true">9.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-GenericProgrammingandCollectionClasses.html"><strong aria-hidden="true">10.</strong> Generic Programmingand Collection Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-GenericProgramming.html"><strong aria-hidden="true">10.1.</strong> Generic Programming</a></li><li class="chapter-item expanded "><a href="ch10-02-ListsandSets.html"><strong aria-hidden="true">10.2.</strong> Lists and Sets</a></li><li class="chapter-item expanded "><a href="ch10-03-Maps.html"><strong aria-hidden="true">10.3.</strong> Maps</a></li><li class="chapter-item expanded "><a href="ch10-04-JCF.html"><strong aria-hidden="true">10.4.</strong> Programming with the JCF</a></li><li class="chapter-item expanded "><a href="ch10-05-WritingGenericClassesandMethods.html"><strong aria-hidden="true">10.5.</strong> Writing Generic Classes and Methods</a></li><li class="chapter-item expanded "><a href="ch10-06-StreamAPI.html"><strong aria-hidden="true">10.6.</strong> Stream APIs</a></li><li class="chapter-item expanded "><a href="ch10-07-Exercises.html"><strong aria-hidden="true">10.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch10-08-Quiz.html"><strong aria-hidden="true">10.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-IOStreamsFilesNetworking.html"><strong aria-hidden="true">11.</strong> I/O Streams, Files, and Networking</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-IOStreamsReadersAndWriters.html"><strong aria-hidden="true">11.1.</strong> I/O Streams, Readers, and Writers</a></li><li class="chapter-item expanded "><a href="ch11-02-Files.html"><strong aria-hidden="true">11.2.</strong> Files</a></li><li class="chapter-item expanded "><a href="ch11-03-ProgrammingWithFiles.html"><strong aria-hidden="true">11.3.</strong> Programming With Files</a></li><li class="chapter-item expanded "><a href="ch11-04-Networking.html"><strong aria-hidden="true">11.4.</strong> Networking</a></li><li class="chapter-item expanded "><a href="ch11-05-XML.html"><strong aria-hidden="true">11.5.</strong> A Brief Introduction to XML</a></li><li class="chapter-item expanded "><a href="ch11-06-Exercises.html"><strong aria-hidden="true">11.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch11-07-Quiz.html"><strong aria-hidden="true">11.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-ThreadsandMultiprocessing.html"><strong aria-hidden="true">12.</strong> Threads and Multiprocessing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-IntroductiontoThreads.html"><strong aria-hidden="true">12.1.</strong> Introduction to Threads</a></li><li class="chapter-item expanded "><a href="ch12-02-ProgrammingwithThreads.html"><strong aria-hidden="true">12.2.</strong> Programming with Threads</a></li><li class="chapter-item expanded "><a href="ch12-03-ThreadsandParallelProcessing.html"><strong aria-hidden="true">12.3.</strong> Threads and Parallel Processing</a></li><li class="chapter-item expanded "><a href="ch12-04-ThreadsandNetworking.html"><strong aria-hidden="true">12.4.</strong> Threads and Networking</a></li><li class="chapter-item expanded "><a href="ch12-05-NetworkProgrammingExample.html"><strong aria-hidden="true">12.5.</strong> Network Programming Example</a></li><li class="chapter-item expanded "><a href="ch12-06-Exercises.html"><strong aria-hidden="true">12.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch12-07-Quiz.html"><strong aria-hidden="true">12.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-GUIProgrammingContinued.html"><strong aria-hidden="true">13.</strong> GUI Programming Continued</a></li><li><ol class="section"><li class="chapter-item expanded "><a class="active" href="ch13-01-PropertiesandBindings.html"><strong aria-hidden="true">13.1.</strong> Properties and Bindings</a></li><li class="chapter-item expanded "><a href="ch13-02-FancierGraphics.html"><strong aria-hidden="true">13.2.</strong> Fancier Graphics</a></li><li class="chapter-item expanded "><a href="ch13-03-ComplexComponentsandMVC.html"><strong aria-hidden="true">13.3.</strong> Complex Components and MVC</a></li><li class="chapter-item expanded "><a href="ch13-04-MostlyWindowsandDialogs.html"><strong aria-hidden="true">13.4.</strong> Mostly Windows and Dialogs</a></li><li class="chapter-item expanded "><a href="ch13-05-FinishingTouches.html"><strong aria-hidden="true">13.5.</strong> Finishing Touches</a></li><li class="chapter-item expanded "><a href="ch13-06-Exercises.html"><strong aria-hidden="true">13.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch13-07-Quiz.html"><strong aria-hidden="true">13.7.</strong> Quiz</a></li></ol><li class="chapter-item expanded "><a href="appendix-00.html"> Appendix</a></li><li class="chapter-item expanded "><a href="glossary-00.html"> Glossary</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="Java">Java</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Introduction to Programming Using Java</h1>

                    <div class="right-buttons">

                        <a href="https://github.com/Xayarsh/Java-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>

                        <h2 id="Properties and Bindings"><a class="header" href="#Properties and Bindings">Properties and Bindings</a></h2>
                        <p>
                            We have seen that GUI programming makes heavy
                            use of events, including low-level mouse and keyboard events and higher-level
                            events such as those that are generated when the user makes a menu selection
                            or adjusts the value of a slider.  In <a href="ch06-04-BasicControls.html">Subsection&nbsp;6.4.5</a>, we saw that
                            events from a slider actually come from an "observable property" of the slider.
                            That is, in order to respond to changes in the value of a <span class="classname">Slider</span>,
                            <span class="code">sldr</span>, you need to register a listener with the <span class="code">valueProperty</span>
                            of the slider:</p>


                        <pre><code class="java">sldr.valueProperty().addListener( . . . );</code></pre>


                        <p>When the value of the slider changes, its <span class="code">valueProperty</span> emits
                            an event that allows your event-handling code to respond to the change.</p>


                        <p>In fact, the value property of a slider is an object of type
                            <span class="classname">DoubleProperty</span>.  A <span class="classname">DoubleProperty</span>
                            has several aspects.  First of all, it wraps a value of type <span class="ptype">double</span>,
                            and it has methods <span class="code">get()</span> and <span class="code">set()</span> for retrieving and
                            changing that value. Second, it is an "observable value," which means that it emits
                            events when the <span class="ptype">double</span> value is changed.  Third, it is a
                            "bindable property," an aspect that is possibly unique to JavaFX.  A bindable
                            property can be bound to another property of the same type.  Properties that
                            are bound in this way are forced to have the same value.  Bindable
                            properties are used throughout the JavaFX API.  This section explores how
                            and why they are used. </p>


                        <p>The classes discussed in this section are defined in package <span class="code">javafx.beans</span>
                            and its subpackages.  However, you will rarely need to import classes from those packages
                            into your JavaFX programs, since you will mostly be using objects that already exist.</p>


                        <h3 id="Observable Values"><a class="header" href="#Observable Values">Observable Values</a></h3>

                        <p>Many instance variables in JavaFX objects are <span class="newword">observable values</span>, meaning that they emit
                            events.  Many of the observables are actually <span class="newword">observable properties</span> in the sense that they are bindable.
                            The width and height of a canvas are observables of type <span class="classname">DoubleProperty</span>.
                            The text in a text field or label is an observable of type <span class="classname">StringProperty</span>.
                            The list of children of a <span class="classname">Pane</span> is an observable of type
                            <span class="atype">ObservableList&lt;Node&gt;</span>.   A checkbox has
                            observable property of type <span class="classname">BooleanProperty</span> that says whether
                            the box is currently checked. The color of the text in a label is an
                            observable of type <span class="atype">ObjectProperty&lt;Paint&gt;</span>. </p>


                        <p>An observable value emits two kinds of events.  It emits a change event
                            whenever the value changes.  A handler for the event must implement the parameterized functional interface
                            <span class="atype">ChangeListener&lt;T&gt;</span>, which defines a method <span class="code">changed(target,oldValue,newValue)</span>.
                            The first parameter of <span class="code">change()</span> is the observable whose value has changed; the second parameter
                            is the previous value of that observable; and the third parameter is the new value.  Suppose, for example,
                            we want the text on a label to display the current value of a slider.  When the slider value changes,
                            we need to change the text on the label to match.  One way to do that is to register a change listener with
                            the property that records the value of the slider:</p>


                        <pre><code class="java">slider.valueProperty().addListener(
            (t,oldVal,newVal) -&gt; label.setText("Slider Value: " + newVal) );</code></pre>


                        <p>However, we will see below that there is a better way to accomplish the same thing.</p>


                        <p>The second type of event emitted by an observable value is an invalidation event,
                            which is emitted when the current value becomes invalid for some reason.  An invalid value
                            will never be seen by another object; any attempt to read the value will cause the value to
                            be recomputed and become valid again.  An invalidation event is a notice that the value needs
                            to be recomputed, but the value won't actually be recomputed until it is needed.   This is
                            something called "lazy evaluation" of the value: The work of recomputing the value is not done
                            until the new value is actually needed for something.  Lazy evaluation can be more efficient
                            than recomputing the value every time it is invalidated.  Let's say a dozen things happen
                            that invalidate the value before the value is needed&mdash;with lazy evaluation, the value will
                            only be recomputed once, when it is needed, rather than a dozen times.
                            More important for us, the observable would only emit one invalidation event, not a dozen.
                            This avoids multiple redundant calls to invalidation listeners.  In most cases in JavaFX,
                            invalidation listeners should be used in preference to change listeners.</p>


                        <p>An <span class="classname">InvalidationListener</span> defines the single method <span class="code">invalidated(obv)</span>,
                            where the parameter is the observable that has been invalidated.  Consider this code,
                            where <span class="code">sayHello</span> is a <span class="classname">CheckBox</span>:</p>


                        <pre><code class="java">sayHello.selectedProperty().addListener( e -&gt; {
    if (sayHello.isSelected())
        label.settext("Hello");
    else
        label.setText("Goodbye");
});</code></pre>


                        <p>In this example, an <span class="classname">InvalidationListener</span> is registered as a listener.
                            You could accomplish almost the same thing using <span class="code">sayHello.setOnAction()</span>.
                            However, an <span class="classname">ActionListener</span> would be called only when the <b>user</b>
                            changes the selected state of the checkbox, while the invalidation listener is called whenever
                            the value changes, including changes made by calling <span class="code">sayHello.setSelected()</span>.
                            Note that <span class="classname">ChangeListeners</span> are also registered using a method named <span class="code">addListener()</span>.
                            The compiler can tell the difference, even when the listener is given by a lambda expression,
                            because a lambda expression for a <span class="classname">ChangeListener</span>
                            has three parameters, while a lambda expression for an <span class="classname">InvalidationListener</span>
                            has only one parameter.</p>


                        <p>You might have asked yourself what would happen if the <span class="code">selectedProperty</span> of <span class="code">sayHello</span>
                            was merely invalidated rather than changed.  Would <span class="code">sayHello.isSelected()</span>  return the
                            current invalid value or the new value?  In fact, calling <span class="code">sayHello.isSelected()</span>
                            would force the computation of the new value, and it would return the new value.  An invalid
                            value is never seen because any attempt to read it forces the new value to be computed.</p>


                        <p>The general pattern in JavaFX is that an observable property of an object is accessed by calling
                            an instance method whose name
                            ends with "Property".  For example, the value property of a slider is given by <span class="code">slider.valueProperty()</span>,
                            and the text property of a label is given by <span class="code">label.textProperty()</span>.  Some JavaFX objects have
                            observable values that are not properties.  An observable property is bindable, as we will see
                            in the next section.  A plain observable value is not bindable, but it does emit change events
                            and invalidation events, and you can register listeners if you want to respond to changes
                            in the value.</p>

                        <h3 id="Bindable Properties"><a class="header" href="#Bindable Properties">Bindable Properties</a></h3>

                        <p>Many JavaFX observable properties can be bound to another property of the same type.
                            (The exceptions are "read-only properties"; you can't bind a read-only property to another
                            property, although you <b>can</b> bind a property <b>to</b> a read-only property.)
                            As a basic example, suppose that we want the text in a label to always be the same as
                            the text in a text field.  That can be implemented simply by binding the <span class="code">textProperty</span>
                            of the label to the <span class="code">textProperty</span> of the text field:</p>


                        <pre><code class="java">Label message = new Label("Never Seen");
TextField input = new TextField("Type Here!");
message.textProperty().bind( input.textProperty() );</code></pre>


                        <p>The <span class="code">bind()</span> method forces the value of <span class="code">message.textProperty()</span>
                            to be the same as the value of <span class="code">input.textProperty()</span>.  As soon as <span class="code">bind()</span>
                            is executed, the text from the text field is copied into the label, so that the initial
                            text in the label&mdash;"Never&nbsp;Seen" in the example&mdash;is never seen by the user.
                            As the program runs, any change to the text in the
                            text field will automatically be applied to the label as well, whether that change is due to the
                            user typing in the text field or due to <span class="code">input.setText()</span> being called.
                            Bindings are implemented internally using events and listeners, but the point is that
                            you don't have to set up the listeners and respond to the events yourself&mdash;everything is set up
                            by the <span class="code">bind()</span> method.</p>


                        <p>When <span class="code">bind()</span> is used to bind a property to another property,
                            it becomes illegal to change the value of the bound property directly.  In the
                            example, any call to <span class="code">message.setText()</span> would throw an exception.
                            And of course, a property can only be bound to one other property at a time.
                            The <span class="code">unbind()</span> method, which takes no parameter, can be used to remove a binding:</p>


                        <pre><code class="java">message.textProperty().unbind();</code></pre>


                        <p>The sample program <span class="sourceref"><a href="./source/chapter13/BoundPropertyDemo.java">BoundPropertyDemo.java</a></span> contains several examples
                            of bound properties.  In particular, the text property of a large label is bound to the
                            text property of a text field, as in the preceding example, so that typing in the text field also changes the text
                            on the label.  Here is a screenshot:</p>


                        <p align="center">
                            <img src="./images/bound-property-demo.png" width="500" height="141" alt="screeshot of BoundPropertyDemo.java"></p>


                        <p>The label at the lower right of this window provides another example of binding.  The label
                            displays the value of the slider, and the text
                            on the label will change as the user adjusts the slider value.  As noted at the beginning of
                            this section, one way to implement this interaction would be to register a listener with the
                            slider's <span class="code">valueProperty</span>.  Here, however, it's done with a binding.
                            Now, the <span class="code">textProprety</span> of the label is a <span class="classname">StringProperty</span>
                            while the <span class="code">valueProperty</span> of the slider is a <span class="classname">DoubleProperty</span>,
                            so it's not possible to directly bind the two values.  A binding only works for properties
                            of the same type.  However, a <span class="classname">DoubleProperty</span> has a method,
                            <span class="code">asString()</span> that converts the property into a string property.
                            That is, if <span class="code">slider</span> is a <span class="classname">Slider</span>, then</p>


                        <pre><code class="java">slider.valueProperty().asString()</code></pre>


                        <p>is a string property representing the <span class="ptype">double</span> value
                            of the slider as a string.  The text property of a label can be bound to that
                            string property.  In fact, <span class="code">asString()</span> can take a format string (like the
                            ones used with <span class="code">System.out.printf</span>) as an optional parameter that is used
                            to format the <span class="ptype">double</span>
                            value.  In the program, the label is <span class="code">sliderVal</span>, and its text property
                            is bound by saying:</p>


                        <pre><code class="java">sliderVal.textProperty().bind(
                   slider.valueProperty().asString("Slider Value: %1.2f") );</code></pre>


                        <p>(Actually, <span class="code">slider.valueProperty().asString</span> is of type <span class="classname">StringBinding</span>
                            rather than <span class="classname">StringProperty</span>, but the distinction is not important here,
                            and I will ignore it.)</p>


                        <p>Property objects have many methods for converting properties of one
                            type into properties of another type, as well as other operations.  For another
                            example, a <span class="classname">DoubleProperty</span> has a method <span class="code">lessThan(number)</span>
                            that returns a boolean property whose value is <span class="code">true</span>
                            when the value of the <span class="classname">DoubleProperty</span> is less than <span class="code">number</span>.
                            For example, a <span class="classname">Button</span>, <span class="code">btn</span> has a <span class="classname">BooleanProperty</span>,
                            <span class="code">btn.disableProperty()</span> that tells whether the button is disabled.  If we want the
                            button to be disabled when the value on a slider is less than 20, we can do that by
                            binding the button's disable property as follows:</p>


                        <pre><code class="java">btn.disableProperty().bind( slider.valueProperty().lessThan(20) );</code></pre>


                        <p>There are similar methods <span class="code">greaterThan()</span>, <span class="code">lessThanOrEqual()</span>,
                            <span class="code">isNotEqualTo()</span>, and so on.  There are also methods for doing math.  For
                            example,</p>


                        <pre><code class="java">slider.valueProperty().multiply(2)</code></pre>


                        <p>is a double property whose value is 2 times the value of the slider.</p>





                        <p>The class <span class="classname">When</span>, from package <span class="code">javafx.beans.binding</span>,
                            can be used to apply something like the ternary operator, "?:" (see <a href="ch02-05-DetailsOfExpressions.html">Subsection&nbsp;2.5.5</a>),
                            to boolean properties, with a rather strange syntax.  If <span class="code">boolProp</span> is a boolean
                            property, and if <span class="code">trueVal</span> and <span class="code">falseVal</span> are any values that both have
                            the same type, then</p>


                        <pre><code class="java">new When(boolProp).then(trueVal).otherwise(falseVal)</code></pre>


                        <p>represents a property whose type is the same as the type of <span class="code">trueVal</span>
                            and <span class="code">falseVal</span>.  The value of this property is <span class="code">trueVal</span> if
                            <span class="code">boolProp</span> has the value <span class="code">true</span>, and the value is <span class="code">falseVal</span>
                            if <span class="code">boolProp</span> has the value <span class="code">false</span>.</p>


                        <p>In an earlier example, we used a listener to set the text in a label to "Hello" or
                            "Goodbye" depending on whether or not a checkbox, <span class="code">sayHello</span>, is checked.
                            Here's how to do the same thing with a property binding:</p>


                        <pre><code class="java">label.textProperty().bind(
     new When(sayHello.selectedProperty()).then("Hello").otherwise("Goodbye")
);</code></pre>


                        <p>The parameter in <span class="code">new When(sayHello.selectedProperty())</span> is a boolean
                            property.  Since "Hello" and "Goodbye" are values of type <span class="classname">String</span>,
                            the property that results from the complete expression is a string property, which matches the type of
                            <span class="code">label.textProperty()</span>.</p>


                        <p>The same sort of thing is done in <span class="sourceref"><a href="./source/chapter13/BoundPropertyDemo.java">BoundPropertyDemo.java</a></span> to control the
                            background color of the big label.  The background is controlled by a checkbox using binding
                            and an object of type <span class="classname">When</span>.  See the well-commented source code for
                            details.</p>





                        <p>A straightforward, but useful, application of property binding can be found in the
                            sample program <span class="sourceref"><a href="./source/chapter13/CanvasResizeDemo.java">CanvasResizeDemo.java</a></span>.  The program shows fifty small
                            red disks that bounce around in a window.  The disks are drawn to a <span class="classname">Canvas</span>
                            that fills the window, and the disks bounce off the edges of the canvas.
                            In previous examples that used a canvas, the window was made
                            non-resizable because canvasses do not automatically change size.  However, it is possible
                            for a program to change the size of a canvas by setting the canvas's height and width
                            properties.  That can be done by calling <span class="code">canvas.setWidth(w)</span> and
                            <span class="code">canvas.setHeight(h)</span>.  However, the height and width are bindable properties
                            of type <span class="classname">DoubleProperty</span>, so another way to set the canvas size
                            is to bind these properties to an appropriate source.</p>


                        <p>In the program, the canvas is contained in a <span class="classname">Pane</span>
                            that serves as the root of the scene graph and fills the window.  When the size of the
                            window is changed by the user, the size of the <span class="classname">Pane</span> is automatically
                            set to match.  If we want the canvas size to track the size of the pane, it is only
                            necessary to bind the width property of the canvas to the width property of the
                            pane, and to bind the height property of the canvas to the height property of
                            the pane.  That is done in the program with two lines of code:</p>


                        <pre><code class="java">canvas.widthProperty().bind( root.widthProperty() );
canvas.heightProperty().bind( root.heightProperty() );</code></pre>


                        <p>If you run the program and increase the size of the window, you can see that the
                            canvas has also increased in size, because the bouncing red disks will spread out to
                            fill the larger space.  Similarly, if you decrease the size, the disks will be trapped
                            in the smaller space.</p>


                        <p>In this program, the canvas is being continually redrawn, so no special action needs
                            to be taken to redraw it when the canvas size is changed.  In some programs, it might
                            be necessary to redraw the contents of the canvas when its size changes.  One way to
                            make that happen is to add listeners to the width and height properties of the
                            canvas.  The listeners can redraw the canvas in response to changes in the width
                            or height.</p>

                        <h3 id="Bidirectional Bindings"><a class="header" href="#Bidirectional Bindings">Bidirectional Bindings</a></h3>

                        <p>Bindings created using the <span class="code">bind()</span> method are one-way bindings: They
                            only work in one direction.  One-way
                            bindings are not always appropriate.  Suppose for example that <span class="code">cb1</span>
                            and <span class="code">cb2</span> are of type <span class="classname">CheckBox</span>, and that we
                            would like the two checkboxes to always be in the same state.  That can't be
                            done with a one-way binding.  If we do</p>


                        <pre><code class="java">cb2.selectedProperty().bind( cb1.selectedProperty() );</code></pre>


                        <p>that will make <span class="code">cb2</span> match its state to <span class="code">cb1</span>.
                            But changing the selected state of <span class="code">cb2</span> will not change the state of
                            <span class="code">cb1</span>; instead, it will cause an exception, since it is illegal
                            to try to change the value of a property that has been bound using
                            <span class="code">bind()</span>.  In fact, if the user just clicks <span class="code">cb2</span>,
                            there will be an exception as the checkbox tries to change state.</p>


                        <p>The solution that we need here is something called a <span class="newword">bidirectional
binding</span>.  When two properties are bound bidirectionally, then
                            the value of either property can be changed, and
                            the other property will automatically be changed to the same value.
                            Bidirectional bindings are set up with the method
                            <span class="code">bindBidirectional()</span>.  For our two checkboxes,
                            we can say:</p>


                        <pre><code class="java">cb2.selectedProperty().bindBidirectional( cb1.selectedProperty() );</code></pre>


                        <p>Now, the user can click either checkbox, and the other will also
                            change state.  This would probably not be useful for two checkboxes,
                            but it can be useful to synchronize the state of a <span class="classname">CheckBox</span>
                            in a window with the state of a <span class="classname">CheckMenuItem</span> in
                            a menu.  The user would have a choice of using either interface element.
                            Similar redundant interface elements are common in menus and toolbars.</p>


                        <p>The sample program <span class="sourceref"><a href="./source/chapter13/BoundPropertyDemo.java">BoundPropertyDemo.java</a></span> does
                            something similar with <span class="classname">RadioButtons</span> and
                            <span class="classname">RadioMenuItems</span>.  The color of the label in the program
                            can be controlled using either a "Color" menu or a set of
                            radio buttons.  The state of each <span class="classname">RadioButton</span>
                            is bidirectionally bound to the state of a corresponding
                            <span class="classname">RadioMenuItem</span>.  It might be worth looking
                            at how it's done in detail:</p>


                        <pre><code class="java">Menu colorMenu = new Menu("Color");

Color[] colors = { Color.BLACK, Color.RED, Color.GREEN, Color.BLUE };
String[] colorNames = { "Black", "Red", "Green", "Blue" };

ToggleGroup colorGroup = new ToggleGroup();

for (int i = 0; i &lt; colors.length; i++) {

        // Make a menu item and corresponding radio button.
    RadioButton button = new RadioButton(colorNames[i]);
    RadioMenuItem menuItem = new RadioMenuItem(colorNames[i]);

    button.selectedProperty().bindBidirectional( menuItem.selectedProperty() );

    menuItem.setToggleGroup(colorGroup);

        // Note how UserData is used to store the color object
        // associated with the menu item, for later use.
    menuItem.setUserData(colors[i]);

    right.getChildren().add(button);    // add button to a container
    colorMenu.getItems().add(menuItem); // add menu item to a menu
    if (i == 0)
        menuItem.setSelected(true);
}

colorGroup.selectedToggleProperty().addListener( e -&gt; {
            // Listen for changes to the selectedToggleProperty
            // of the ToggleGroup, so that the color of the
            // label can be set to match the selected menu item.
    Toggle t = colorGroup.getSelectedToggle();
    if (t != null) {
            // t is the selected RadioMenuItem.  Get the color
            // from its UserData, and use it to set the color
            // of the text.  The value of the selectedToggleProperty()
            // can momentarily be null as one toggle is unselected
            // and another is selected.
        Color c = (Color)t.getUserData();
        message.setTextFill(c);
    }
});</code></pre>


                        <p>Note that the menu items are added to a <span class="classname">ToggleGroup</span>
                            (see <a href="ch06-04-BasicControls.html">Subsection&nbsp;6.4.3</a>), but the buttons are not.  Suppose that the user clicks on
                            a currently unselected radio button.  The state of the button changes to
                            "selected."  Because of the bidirectional binding, the state of the
                            corresponding radio menu item must also be changed to "selected."
                            Before that can happen, however, the <span class="classname">ToggleGroup</span>
                            will change the state of the currently selected radio menu item to "unselected,"
                            which will in turn cause the state of its associated radio button to change
                            to "unselected".  In the end, the states of two radio buttons and two
                            radio menu items are changed.</p>


                        <p>(Although it is not relevant to property binding, you should also check out
                            how this code uses the <span class="code">userData</span> property of the radio buttons.
                            Every scene graph node has user data of type <span class="classname">Object</span>,
                            which is not used by the system.  The <span class="code">userData</span> property of a node can be
                            a convenient place for a programmer to store data of any type that the
                            programmer wants to associate with the node.  In this case, the user
                            data for a radio menu item is a value of type <span class="classname">Color</span>,
                            and that color value is used when the menu item is selected.)</p>





                        <p>I hope that the examples in this section have convinced you that
                            property binding can be an effective way to program interactions
                            between objects in a JavaFX program.  This style of programming might
                            look strange at first, but it can be easier and clearer than working
                            directly with events and listeners.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch13-00-GUIProgrammingContinued.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch13-02-FancierGraphics.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch13-00-GUIProgrammingContinued.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch13-02-FancierGraphics.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </body>
</html>
