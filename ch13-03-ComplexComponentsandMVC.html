<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Complex Components and MVC - Introduction to Programming Using Java</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

<link rel="stylesheet" href="code-class.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html" >Introduction to Programming Using Java</a></li><li class="chapter-item expanded affix "><a href="preface.html">Preface</a></li><li class="chapter-item expanded "><a href="ch01-00-Overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-FetchExecuteCycle.html"><strong aria-hidden="true">1.1.</strong> Fetch and Execute Cycle</a></li><li class="chapter-item expanded "><a href="ch01-02-AsynchronousEvents.html"><strong aria-hidden="true">1.2.</strong> Asynchronous Events</a></li><li class="chapter-item expanded "><a href="ch01-03-JavaVirtualMachine.html"><strong aria-hidden="true">1.3.</strong> The Java Virtual Machine</a></li><li class="chapter-item expanded "><a href="ch01-04-FundamentalBuildingBlocks.html"><strong aria-hidden="true">1.4.</strong> Fundamentals</a></li><li class="chapter-item expanded "><a href="ch01-05-OOP.html"><strong aria-hidden="true">1.5.</strong> Object Oriented Programming</a></li><li class="chapter-item expanded "><a href="ch01-06-ModernUserInterface.html"><strong aria-hidden="true">1.6.</strong> Modern User Interface</a></li><li class="chapter-item expanded "><a href="ch01-07-InternetAndBeyond.html"><strong aria-hidden="true">1.7.</strong> Internet and Beyond</a></li><li class="chapter-item expanded "><a href="ch01-08-Quiz.html"><strong aria-hidden="true">1.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-NameAndThings.html"><strong aria-hidden="true">2.</strong> Name and Things</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-BasicJavaApplication.html"><strong aria-hidden="true">2.1.</strong> Basic Java Application</a></li><li class="chapter-item expanded "><a href="ch02-02-VariablesAndTypes.html"><strong aria-hidden="true">2.2.</strong> Variables and Types</a></li><li class="chapter-item expanded "><a href="ch02-03-ObjectsAndSubroutines.html"><strong aria-hidden="true">2.3.</strong> Objects and Subroutines</a></li><li class="chapter-item expanded "><a href="ch02-04-TextInputAndOutput.html"><strong aria-hidden="true">2.4.</strong> Text Input and Output</a></li><li class="chapter-item expanded "><a href="ch02-05-DetailsOfExpressions.html"><strong aria-hidden="true">2.5.</strong> Details of Expressions</a></li><li class="chapter-item expanded "><a href="ch02-06-ProgrammingEnvironments.html"><strong aria-hidden="true">2.6.</strong> Programming and Environments</a></li><li class="chapter-item expanded "><a href="ch02-07-Exercises.html"><strong aria-hidden="true">2.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch02-08-Quiz.html"><strong aria-hidden="true">2.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-Control.html"><strong aria-hidden="true">3.</strong> Control</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-BlocksLoopsBranches.html"><strong aria-hidden="true">3.1.</strong> Blocks, Loops and Branches</a></li><li class="chapter-item expanded "><a href="ch03-02-AlgorithmDevelopment.html"><strong aria-hidden="true">3.2.</strong> Algorithm Development</a></li><li class="chapter-item expanded "><a href="ch03-03-While.html"><strong aria-hidden="true">3.3.</strong> while and do...while</a></li><li class="chapter-item expanded "><a href="ch03-04-For.html"><strong aria-hidden="true">3.4.</strong> The for statement</a></li><li class="chapter-item expanded "><a href="ch03-05-If.html"><strong aria-hidden="true">3.5.</strong> The If Statement</a></li><li class="chapter-item expanded "><a href="ch03-06-Switch.html"><strong aria-hidden="true">3.6.</strong> The Switch Statement</a></li><li class="chapter-item expanded "><a href="ch03-07-ExceptionsTryCatch.html"><strong aria-hidden="true">3.7.</strong> Exceptions and try...catch</a></li><li class="chapter-item expanded "><a href="ch03-08-Arrays.html"><strong aria-hidden="true">3.8.</strong> Arrays: An Introduction</a></li><li class="chapter-item expanded "><a href="ch03-09-GUI.html"><strong aria-hidden="true">3.9.</strong> GUI: An Introduction</a></li><li class="chapter-item expanded "><a href="ch03-10-Exercises.html"><strong aria-hidden="true">3.10.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch03-11-Quiz.html"><strong aria-hidden="true">3.11.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-Subroutines.html"><strong aria-hidden="true">4.</strong> Subroutines</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-BlackBoxes.html"><strong aria-hidden="true">4.1.</strong> Black Boxes</a></li><li class="chapter-item expanded "><a href="ch04-02-StaticSubroutines.html"><strong aria-hidden="true">4.2.</strong> Static Subroutines and Variables</a></li><li class="chapter-item expanded "><a href="ch04-03-Parameters.html"><strong aria-hidden="true">4.3.</strong> Parameters</a></li><li class="chapter-item expanded "><a href="ch04-04-ReturnValues.html"><strong aria-hidden="true">4.4.</strong> Return Values</a></li><li class="chapter-item expanded "><a href="ch04-05-Lambda.html"><strong aria-hidden="true">4.5.</strong> Lambda Expressions</a></li><li class="chapter-item expanded "><a href="ch04-06-APIPackagesModulesJavadoc.html"><strong aria-hidden="true">4.6.</strong> API, Packages, Modules and Javadoc</a></li><li class="chapter-item expanded "><a href="ch04-07-MoreOnProgramDesign.html"><strong aria-hidden="true">4.7.</strong> More on Program Design</a></li><li class="chapter-item expanded "><a href="ch04-08-TruthAboutDeclarations.html"><strong aria-hidden="true">4.8.</strong> Truth about Declarations</a></li><li class="chapter-item expanded "><a href="ch04-09-Exercises.html"><strong aria-hidden="true">4.9.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch04-10-Quiz.html"><strong aria-hidden="true">4.10.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-ObjectsClasses.html"><strong aria-hidden="true">5.</strong> Objects and Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-ObjectsAndInstanceMethods.html"><strong aria-hidden="true">5.1.</strong> Objects and Instance Methods</a></li><li class="chapter-item expanded "><a href="ch05-02-ConstructorObjectInit.html"><strong aria-hidden="true">5.2.</strong> Constructor and Object Initialization</a></li><li class="chapter-item expanded "><a href="ch05-03-ProgrammingWithObjects.html"><strong aria-hidden="true">5.3.</strong> Programming with Objects</a></li><li class="chapter-item expanded "><a href="ch05-04-AnExample.html"><strong aria-hidden="true">5.4.</strong> An Example</a></li><li class="chapter-item expanded "><a href="ch05-05-InheritanceAndPolymorphism.html"><strong aria-hidden="true">5.5.</strong> Inheritance and Polymorphism</a></li><li class="chapter-item expanded "><a href="ch05-06-thisandsuper.html"><strong aria-hidden="true">5.6.</strong> this and super</a></li><li class="chapter-item expanded "><a href="ch05-07-Interfaces.html"><strong aria-hidden="true">5.7.</strong> Interfaces</a></li><li class="chapter-item expanded "><a href="ch05-08-NestedClasses.html"><strong aria-hidden="true">5.8.</strong> Nested Classes</a></li><li class="chapter-item expanded "><a href="ch05-09-Exercises.html"><strong aria-hidden="true">5.9.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch05-10-Quiz.html"><strong aria-hidden="true">5.10.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-GUIProgramming.html"><strong aria-hidden="true">6.</strong> Introduction to GUI Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-BasicJavaFXApp.html"><strong aria-hidden="true">6.1.</strong> A Basic JavaFX Application</a></li><li class="chapter-item expanded "><a href="ch06-02-BasicClasses.html"><strong aria-hidden="true">6.2.</strong> Basic Classes</a></li><li class="chapter-item expanded "><a href="ch06-03-BasicEvents.html"><strong aria-hidden="true">6.3.</strong> Basic Events</a></li><li class="chapter-item expanded "><a href="ch06-04-BasicControls.html"><strong aria-hidden="true">6.4.</strong> Basic Controls</a></li><li class="chapter-item expanded "><a href="ch06-05-BasicLayout.html"><strong aria-hidden="true">6.5.</strong> Basic Layout</a></li><li class="chapter-item expanded "><a href="ch06-06-CompetePrograms.html"><strong aria-hidden="true">6.6.</strong> Complete Programs</a></li><li class="chapter-item expanded "><a href="ch06-07-Exercises.html"><strong aria-hidden="true">6.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch06-08-Quiz.html"><strong aria-hidden="true">6.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-ArraysArraylistsRecords.html"><strong aria-hidden="true">7.</strong> Arrays, ArrayLists and Records</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-ArrayDetails.html"><strong aria-hidden="true">7.1.</strong> Array Details</a></li><li class="chapter-item expanded "><a href="ch07-02-ArrayProcessing.html"><strong aria-hidden="true">7.2.</strong> Array Processing</a></li><li class="chapter-item expanded "><a href="ch07-03-ArrayLists.html"><strong aria-hidden="true">7.3.</strong> ArrayLists</a></li><li class="chapter-item expanded "><a href="ch07-04-Records.html"><strong aria-hidden="true">7.4.</strong> Records</a></li><li class="chapter-item expanded "><a href="ch07-05-SearchingAndSorting.html"><strong aria-hidden="true">7.5.</strong> Searching and Sorting</a></li><li class="chapter-item expanded "><a href="ch07-06-2DArrays.html"><strong aria-hidden="true">7.6.</strong> 2D Arrays</a></li><li class="chapter-item expanded "><a href="ch07-07-Exercises.html"><strong aria-hidden="true">7.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch07-08-Quiz.html"><strong aria-hidden="true">7.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-CorrectnessRobustnessEfficiency.html"><strong aria-hidden="true">8.</strong> Correctness, Robustness, Efficiency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-IntroductionCorrectnessandRobustness.html"><strong aria-hidden="true">8.1.</strong> Introduction to Correctness and Robustness</a></li><li class="chapter-item expanded "><a href="ch08-02-WritingCorrectPrograms.html"><strong aria-hidden="true">8.2.</strong> Writing Correct Programs</a></li><li class="chapter-item expanded "><a href="ch08-03-ExceptionsAndtrycatch.html"><strong aria-hidden="true">8.3.</strong> Exceptions and try..catch</a></li><li class="chapter-item expanded "><a href="ch08-04-AssertionsAnnotations.html"><strong aria-hidden="true">8.4.</strong> Assertions and Annotations</a></li><li class="chapter-item expanded "><a href="ch08-05-AnalysisofAlgorithms.html"><strong aria-hidden="true">8.5.</strong> Analysis of Algorithms</a></li><li class="chapter-item expanded "><a href="ch08-06-Exercises.html"><strong aria-hidden="true">8.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch08-07-Quiz.html"><strong aria-hidden="true">8.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-LinkedDataStructuresRecursion.html"><strong aria-hidden="true">9.</strong> Linked Data Structures and Recursion</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-Recursion.html"><strong aria-hidden="true">9.1.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="ch09-02-LinkedDataStructures.html"><strong aria-hidden="true">9.2.</strong> Linked Data Structures</a></li><li class="chapter-item expanded "><a href="ch09-03-StacksQueuesADTs.html"><strong aria-hidden="true">9.3.</strong> Stacks, Queues and ADTs</a></li><li class="chapter-item expanded "><a href="ch09-04-BinaryTrees.html"><strong aria-hidden="true">9.4.</strong> Binary Trees</a></li><li class="chapter-item expanded "><a href="ch09-05-SimpleRecursiveDescentParser.html"><strong aria-hidden="true">9.5.</strong> A Simple Recursive Descent Parser</a></li><li class="chapter-item expanded "><a href="ch09-06-Exercises.html"><strong aria-hidden="true">9.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch09-07-Quiz.html"><strong aria-hidden="true">9.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-GenericProgrammingandCollectionClasses.html"><strong aria-hidden="true">10.</strong> Generic Programmingand Collection Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-GenericProgramming.html"><strong aria-hidden="true">10.1.</strong> Generic Programming</a></li><li class="chapter-item expanded "><a href="ch10-02-ListsandSets.html"><strong aria-hidden="true">10.2.</strong> Lists and Sets</a></li><li class="chapter-item expanded "><a href="ch10-03-Maps.html"><strong aria-hidden="true">10.3.</strong> Maps</a></li><li class="chapter-item expanded "><a href="ch10-04-JCF.html"><strong aria-hidden="true">10.4.</strong> Programming with the JCF</a></li><li class="chapter-item expanded "><a href="ch10-05-WritingGenericClassesandMethods.html"><strong aria-hidden="true">10.5.</strong> Writing Generic Classes and Methods</a></li><li class="chapter-item expanded "><a href="ch10-06-StreamAPI.html"><strong aria-hidden="true">10.6.</strong> Stream APIs</a></li><li class="chapter-item expanded "><a href="ch10-07-Exercises.html"><strong aria-hidden="true">10.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch10-08-Quiz.html"><strong aria-hidden="true">10.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-IOStreamsFilesNetworking.html"><strong aria-hidden="true">11.</strong> I/O Streams, Files, and Networking</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-IOStreamsReadersAndWriters.html"><strong aria-hidden="true">11.1.</strong> I/O Streams, Readers, and Writers</a></li><li class="chapter-item expanded "><a href="ch11-02-Files.html"><strong aria-hidden="true">11.2.</strong> Files</a></li><li class="chapter-item expanded "><a href="ch11-03-ProgrammingWithFiles.html"><strong aria-hidden="true">11.3.</strong> Programming With Files</a></li><li class="chapter-item expanded "><a href="ch11-04-Networking.html"><strong aria-hidden="true">11.4.</strong> Networking</a></li><li class="chapter-item expanded "><a href="ch11-05-XML.html"><strong aria-hidden="true">11.5.</strong> A Brief Introduction to XML</a></li><li class="chapter-item expanded "><a href="ch11-06-Exercises.html"><strong aria-hidden="true">11.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch11-07-Quiz.html"><strong aria-hidden="true">11.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-ThreadsandMultiprocessing.html"><strong aria-hidden="true">12.</strong> Threads and Multiprocessing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-IntroductiontoThreads.html"><strong aria-hidden="true">12.1.</strong> Introduction to Threads</a></li><li class="chapter-item expanded "><a href="ch12-02-ProgrammingwithThreads.html"><strong aria-hidden="true">12.2.</strong> Programming with Threads</a></li><li class="chapter-item expanded "><a href="ch12-03-ThreadsandParallelProcessing.html"><strong aria-hidden="true">12.3.</strong> Threads and Parallel Processing</a></li><li class="chapter-item expanded "><a href="ch12-04-ThreadsandNetworking.html"><strong aria-hidden="true">12.4.</strong> Threads and Networking</a></li><li class="chapter-item expanded "><a href="ch12-05-NetworkProgrammingExample.html"><strong aria-hidden="true">12.5.</strong> Network Programming Example</a></li><li class="chapter-item expanded "><a href="ch12-06-Exercises.html"><strong aria-hidden="true">12.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch12-07-Quiz.html"><strong aria-hidden="true">12.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-GUIProgrammingContinued.html"><strong aria-hidden="true">13.</strong> GUI Programming Continued</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-PropertiesandBindings.html"><strong aria-hidden="true">13.1.</strong> Properties and Bindings</a></li><li class="chapter-item expanded "><a href="ch13-02-FancierGraphics.html"><strong aria-hidden="true">13.2.</strong> Fancier Graphics</a></li><li class="chapter-item expanded "><a class="active" href="ch13-03-ComplexComponentsandMVC.html"><strong aria-hidden="true">13.3.</strong> Complex Components and MVC</a></li><li class="chapter-item expanded "><a href="ch13-04-MostlyWindowsandDialogs.html"><strong aria-hidden="true">13.4.</strong> Mostly Windows and Dialogs</a></li><li class="chapter-item expanded "><a href="ch13-05-FinishingTouches.html"><strong aria-hidden="true">13.5.</strong> Finishing Touches</a></li><li class="chapter-item expanded "><a href="ch13-06-Exercises.html"><strong aria-hidden="true">13.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch13-07-Quiz.html"><strong aria-hidden="true">13.7.</strong> Quiz</a></li></ol><li class="chapter-item expanded "><a href="appendix-00.html"> Appendix</a></li><li class="chapter-item expanded "><a href="glossary-00.html"> Glossary</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="Java">Java</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Introduction to Programming Using Java</h1>

                    <div class="right-buttons">

                        <a href="https://github.com/Xayarsh/Java-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Complex Components and MVC"><a class="header" href="#Complex Components and MVC">Complex Components and MVC</a></h2>
                        <p>
                            There is a lot more complexity than we have
                            seen so far lurking in the JavaFX API.  However, a lot of that
                            complexity works to your benefit as a programmer, since a lot of it is hidden in
                            typical uses of JavaFX components.  You don't have to know about the most
                            complex details of controls in order to use them effectively in most programs.</p>


                        <p>JavaFX defines several component classes that are much more complex than those
                            we have looked at, but even the most complex components are not very
                            difficult to use for many purposes.  In this section, we'll look at components
                            that support display and manipulation of lists and tables.
                            To use these complex components effectively, it's helpful to know something about
                            the Model-View-Controller pattern that is used as a basis for the design of
                            many GUI components.  That pattern is discussed later in this section.</p>


                        <p>There are a number of JavaFX controls that are not covered in this book.  Some useful
                            ones that you might want to look into include:  <span class="classname">TabbedPane</span>,
                            <span class="classname">SplitPane</span>, <span class="classname">Tree</span>, <span class="classname">ProgressBar</span>, and
                            various specialized input controls such as <span class="classname">ColorPicker</span>,
                            <span class="classname">DatePicker</span>, <span class="classname">PasswordField</span>,
                            and <span class="classname">Spinner</span>.</p>


                        <p>We start this section with a short example of writing a custom control&mdash;something
                            that you might consider when even the large variety of components that are already
                            defined in JavaFX don't do quite what you want (or when they do too much,
                            and you want something simpler).</p>

                        <h3 id="A Simple Custom Component"><a class="header" href="#A Simple Custom Component">A Simple Custom Component</a></h3>

                        <p>JavaFX's standard component classes are usually all you need to construct a user
                            interface. At some point, however, you might need something a bit different.
                            In that case, you can consider writing your own component class, by building on one of the
                            components that JavaFX does provide or on the basic <span class="classname">Control</span> class that
                            serves as the base class for all controls.</p>


                        <p>For example, suppose I have a need for a "stopwatch" control. When the
                            user clicks on the stopwatch, I want it to start timing. When the user clicks
                            again, I want it to display the elapsed time since the first click. The textual
                            display can be done with a <span class="classname">Label</span>, but we want
                            a <span class="classname">Label</span> that
                            can respond to mouse clicks. We can get this behavior by defining a
                            <span class="classname">StopWatchLabel</span> component as a subclass of the <span class="classname">Label</span> class. A
                            <span class="classname">StopWatchLabel</span> object will listen for mouse clicks on itself. The first
                            time the user clicks, it will change its display to "Timing..." and remember
                            the time when the click occurred. When the user clicks again, it will check the
                            time again, and it will compute and display the elapsed time. (Of course, I
                            don't necessarily have to define a subclass. I could use a regular label in my
                            program, set up a listener to respond to mouse events on the label, and let the
                            program do the work of keeping track of the time and changing the text displayed
                            on the label. However, by writing a new class, I have something that can be
                            <b>reused</b> in other projects. I also have all the code involved in the stopwatch
                            function collected together neatly in one place. For more complicated
                            components, both of these considerations are very important.)</p>


                        <p>The <span class="classname">StopWatchLabel</span> class is not very hard to write. I need an instance
                            variable to record the time when the user starts the stopwatch.
                            In the mouse event handling method that responds to mouse clicks on the stopwatch, I need
                            to know whether the timer is being started or stopped, so I need a <span class="ptype">boolean</span>
                            instance variable, <span class="code">running</span>, to keep track of this aspect of the component's state.
                            We can use the method <span class="code">System.currentTimeMillis()</span> to get the current time,
                            in milliseconds, as a value of type <span class="ptype">long</span>.   When the timer is started,
                            we can store the current time in an instance variable, <span class="code">startTime</span>.
                            When the timer is stopped, we can use the current time and the start time to compute
                            the elapsed time that the timer has been running.
                            The complete <span class="code">StopWatch</span> class is very short:</p>


                        <pre><code class="java">import javafx.scene.control.Label;

/**
 * A custom component that acts as a simple stop-watch.  When the user
 * clicks on it, this component starts timing.  When the user clicks again,
 * it displays the time between the two clicks.  Clicking a third time
 * starts another timer, etc.  While it is timing, the label just
 * displays the message "Timing....".
 */
public class StopWatchLabel extends Label {

    private long startTime;   // Start time of timer.
                              //   (Time is measured in milliseconds.)

    private boolean running;  // True when the timer is running.

    /**
     * Constructor sets initial text on the label to
     * "Click to start timer." and sets up a mouse event
     * handler so the label can respond to clicks.
     */
    public StopWatchLabel() {
        super("  Click to start timer.  ");
        setOnMousePressed( e -&gt; setRunning( !running ) );
    }


    /**
     * Tells whether the timer is currently running.
     */
    public boolean isRunning() {
        return running;
    }


    /**
     * Sets the timer to be running or stopped, and changes the text that
     * is shown on the label.  (This method should be called on the JavaFX
     * application thread.)
     * @param running says whether the timer should be running; if this
     *    is equal to the current state, nothing is done.
     */
    public void setRunning( boolean running ) {
        if (this.running == running)
            return;
        this.running = running;
        if (running == true) {
                // Record the time and start the timer.
            startTime = System.currentTimeMillis();
            setText("Timing....");
        }
        else {
                // Stop the timer.  Compute the elapsed time since the
                // timer was started and display it.
            long endTime = System.currentTimeMillis();
            double seconds = (endTime - startTime) / 1000.0;
            setText( String.format("Time: %1.3f seconds", seconds) );
        }
    }

} // end StopWatchLabel</code></pre>


                        <p>Don't forget that since <span class="classname">StopWatchLabel</span> is a subclass of <span class="classname">Label</span>,
                            you can do anything with a <span class="classname">StopWatchLabel</span> that you can do with a
                            <span class="classname">Label</span>. You can add it to a container. You can set its font,
                            text color, max and preferred size, and CSS style. You can set the text that it displays
                            (although this would interfere with its stopwatch function).</p>


                        <p>
                            <span class="sourceref"><a href="./source/chapter13/StopWatchLabel.java">StopWatchLabel.java</a></span>
                            is not an application and cannot be run on its own. The very short program <span class="sourceref"><a href="./source/chapter13/TestStopWatch.java">TestStopWatch.java</a></span>
                            shows a <span class="classname">StopWatchLabel</span>, and it sets several of the label's properties to
                            improve the appearance.</p>


                        <h3 id="The MVC Pattern"><a class="header" href="#The MVC Pattern">The MVC Pattern</a></h3>


                        <p>One of the principles of object-oriented design is division of responsibilities.
                            Ideally, an object should have a single, clearly defined role, with a limited
                            realm of responsibility.  One application of this principle to the design of
                            graphical user interfaces is the <span class="newword">MVC pattern</span>.  "MVC" stands
                            for "Model-View-Controller" and refers to three different realms of responsibility
                            in the design of a graphical user interface.</p>


                        <p>When the MVC pattern is applied to a component, the <span class="newword">model</span>
                            consists of the data that represents the current state of the component.
                            The <span class="newword">view</span> is simply the visual presentation of the
                            component on the screen.  And the <span class="newword">controller</span> is the
                            aspect of the component that carries out actions in response to events
                            generated by the user (or by other sources such as timers).  The idea is to assign responsibility for the
                            model, the view, and the controller to different objects.</p>


                        <p>The view is the easiest part of the MVC pattern to understand.  It is
                            often represented by the component object itself, and its responsibility
                            is to draw the component on the screen.  In doing this, of course, it
                            has to consult the model, since the model represents the state of the
                            component, and that state can determine what appears on the screen.
                            To get at the model data&mdash;which is stored in a separate object
                            according to the MVC pattern&mdash;the component object needs to keep
                            a reference to the model object. Furthermore, when the model changes,
                            the view often needs to be redrawn to reflect the changed state.
                            The component needs some way of knowing when changes in the model
                            occur.  Typically, in Java, this is done with events and listeners.  The
                            model object is set up to generate events when its data changes.
                            The view object registers itself as a listener for those events. When the model
                            changes, an event is generated, the view is notified of that event, and the
                            view responds by updating its appearance on the screen.</p>


                        <p>When MVC is
                            used for JavaFX components, the controller is generally not so well defined
                            as the model and view, and its responsibilities are often split
                            among several objects.  The controller might include mouse
                            and keyboard listeners that respond to user events on the view, as well as
                            listeners for other high-level events, such as those from a button or slider,
                            that affect the state of the component.  Usually, the controller
                            responds to events by making modifications to the model, and
                            the view is changed only indirectly, in response to the changes
                            in the model.</p>


                        <p>The MVC pattern is used in many places in the design of JavaFX,
                            even when the terms "model" and "view" are not used.  The whole
                            idea of observable properties (<a href="ch13-01-PropertiesandBindings.html">Subsection&nbsp;13.1.1</a>) is a way
                            of implementing the idea of a model that is separate from the view,
                            although when properties are used, the model can be spread over
                            many different objects.
                            For the list and table controls that we will look at
                            next, the model and view are somewhat more explicit.</p>


                        <h3 id="ListView and ComboBox"><a class="header" href="#ListView and ComboBox">ListView and ComboBox</a></h3>

                        <p>A <span class="classname">ListView</span> is a control that represents a list
                            of items that can be selected by the user.  It is also possible to let the
                            user edit items in the list.  The sample program
                            <span class="sourceref"><a href="./source/chapter13/SillyStamper.java">SillyStamper.java</a></span> allows the user to select
                            an icon (that is, a small image) in a <span class="classname">ListView</span> of icons.
                            The user selects an icon in the list by clicking on it.
                            The selected icon can be "stamped" onto a canvas by clicking on
                            the canvas. Shift-clicking adds a larger version of the image to the canvas.
                            (The icons in this program are from the KDE desktop project.)
                            Here is a picture of the program with several icons already stamped onto the
                            drawing area and with the "star" icon selected in the list:</p>


                        <p align="center">
                            <img src="./images/silly-stamper.png" width="394" height="286" alt="screenshot from SillyStamper.java"></p>


                        <p>
                            <span class="classname">ListView</span> is defined in package <span class="code">javafx.scene.control</span>. It is a parameterized
                            type, where the type parameter indicates what type of object can be displayed in the list.
                            The most common type is probably <span class="atype">ListView&lt;String&gt;</span>, but in the sample program,
                            it's <span class="atype">ListView&lt;ImageView&gt;</span>.  A <span class="classname">ListView</span>
                            can display <span class="classname">Strings</span> and <span class="classname">Nodes</span> directly.
                            When used with objects of other types, the default is to display the string representation
                            of the object, as returned by the <span class="code">toString()</span> method (which is often not very
                            useful).</p>


                        <p>The items in a <span class="atype">ListView&lt;T&gt;</span> are stored in an
                            <span class="atype">ObservableList&lt;T&gt;</span>.  The list of items is part of the model
                            for the <span class="classname">ListView</span>.  The list for a <span class="code">listView</span>
                            can be accessed as <span class="code">listView.getItems()</span>.  When items are added to
                            this list or deleted from the list, the list view is automatically updated
                            to reflect the change.</p>


                        <p>In the <span class="code">SillyStamper</span> program, the list is static.  That is, no changes
                            are made to the list after it has been created, and the user cannot edit the list.
                            The images for the icons are read from resource files, and each <span class="classname">Image</span>
                            is wrapped in an  <span class="classname">ImageView</span> (<a href="ch06-04-BasicControls.html">Subsection&nbsp;6.4.1</a>),
                            which is added to the list of items in the <span class="classname">ListView</span>.
                            The list is constructed in the following method, which is called in the program's
                            <span class="code">start()</span> method:</p>


                        <pre><code class="java">private ListView&lt;ImageView&gt; createIconList() {
    String[] iconNames = new String[] {
               // names of image resource file, in directory stamper_icons
            "icon5.png", "icon7.png", "icon8.png", "icon9.png", "icon10.png",
            "icon11.png", "icon24.png", "icon25.png", "icon26.png",
            "icon31.png", "icon33.png", "icon34.png"
    };

    iconImages = new Image[iconNames.length];  // Used for drawing the icons.

    ListView&lt;ImageView&gt; list = new ListView&lt;&gt;();

    list.setPrefWidth(80);
    list.setPrefHeight(100);

    for (int i = 0; i &lt; iconNames.length; i++) {
        Image icon = new Image("stamper_icons/" + iconNames[i]);
        iconImages[i] = icon;
        list.getItems().add( new ImageView(icon) );
    }

    list.getSelectionModel().select(0);  // Select the first item in the list.

    return list;
}</code></pre>


                        <p>This method sets a preferred width and height for the list.  The default preferred
                            size for a list seems to be about 200-by-400, no matter what it contains.  The icon
                            list needs a much smaller width.  The preferred height is set to a small value, but
                            in this program it will grow to fill the available space in the "right" position of
                            the <span class="classname">BorderPane</span> that fills the window.  The default preferred height
                            would have forced the container to be bigger than I wanted.</p>


                        <p>The other point of interest is the use of the "selection model" of the list.
                            The selection model is the part of the model that records which items are selected
                            in the list.  By default, at most one item can be selected in a list, which is
                            the correct behavior for this program.  However, it would be possible to allow multiple items to be
                            selected at the same time by calling</p>


                        <pre><code class="java">list.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);</code></pre>


                        <p>With the default single selection mode, when the user selects an item, the previously
                            selected item, if any, is deselected.  The user can select an item by clicking it,
                            and the program can set the selection by calling
                            <span class="code">list.getSelectionModel().select(index)</span>.  The parameter is the index
                            of the item in the list, with numbering starting from zero as usual.
                            If <span class="code">index</span> is -1, than no item in the list is selected.  The selected
                            item in the list is highlighted in the list view.  The list view listens for
                            changes in the selection model.  When the user clicks an item, a mouse
                            listener (which is a built-in part of the controller for the list) changes the selection model.
                            When that happens, the list view is notified of the change and
                            updates its appearance to reflect the fact that a different item is now selected.
                            A program can find out which item is currently selected by calling</p>


                        <pre><code class="java">list.getSelectionModel().getSelectedIndex()</code></pre>


                        <p>In <span class="sourceref"><a href="./source/chapter13/SillyStamper.java">SillyStamper.java</a></span>, this method is used when the
                            user clicks on the canvas, to find out which icon should be stamped
                            into the picture.</p>





                        <p>The list in <span class="code">SillyStamper.java</span> is not editable. Our second
                            sample program, <span class="sourceref"><a href="./source/chapter13/EditListDemo.java">EditListDemo.java</a></span>, shows two lists
                            that can be edited by the user.  One is a list of strings and one is a list
                            of numbers.  The user can initiate editing of an item by double-clicking it,
                            or simply by clicking it if it is already selected.  The user finishes the edit
                            by pressing return or by hitting the escape key to cancel the edit.
                            Selecting another item in the list will also cancel the edit.</p>


                        <p align="center">
                            <img src="./images/edit-list-demo.png" width="540" height="320" alt="Screenshot of EditListDemo.java"></p>


                        <p>There are a few things that you need to do if you want the user
                            to be able to edit the items in a <span class="classname">ListView</span>.
                            The <span class="code">list</span> must be made editable by calling
                        </p>


                        <pre><code class="java">list.setEditable(true);</code></pre>


                        <p>However, that by itself is not enough.  The individual cells in the list
                            must also be editable.  The term "cell" refers to an area in a list that
                            displays one item.  A list cell is an object that is responsible for
                            displaying the item and, optionally, implementing user editing of the
                            item.  Default list cells are not editable.</p>


                        <p>A <span class="classname">ListView</span> uses a <span class="newword">cell factory</span>
                            to create list cell objects.  The cell factory is another object that
                            is responsible for creating cells.  To get a different kind of cell,
                            you have to provide a different cell factory for the list.
                            (This follows something called the "factory pattern."  By using a
                            a factory object to create cells, the cells can be customized without
                            changing the <span class="classname">ListView</span> source code.  You simply
                            have to install a new cell factory.)</p>


                        <p>Writing cell factories is not a trivial task, but JavaFX has
                            several standard cell factories.  If <span class="code">listView</span> is
                            of type <span class="atype">ListView&lt;String&gt;</span>, you can install
                            a cell factory that makes editable cells simply by calling</p>


                        <pre><code class="java">listView.setCellFactory( TextFieldListCell.forListView() );</code></pre>


                        <p>The method <span class="code">TextFieldListCell.forListView()</span> returns
                            a cell factory that creates cells that can display and edit strings.
                            When the cell is simply displaying the string, it actually uses
                            a <span class="classname">Label</span> for the display.  When the item
                            is being edited, it is displayed as a <span class="classname">TextField</span>.</p>


                        <p>That's all you need to know to make an editable list of strings.
                            There are other item types for which it is natural to display the
                            item as a string and to use a <span class="classname">TextField</span> for
                            editing the item.  That includes numbers, single character values,
                            dates, and times.  However, when the items are not strings, there
                            has to be some way to convert between items and their string
                            representations.  Again, JavaFX makes things reasonably easy in
                            the common cases: It provides standard converters for all of the
                            types mentioned above.  For example, if <span class="code">intList</span>
                            is an editable <span class="atype">ListType&lt;Integer&gt;</span>, you can
                            install an appropriate cell factory with</p>


                        <pre><code class="java">intView.setCellFactory(
           TextFieldListCell.forListView( new IntegerStringConverter() ) );</code></pre>


                        <p>The parameter to <span class="code">forListView</span> is an object that can convert
                            between integers and their string representations.  As it happens I was not
                            completely satisfied with the standard converter, since it didn't handle
                            illegal inputs in the text field very well, so for the list of integers in
                            the sample program <span class="sourceref"><a href="./source/chapter13/EditListDemo.java">EditListDemo.java</a></span>, I wrote my own
                            converter and used it create the cell factory for the list:</p>


                        <pre><code class="java">StringConverter&lt;Integer&gt; myConverter = new StringConverter&lt;Integer&gt;() {
        // This custom string converter will convert a bad input string to
        // null, instead of just failing.  And it will display a null value
        // as "Bad Value" and an empty string value as 0.

    public Integer fromString(String s) {
            // Convert a string to an integer.
        if (s == null || s.trim().length() == 0)
            return 0;
        try {
            return Integer.parseInt(s);
        }
        catch (NumberFormatException e) {
            return null;
        }
    }

    public String toString(Integer n) {
            // Convert an integer to a String.
        if (n == null)
            return "Bad Value";
        return n.toString();
    }
};

listView.setCellFactory( TextFieldListCell.forListView( myConverter ) );</code></pre>


                        <p>As you can see, a <span class="classname">StringConverter</span> just needs
                            to  define two functions, <span class="code">fromString()</span> and <span class="code">toString()</span>.</p>


                        <p>Standard string converters can be found in package <span class="code">javafx.util.converters</span>, and
                            the factory class <span class="code">TextFieldListCell</span> is in package <span class="code">javafx.scene.control.cell</span>.
                            There are also similar classes for use with cells in tables, which we will need below.</p>





                        <p>In addition to the lists themselves in the sample program, a few interesting things are
                            done with labels and buttons, by using observable properties of the <span class="classname">ListView's</span> model,
                            as discussed in <a href="ch13-01-PropertiesandBindings.html">Subsection&nbsp;13.1.2</a>.
                            For example, there are labels that show the selected index and the selected item in the list.
                            This is coded by binding the text property of the label with a property of the
                            list's selection model:</p>


                        <pre><code class="java">Label selectedIndexLabel = new Label();
selectedIndexLabel.textProperty().bind(
                    listView.getSelectionModel()
                            .selectedIndexProperty()
                            .asString("Selected Index: %d") );

Label selectedNumberLabel = new Label();
selectedNumberLabel.textProperty().bind(
                    listView.getSelectionModel()
                            .selectedItemProperty()
                            .asString("SelectedItem: %s") );</code></pre>


                        <p>And the button for deleting the selected item from the list should be enabled
                            only when there is actually a selected item.  This is coded by binding the
                            disable property of the button:</p>


                        <pre><code class="java">deleteNumberButton.disableProperty().bind(
                    listView.getSelectionModel()
                            .selectedIndexProperty()
                            .isEqualTo(-1) );</code></pre>


                        <p>In effect, the labels and button are being used as alternative views of the
                            same selection model that is used by the list.  This is a major feature of the
                            MVC pattern:  There can be multiple views of the same model object.  The views listen
                            for changes in the model.  When the model changes, the views are notified of
                            the change and update themselves to reflect the new state of the model.</p>


                        <p>There is also an "Add" button that adds an item to the list.  This uses another
                            part of the <span class="classname">ListView</span> model.  The item is actually added
                            to the <span class="classname">ObservableList</span> that holds the items.  Since the
                            <span class="classname">ListView</span> listens for changes in that list, it will be notified of the change and
                            will update itself to show the new item in the visible on-screen view of the list.
                            Beyond adding the item to the observable list, no other action is needed in the program
                            to get the item to appear on the screen.</p>





                        <p>We can look briefly at another control, <span class="classname">ComboBox</span>,
                            that bears a lot of similarities to <span class="classname">ListView</span>.  In fact,
                            a <span class="classname">ComboBox</span> is basically a list view in which only the
                            selected item is normally visible.  When the user clicks on a combo box, the
                            full list of items pops up, and the user can select an item from the list.
                            In fact, a <span class="classname">ComboBox</span> actually uses a <span class="classname">ListView</span>
                            to show the items in the pop-up list.
                            You have seen combo boxes used as pop-up menus in some examples, starting
                            with <span class="sourceref"><a href="./source/chapter1/GUIDemo.java">GUIDemo.java</a></span> all the way back in
                            <a href="ch01-06-ModernUserInterface.html">Section&nbsp;1.6</a>.  Like <span class="classname">ListView</span>, <span class="classname">ComboBox</span>
                            is a parameterized type.  Although other item types are supported
                            (using cell factories and string converters), <span class="classname">String</span>
                            is the most common type for the items.  Creating a combo box and managing
                            the selection is similar to working with <span class="classname">ListView</span>.
                            For example,</p>


                        <pre><code class="java">ComboBox&lt;String&gt; flavors = new ComboBox&lt;&gt;();
flavors.getItems().addAll("Vanilla", "Chocolate", "Strawberry", "Pistachio");
flavors.getSelectionModel().select(0);</code></pre>


                        <p>It is possible to set a combo box to be editable (and no special cell factory
                            is needed for that, as long as the items are strings).  An editable combo
                            box is like a strange combination of text field and list view.  Instead of
                            using a label to show the selected item, the combo box uses a text field.
                            The user can edit the value in the text field, and the modified value becomes
                            the selected value in the combo box.  However, the original value of the modified item
                            is not removed from the list; the new item is just added.  And the new
                            item does not become a permanent part of the list.  In the above
                            example, the effect of saying <span class="code">flavors.setEditable(true)</span>
                            is to let the user type in "Rum Raisin," or anything else, as the selected
                            flavor, but doing so won't replace "Vanilla", "Chocolate", "Strawberry",
                            or "Pistachio" in the list.</p>


                        <p>Unlike a <span class="classname">ListView</span>, a <span class="classname">ComboBox</span> emits
                            an <span class="classname">ActionEvent</span> when the user selects a new item, either
                            by selecting it from the pop-up menu or by typing a new value into an
                            editable combo box and pressing return.</p>


                        <h3 id="TableView"><a class="header" href="#TableView">TableView</a></h3>


                        <p>Like a <span class="classname">ListView</span>, a <span class="classname">TableView</span> control displays
                            a collection of items to the user.  However, tables are more complicated
                            than lists.  Table items are arranged in a grid
                            of rows and columns.  Each grid position is a cell of
                            the table.  Each column has a column header at the top, which
                            contains a name for the column.  A column contains a sequence of items,
                            and working with one of the columns
                            in a <span class="classname">TableView</span> is in many ways similar to
                            working with a <span class="classname">ListView</span>.</p>


                        <p>
                            <span class="atype">TableView&lt;T&gt;</span> is a parameterized type.  The type <span class="classname">T</span>
                            represents one row of the table; that is, an object of the
                            type parameter, <span class="classname">T</span>, contains the data for one
                            row.  (It can contain additional data as well; the table can be
                            a view of just some of the available data.)  The data model for a <span class="code">table</span>
                            of type <span class="atype">TableView&lt;T&gt;</span> is an <span class="atype">ObservableList&lt;T&gt;</span>,
                            and it can be accessed as <span class="code">table.getItems()</span>. Each item represents one row,
                            and you can add and delete complete rows
                            of the table by adding and deleting elements of this list.</p>


                        <p>To define a table, it's not enough to provide the class that represents the
                            rows of the table; you also have to say what data goes in each column of the
                            table.  A table column is described by an object of type <span class="atype">TableColumn&lt;T,S&gt;</span>,
                            where the first type parameter, <span class="classname">T</span>, is the same as the type
                            parameter of the table, and the second type parameter, <span class="classname">S</span>,
                            is the data type for the items that appear in the cells of that column.  The type
                            <span class="atype">TableColumn&lt;T,S&gt;</span> indicates that the column displays items of
                            type <span class="classname">S</span> derived from rows of type&nbsp;<span class="classname">T</span>. A table
                            column object does not contain the items that appear in the column; they are contained
                            in the objects of type <span class="classname">T</span> that represent the rows.
                            But the table column object needs to specify how to <b>get</b> the item that appears
                            in the column from the object that represents the row.  That is specified
                            by something called a "cell value factory."  It is possible to write a cell value factory that
                            computes any function of a row object, but the most common option is to use
                            a <span class="classname">PropertyValueFactory</span> that simply picks out one of the
                            properties of the row object.</p>


                        <p>Let's turn to an example.  The sample program <span class="sourceref"><a href="./source/chapter13/SimpleTableDemo.java">SimpleTableDemo.java</a></span>
                            shows an uneditable table that contains the fifty states of the United States with their capital cities
                            and population:</p>


                        <p align="center">
                            <img src="./images/table-demo.png" width="354" height="161" alt="an example TableView"></p>


                        <p>The data for the rows of the table are in objects of type <span class="classname">StateData</span>,
                            which is defined in the program as a public static nested class.  (The class must be public for
                            use with a <span class="classname">PropertyValueFactory</span>; it does not need to be static or nested.)
                            The data values for a row are properties of the class, in the sense that there is a
                            getter method for each value.  Properties defined by getter methods are sufficient for
                            uneditable table values (though as we shall see, you need something different for editable table columns).
                            Here is the class definition:</p>


                        <pre><code class="java">public static class StateData {
    private String state;
    private String capital;
    private int population;
    public String getState() {
        return state;
    }
    public String getCapital() {
        return capital;
    }
    public int getPopulation() {
        return population;
    }
    public StateData(String s, String c, int p) {
        state = s;
        capital = c;
        population = p;
    }
}</code></pre>


                        <p>The table that displays the state data is created with</p>


                        <pre><code class="java">TableView&lt;StateData&gt; table = new TableView&lt;&gt;();</code></pre>


                        <p>and an item for each of the fifty states is added to the table data model, which is stored in <span class="code">table.getItems()</span>.
                            Then the table column objects are created and configured and added to the table column model, which is stored in
                            <span class="code">table.getColumns()</span>:</p>


                        <pre><code class="java">TableColumn&lt;StateData, String&gt; stateCol = new TableColumn&lt;&gt;("State");
stateCol.setCellValueFactory(
                new PropertyValueFactory&lt;StateData, String&gt;("state") );
table.getColumns().add(stateCol);

TableColumn&lt;StateData, String&gt; capitalCol = new TableColumn&lt;&gt;("Capital City");
capitalCol.setCellValueFactory(
                  new PropertyValueFactory&lt;StateData, String&gt;("capital") );
table.getColumns().add(capitalCol);

TableColumn&lt;StateData, Integer&gt; populationCol = new TableColumn&lt;&gt;("Population");
populationCol.setCellValueFactory(
                 new PropertyValueFactory&lt;StateData, Integer&gt;("population") );
table.getColumns().add(populationCol);</code></pre>


                        <p>The parameter to the <span class="classname">TableColumn</span> constructor is the
                            text that appears in the header at the top of the column.  As for the cell value
                            factories, remember that a cell value factory needs to pull the value for a cell
                            out of a row object of type <span class="classname">StateData</span>.
                            For the first column, the type of data is <span class="classname">String</span>,
                            so the property value factory takes an
                            input of type <span class="classname">StateData</span> and outputs a property value
                            of a type <span class="classname">String</span>.  The output value is the property
                            named "state" in the <span class="classname">StateData</span> object.  More simply,
                            the constructor</p>


                        <pre><code class="java">new PropertyValueFactory&lt;StateData, String&gt;("state")</code></pre>


                        <p>creates a cell value factory that gets the value to be displayed in a
                            cell by calling <span class="code">obj.getState()</span>, where <span class="code">obj</span> is the
                            object that represents the row of the table which contains the cell.
                            The other two columns are specified similarly.</p>


                        <p>That's about all you need to know to create a table in which the user cannot
                            edit the contents of the cells.  By default, the user will be able to
                            change the column width by dragging a separator between two column
                            headers.  And the user can click a column header to sort the rows of the
                            table into increasing or decreasing order according to the values in
                            that column.  Both capabilities can be turned off by setting properties
                            of the <span class="classname">TableColumn</span> object, as we will do for the
                            next example.  The user can also rearrange the columns by dragging a
                            table header to the left or right.</p>





                        <p>The sample program <span class="sourceref"><a href="./source/chapter13/ScatterPlotTableDemo.java">ScatterPlotTableDemo.java</a></span> includes
                            an example of a user-editable table.  Each row in the table represents a point
                            in the plane, and the two columns contain the x-coordinates and the y-coordinates
                            of the points.  To add some interest, the program also shows the points on
                            a canvas; the canvas is a "scatter plot" with a small crosshair at the location
                            of each point.  In the picture, one of the x-coordinates is being edited:</p>


                        <p align="center">
                            <img src="./images/scatter-plot.png" width="500" height="320" alt="editable list of points, with scatter plot"></p>


                        <p>We need a data type to represent the rows of the table.  It can be a simple
                            class, with two properties <span class="code">x</span> and <span class="code">y</span> that hold the
                            coordinates of a point.  However, for an editable table column, we can't use
                            simple properties defined by getters and setters.  The problem is that
                            an editable column expects the property for that column to be an
                            <i>observable property</i> (see <a href="ch13-01-PropertiesandBindings.html">Section&nbsp;13.1</a>).
                            More exactly, the class should follow the JavaFX pattern for observable properties:
                            The values for the properties named <span class="code">x</span> and <span class="code">y</span> should be stored in
                            observable property objects, and a point object, <span class="code">pt</span>, should have
                            instance methods <span class="code">pt.xProperty()</span> and <span class="code">pt.yProperty()</span>.  These methods
                            return the observable property objects so that they can be used to get and set
                            the property value.  Since the properties store <span class="ptype">double</span>
                            values, they can be of type <span class="classname">DoubleProperty</span>.
                            The data class for the table is defined as:</p>


                        <pre><code class="java">public static class Point {
    private DoubleProperty x, y;
    public Point(double xVal, double yVal) {
        x = new SimpleDoubleProperty(this,"x",xVal);
        y = new SimpleDoubleProperty(this,"y",yVal);
    }
    public DoubleProperty xProperty() {
        return x;
    }
    public DoubleProperty yProperty() {
        return y;
    }
}</code></pre>


                        <p>The class <span class="classname">DoubleProperty</span> itself is an abstract class.
                            <span class="classname">SimpleDoubleProperty</span> is concrete subclass. whose
                            constructor requires the object that contains the property, the name of the
                            property, and the initial value of the property.  Support for adding
                            change and invalidation listeners to the property is already implemented
                            in this class.</p>


                        <p>With the <span class="classname">Point</span> class in hand, we can create the table
                            and add a few random points to it:</p>


                        <pre><code class="java">table = new TableView&lt;Point&gt;();
points = table.getItems();

for (int i = 0; i &lt; 5; i++) { // add 5 random points to the table
    points.add( new Point(5*Math.random(), 5*Math.random()) );
}</code></pre>


                        <p>When a point is added to or deleted from the table, the canvas has
                            to be redrawn.  To implement that, we can add a listener to the list, <span class="code">points</span>,
                            that serves as the data model for the table:</p>


                        <pre><code class="java">points.addListener( (Observable e) -&gt; redrawDisplay() );</code></pre>


                        <p>(The type for the parameter, <span class="code">e</span>, in the lambda expression is
                            given as <span class="classname">Observable</span> because an observable list
                            has two <span class="code">addListener()</span> methods that require a one-parameter
                            lamda expression.  The explicit type for <span class="code">e</span> makes it possible
                            for the compiler to tell which one is meant here: We are adding
                            an <span class="classname">InvalidationListener</span> rather than a
                            <span class="classname">ListChangeListener</span>.)</p>


                        <p>We have arranged for the canvas to be redrawn whenever a point is
                            added to or deleted from the table.  However, it will not be redrawn
                            when the user edits one of the points in the table.  That is not a change
                            in the list structure; it's a change inside one of the objects in the list.
                            To respond to such changes, we could add listeners to both of the
                            observable properties in each <span class="classname">Point</span> object.
                            In fact, that's what the table does so that it can respond to any changes
                            in a point that might be made from outside the table. Since that seems a little extreme to
                            me, the program actually listens for a different kind of event to handle cell edits.
                            A table has an observable property named
                            <span class="code">editingCell</span> whose value is the cell that is currently being
                            edited, if any, or is <span class="code">null</span> if no cell is being edited.
                            When the value of this property changes to <span class="code">null</span>, it
                            means that an editing operation has been completed.  We can arrange for
                            the canvas to be redrawn after every editing operation by adding a
                            change listener to the <span class="code">editingCell</span> property:</p>


                        <pre><code class="java">table.editingCellProperty().addListener( (o,oldVal,newVal) -&gt; {
    if (newVal == null) {
        redrawDisplay();
    }
});</code></pre>


                        <p>To complete the definition of the table, we have to define the columns.
                            As in any table, we need a cell value factory for each column, which can
                            be created using a property value factory; this follows the same pattern
                            as the previous example.  But for an editable column, we also need a
                            cell factory, just as we did for the editable list example above.
                            Similarly to that example, the cell factory can be created using</p>


                        <pre><code class="java">TextFieldTableCell.forTableColumn(myConverter)</code></pre>


                        <p>where <span class="code">myConverter</span> is a <span class="atype">StringConverter&lt;Double&gt;</span>.
                            Furthermore, for this program, it makes sense to stop the user
                            from resizing the columns or sorting them.  Here is the complete
                            code for setting up one of the columns:</p>


                        <pre><code class="java">TableColumn&lt;Point, Double&gt; xColumn = new TableColumn&lt;&gt;("X Coord");
xColumn.setCellValueFactory( new PropertyValueFactory&lt;Point, Double&gt;("x") );
xColumn.setCellFactory( TextFieldTableCell.forTableColumn(myConverter) );
xColumn.setSortable(false);
xColumn.setResizable(false);
xColumn.setPrefWidth(100);  // (Default size is too small)
table.getColumns().add(xColumn);</code></pre>


                        <p>The only other thing that is needed to make the table work is to set it
                            to be editable by calling <span class="code">table.setEditable(true)</span>.
                            As you can see, you need to do quite a lot to make a table work, especially
                            if it's an editable table.  However, tables are complex, and the code that
                            JavaFX makes you write to set up a table is much less than you would need to
                            implement a table directly.</p>


                        <p>By the way, you should pay attention to the way that we have exploited
                            the MVC pattern in this program.  The scatter plot is an alternative view
                            of the same data model that is shown in the table.  The data from the model
                            is used when the canvas is redrawn, and that happens in response to events
                            generated by changes in the model. It actually takes surprisingly <i>little</i>
                            thought and work to make sure that the scatter plot is always a correct view of
                            the data.</p>


                        <p>I urge you to study the <span class="sourceref"><a href="./source/chapter13/ScatterPlotTableDemo.java">source code</a></span>,
                            which is well-commented.  In addition to seeing the full details of the
                            <span class="classname">TableView</span>, you might be interested in looking at how
                            transforms (<a href="ch13-02-FancierGraphics.html">Subsection&nbsp;13.2.3</a>) are used when drawing the scatter plot.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch13-02-FancierGraphics.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch13-04-MostlyWindowsandDialogs.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch13-02-FancierGraphics.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch13-04-MostlyWindowsandDialogs.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </body>
</html>
