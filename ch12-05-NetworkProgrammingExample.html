<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Network Programming Example:A Networked Game Framework - Introduction to Programming Using Java</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

<link rel="stylesheet" href="code-class.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html" >Introduction to Programming Using Java</a></li><li class="chapter-item expanded affix "><a href="preface.html">Preface</a></li><li class="chapter-item expanded "><a href="ch01-00-Overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-FetchExecuteCycle.html"><strong aria-hidden="true">1.1.</strong> Fetch and Execute Cycle</a></li><li class="chapter-item expanded "><a href="ch01-02-AsynchronousEvents.html"><strong aria-hidden="true">1.2.</strong> Asynchronous Events</a></li><li class="chapter-item expanded "><a href="ch01-03-JavaVirtualMachine.html"><strong aria-hidden="true">1.3.</strong> The Java Virtual Machine</a></li><li class="chapter-item expanded "><a href="ch01-04-FundamentalBuildingBlocks.html"><strong aria-hidden="true">1.4.</strong> Fundamentals</a></li><li class="chapter-item expanded "><a href="ch01-05-OOP.html"><strong aria-hidden="true">1.5.</strong> Object Oriented Programming</a></li><li class="chapter-item expanded "><a href="ch01-06-ModernUserInterface.html"><strong aria-hidden="true">1.6.</strong> Modern User Interface</a></li><li class="chapter-item expanded "><a href="ch01-07-InternetAndBeyond.html"><strong aria-hidden="true">1.7.</strong> Internet and Beyond</a></li><li class="chapter-item expanded "><a href="ch01-08-Quiz.html"><strong aria-hidden="true">1.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-NameAndThings.html"><strong aria-hidden="true">2.</strong> Name and Things</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-BasicJavaApplication.html"><strong aria-hidden="true">2.1.</strong> Basic Java Application</a></li><li class="chapter-item expanded "><a href="ch02-02-VariablesAndTypes.html"><strong aria-hidden="true">2.2.</strong> Variables and Types</a></li><li class="chapter-item expanded "><a href="ch02-03-ObjectsAndSubroutines.html"><strong aria-hidden="true">2.3.</strong> Objects and Subroutines</a></li><li class="chapter-item expanded "><a href="ch02-04-TextInputAndOutput.html"><strong aria-hidden="true">2.4.</strong> Text Input and Output</a></li><li class="chapter-item expanded "><a href="ch02-05-DetailsOfExpressions.html"><strong aria-hidden="true">2.5.</strong> Details of Expressions</a></li><li class="chapter-item expanded "><a href="ch02-06-ProgrammingEnvironments.html"><strong aria-hidden="true">2.6.</strong> Programming and Environments</a></li><li class="chapter-item expanded "><a href="ch02-07-Exercises.html"><strong aria-hidden="true">2.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch02-08-Quiz.html"><strong aria-hidden="true">2.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-Control.html"><strong aria-hidden="true">3.</strong> Control</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-BlocksLoopsBranches.html"><strong aria-hidden="true">3.1.</strong> Blocks, Loops and Branches</a></li><li class="chapter-item expanded "><a href="ch03-02-AlgorithmDevelopment.html"><strong aria-hidden="true">3.2.</strong> Algorithm Development</a></li><li class="chapter-item expanded "><a href="ch03-03-While.html"><strong aria-hidden="true">3.3.</strong> while and do...while</a></li><li class="chapter-item expanded "><a href="ch03-04-For.html"><strong aria-hidden="true">3.4.</strong> The for statement</a></li><li class="chapter-item expanded "><a href="ch03-05-If.html"><strong aria-hidden="true">3.5.</strong> The If Statement</a></li><li class="chapter-item expanded "><a href="ch03-06-Switch.html"><strong aria-hidden="true">3.6.</strong> The Switch Statement</a></li><li class="chapter-item expanded "><a href="ch03-07-ExceptionsTryCatch.html"><strong aria-hidden="true">3.7.</strong> Exceptions and try...catch</a></li><li class="chapter-item expanded "><a href="ch03-08-Arrays.html"><strong aria-hidden="true">3.8.</strong> Arrays: An Introduction</a></li><li class="chapter-item expanded "><a href="ch03-09-GUI.html"><strong aria-hidden="true">3.9.</strong> GUI: An Introduction</a></li><li class="chapter-item expanded "><a href="ch03-10-Exercises.html"><strong aria-hidden="true">3.10.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch03-11-Quiz.html"><strong aria-hidden="true">3.11.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-Subroutines.html"><strong aria-hidden="true">4.</strong> Subroutines</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-BlackBoxes.html"><strong aria-hidden="true">4.1.</strong> Black Boxes</a></li><li class="chapter-item expanded "><a href="ch04-02-StaticSubroutines.html"><strong aria-hidden="true">4.2.</strong> Static Subroutines and Variables</a></li><li class="chapter-item expanded "><a href="ch04-03-Parameters.html"><strong aria-hidden="true">4.3.</strong> Parameters</a></li><li class="chapter-item expanded "><a href="ch04-04-ReturnValues.html"><strong aria-hidden="true">4.4.</strong> Return Values</a></li><li class="chapter-item expanded "><a href="ch04-05-Lambda.html"><strong aria-hidden="true">4.5.</strong> Lambda Expressions</a></li><li class="chapter-item expanded "><a href="ch04-06-APIPackagesModulesJavadoc.html"><strong aria-hidden="true">4.6.</strong> API, Packages, Modules and Javadoc</a></li><li class="chapter-item expanded "><a href="ch04-07-MoreOnProgramDesign.html"><strong aria-hidden="true">4.7.</strong> More on Program Design</a></li><li class="chapter-item expanded "><a href="ch04-08-TruthAboutDeclarations.html"><strong aria-hidden="true">4.8.</strong> Truth about Declarations</a></li><li class="chapter-item expanded "><a href="ch04-09-Exercises.html"><strong aria-hidden="true">4.9.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch04-10-Quiz.html"><strong aria-hidden="true">4.10.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-ObjectsClasses.html"><strong aria-hidden="true">5.</strong> Objects and Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-ObjectsAndInstanceMethods.html"><strong aria-hidden="true">5.1.</strong> Objects and Instance Methods</a></li><li class="chapter-item expanded "><a href="ch05-02-ConstructorObjectInit.html"><strong aria-hidden="true">5.2.</strong> Constructor and Object Initialization</a></li><li class="chapter-item expanded "><a href="ch05-03-ProgrammingWithObjects.html"><strong aria-hidden="true">5.3.</strong> Programming with Objects</a></li><li class="chapter-item expanded "><a href="ch05-04-AnExample.html"><strong aria-hidden="true">5.4.</strong> An Example</a></li><li class="chapter-item expanded "><a href="ch05-05-InheritanceAndPolymorphism.html"><strong aria-hidden="true">5.5.</strong> Inheritance and Polymorphism</a></li><li class="chapter-item expanded "><a href="ch05-06-thisandsuper.html"><strong aria-hidden="true">5.6.</strong> this and super</a></li><li class="chapter-item expanded "><a href="ch05-07-Interfaces.html"><strong aria-hidden="true">5.7.</strong> Interfaces</a></li><li class="chapter-item expanded "><a href="ch05-08-NestedClasses.html"><strong aria-hidden="true">5.8.</strong> Nested Classes</a></li><li class="chapter-item expanded "><a href="ch05-09-Exercises.html"><strong aria-hidden="true">5.9.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch05-10-Quiz.html"><strong aria-hidden="true">5.10.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-GUIProgramming.html"><strong aria-hidden="true">6.</strong> Introduction to GUI Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-BasicJavaFXApp.html"><strong aria-hidden="true">6.1.</strong> A Basic JavaFX Application</a></li><li class="chapter-item expanded "><a href="ch06-02-BasicClasses.html"><strong aria-hidden="true">6.2.</strong> Basic Classes</a></li><li class="chapter-item expanded "><a href="ch06-03-BasicEvents.html"><strong aria-hidden="true">6.3.</strong> Basic Events</a></li><li class="chapter-item expanded "><a href="ch06-04-BasicControls.html"><strong aria-hidden="true">6.4.</strong> Basic Controls</a></li><li class="chapter-item expanded "><a href="ch06-05-BasicLayout.html"><strong aria-hidden="true">6.5.</strong> Basic Layout</a></li><li class="chapter-item expanded "><a href="ch06-06-CompetePrograms.html"><strong aria-hidden="true">6.6.</strong> Complete Programs</a></li><li class="chapter-item expanded "><a href="ch06-07-Exercises.html"><strong aria-hidden="true">6.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch06-08-Quiz.html"><strong aria-hidden="true">6.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-ArraysArraylistsRecords.html"><strong aria-hidden="true">7.</strong> Arrays, ArrayLists and Records</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-ArrayDetails.html"><strong aria-hidden="true">7.1.</strong> Array Details</a></li><li class="chapter-item expanded "><a href="ch07-02-ArrayProcessing.html"><strong aria-hidden="true">7.2.</strong> Array Processing</a></li><li class="chapter-item expanded "><a href="ch07-03-ArrayLists.html"><strong aria-hidden="true">7.3.</strong> ArrayLists</a></li><li class="chapter-item expanded "><a href="ch07-04-Records.html"><strong aria-hidden="true">7.4.</strong> Records</a></li><li class="chapter-item expanded "><a href="ch07-05-SearchingAndSorting.html"><strong aria-hidden="true">7.5.</strong> Searching and Sorting</a></li><li class="chapter-item expanded "><a href="ch07-06-2DArrays.html"><strong aria-hidden="true">7.6.</strong> 2D Arrays</a></li><li class="chapter-item expanded "><a href="ch07-07-Exercises.html"><strong aria-hidden="true">7.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch07-08-Quiz.html"><strong aria-hidden="true">7.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-CorrectnessRobustnessEfficiency.html"><strong aria-hidden="true">8.</strong> Correctness, Robustness, Efficiency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-IntroductionCorrectnessandRobustness.html"><strong aria-hidden="true">8.1.</strong> Introduction to Correctness and Robustness</a></li><li class="chapter-item expanded "><a href="ch08-02-WritingCorrectPrograms.html"><strong aria-hidden="true">8.2.</strong> Writing Correct Programs</a></li><li class="chapter-item expanded "><a href="ch08-03-ExceptionsAndtrycatch.html"><strong aria-hidden="true">8.3.</strong> Exceptions and try..catch</a></li><li class="chapter-item expanded "><a href="ch08-04-AssertionsAnnotations.html"><strong aria-hidden="true">8.4.</strong> Assertions and Annotations</a></li><li class="chapter-item expanded "><a href="ch08-05-AnalysisofAlgorithms.html"><strong aria-hidden="true">8.5.</strong> Analysis of Algorithms</a></li><li class="chapter-item expanded "><a href="ch08-06-Exercises.html"><strong aria-hidden="true">8.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch08-07-Quiz.html"><strong aria-hidden="true">8.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-LinkedDataStructuresRecursion.html"><strong aria-hidden="true">9.</strong> Linked Data Structures and Recursion</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-Recursion.html"><strong aria-hidden="true">9.1.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="ch09-02-LinkedDataStructures.html"><strong aria-hidden="true">9.2.</strong> Linked Data Structures</a></li><li class="chapter-item expanded "><a href="ch09-03-StacksQueuesADTs.html"><strong aria-hidden="true">9.3.</strong> Stacks, Queues and ADTs</a></li><li class="chapter-item expanded "><a href="ch09-04-BinaryTrees.html"><strong aria-hidden="true">9.4.</strong> Binary Trees</a></li><li class="chapter-item expanded "><a href="ch09-05-SimpleRecursiveDescentParser.html"><strong aria-hidden="true">9.5.</strong> A Simple Recursive Descent Parser</a></li><li class="chapter-item expanded "><a href="ch09-06-Exercises.html"><strong aria-hidden="true">9.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch09-07-Quiz.html"><strong aria-hidden="true">9.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-GenericProgrammingandCollectionClasses.html"><strong aria-hidden="true">10.</strong> Generic Programmingand Collection Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-GenericProgramming.html"><strong aria-hidden="true">10.1.</strong> Generic Programming</a></li><li class="chapter-item expanded "><a href="ch10-02-ListsandSets.html"><strong aria-hidden="true">10.2.</strong> Lists and Sets</a></li><li class="chapter-item expanded "><a href="ch10-03-Maps.html"><strong aria-hidden="true">10.3.</strong> Maps</a></li><li class="chapter-item expanded "><a href="ch10-04-JCF.html"><strong aria-hidden="true">10.4.</strong> Programming with the JCF</a></li><li class="chapter-item expanded "><a href="ch10-05-WritingGenericClassesandMethods.html"><strong aria-hidden="true">10.5.</strong> Writing Generic Classes and Methods</a></li><li class="chapter-item expanded "><a href="ch10-06-StreamAPI.html"><strong aria-hidden="true">10.6.</strong> Stream APIs</a></li><li class="chapter-item expanded "><a href="ch10-07-Exercises.html"><strong aria-hidden="true">10.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch10-08-Quiz.html"><strong aria-hidden="true">10.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-IOStreamsFilesNetworking.html"><strong aria-hidden="true">11.</strong> I/O Streams, Files, and Networking</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-IOStreamsReadersAndWriters.html"><strong aria-hidden="true">11.1.</strong> I/O Streams, Readers, and Writers</a></li><li class="chapter-item expanded "><a href="ch11-02-Files.html"><strong aria-hidden="true">11.2.</strong> Files</a></li><li class="chapter-item expanded "><a href="ch11-03-ProgrammingWithFiles.html"><strong aria-hidden="true">11.3.</strong> Programming With Files</a></li><li class="chapter-item expanded "><a href="ch11-04-Networking.html"><strong aria-hidden="true">11.4.</strong> Networking</a></li><li class="chapter-item expanded "><a href="ch11-05-XML.html"><strong aria-hidden="true">11.5.</strong> A Brief Introduction to XML</a></li><li class="chapter-item expanded "><a href="ch11-06-Exercises.html"><strong aria-hidden="true">11.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch11-07-Quiz.html"><strong aria-hidden="true">11.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-ThreadsandMultiprocessing.html"><strong aria-hidden="true">12.</strong> Threads and Multiprocessing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-IntroductiontoThreads.html"><strong aria-hidden="true">12.1.</strong> Introduction to Threads</a></li><li class="chapter-item expanded "><a href="ch12-02-ProgrammingwithThreads.html"><strong aria-hidden="true">12.2.</strong> Programming with Threads</a></li><li class="chapter-item expanded "><a href="ch12-03-ThreadsandParallelProcessing.html"><strong aria-hidden="true">12.3.</strong> Threads and Parallel Processing</a></li><li class="chapter-item expanded "><a href="ch12-04-ThreadsandNetworking.html"><strong aria-hidden="true">12.4.</strong> Threads and Networking</a></li><li class="chapter-item expanded "><a class="active" href="ch12-05-NetworkProgrammingExample.html"><strong aria-hidden="true">12.5.</strong> Network Programming Example</a></li><li class="chapter-item expanded "><a href="ch12-06-Exercises.html"><strong aria-hidden="true">12.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch12-07-Quiz.html"><strong aria-hidden="true">12.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-GUIProgrammingContinued.html"><strong aria-hidden="true">13.</strong> GUI Programming Continued</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-PropertiesandBindings.html"><strong aria-hidden="true">13.1.</strong> Properties and Bindings</a></li><li class="chapter-item expanded "><a href="ch13-02-FancierGraphics.html"><strong aria-hidden="true">13.2.</strong> Fancier Graphics</a></li><li class="chapter-item expanded "><a href="ch13-03-ComplexComponentsandMVC.html"><strong aria-hidden="true">13.3.</strong> Complex Components and MVC</a></li><li class="chapter-item expanded "><a href="ch13-04-MostlyWindowsandDialogs.html"><strong aria-hidden="true">13.4.</strong> Mostly Windows and Dialogs</a></li><li class="chapter-item expanded "><a href="ch13-05-FinishingTouches.html"><strong aria-hidden="true">13.5.</strong> Finishing Touches</a></li><li class="chapter-item expanded "><a href="ch13-06-Exercises.html"><strong aria-hidden="true">13.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch13-07-Quiz.html"><strong aria-hidden="true">13.7.</strong> Quiz</a></li></ol><li class="chapter-item expanded "><a href="appendix-00.html"> Appendix</a></li><li class="chapter-item expanded "><a href="glossary-00.html"> Glossary</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="Java">Java</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Introduction to Programming Using Java</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Xayarsh/Java-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Network Programming Example A Networked Game Framework"><a class="header" href="#Network Programming Example A Networked Game Framework">Network Programming Example:A Networked Game Framework</a></h2>
                        <p>
                            This section presents several programs that use
                            networking and threads.  The common problem in each application is to support
                            network communication between several programs running on different computers.
                            A typical example of such an application is a networked game with two or
                            more players, but the same problem can come up in less frivolous applications
                            as well.  The first part of this section describes a framework that
                            can be used for a variety of such applications, and the rest of the section
                            discusses three specific applications that use that framework.  This is
                            a fairly complex example, probably the most complex
                            in this book.  Understanding it is not essential for a basic understanding
                            of networking.</p>


                        <p>This section was inspired by a pair of students, Alexander Kittelberger and
                            Kieran Koehnlein, who wanted to write a networked poker game as a final project
                            in a class that I was teaching.  I helped them with the network part of the
                            project by writing a basic framework to support communication between the players.
                            Since the application illustrates a variety of important ideas, I decided to
                            include a somewhat more advanced and general version of that framework in
                            this book.   The final example in this section is a networked poker game.
                        </p>


                        <h3 id="The Netgame Framework"><a class="header" href="#The Netgame Framework">The Netgame Framework</a></h3>

                        <p>One can imagine playing many different games over the network.  As far as the
                            network goes, all of those games have at least one thing in common: There has
                            to be some way for actions taken by one player to be communicated over the
                            network to other players.  It makes good programming sense to make that
                            capability available in a reusable common core that can be used in many
                            different games.  I have written such a core; it is defined by several
                            classes in the package <span class="sourceref"><a href="./source/chapter12/netgame/common/">netgame.common</a></span>.
                        </p>


                        <p>We have not done much with packages in this book, aside from using
                            built-in classes.  Packages were introduced in <a href="ch12-06-Exercises.html">Subsection&nbsp;2.6.6</a>,
                            but we have stuck to the "default package" in our programming examples.
                            In practice, however, packages are used in all but the simplest programming
                            projects to divide the code into groups of related classes.  It makes particularly
                            good sense to define a reusable framework in a package that can be included as
                            a unit in a variety of projects.</p>


                        <p>Integrated development environments such as Eclipse make it very
                            easy to use packages:  To use the netgame package in a project in an IDE, simply
                            copy-and-paste the entire <span class="sourceref"><a href="./source/chapter12/netgame">netgame</a></span> directory into the
                            project.  Of course, since netgames use JavaFX, you need to use
                            an Eclipse project configured to support JavaFX, as discussed in
                            <a href="ch02-06-ProgrammingEnvironments.html">Section&nbsp;2.6</a>.</p>




                        <p>If you work on the command line, you should be in a working directory
                            that includes the <i>netgame</i> directory as a subdirectory.
                            You need to add JavaFX options to the <span class="code">javac</span>
                            and <span class="code">java</span> commands.  Let's say that you've defined
                            <span class="code">jfxc</span> and <span class="code">jfx</span> commands that are equivalent
                            to the <span class="code">javac</span> and <span class="code">java</span> with JavaFX options included, as discussed in
                            <a href="ch02-06-ProgrammingEnvironments.html">Subsection&nbsp;2.6.7</a>. Then, to compile
                            all the java files in the package <span class="sourceref"><a href="./source/chapter12/netgame/common/">netgame.common</a></span>,
                            for example, you can use the following command in MacOS or Linux:</p>


                        <pre><code class="console"> $ jfxc netgame/common/*.java</code></pre>


                        <p>For Windows, you should use backslashes instead of forward slashes:</p>


                        <pre><code class="console"> $ jfxc netgame\common\*.java</code></pre>



                        <p>You will need similar commands to compile the source code for the examples in
                            this section, which are defined in other subpackages of <span class="code">netgame</span>.</p>


                        <p>To run a main program that is defined in a package, you should again be in
                            a directory that contains the package as a subdirectory, and you should use the
                            full name of the class that you want to run.  For example, the <span class="classname">ChatRoomWindow</span>
                            class, discussed later in this section, is defined in the package <span class="sourceref"><a href="./source/chapter12/netgame/chat/">netgame.chat</a></span>,
                            so you would run it with the command</p>


                        <pre><code class="console"> $ jfx netgame.chat.ChatRoomWindow</code></pre>



                        <p>The applications discussed in this section are examples of distributed
                            computing, since they involve several computers communicating over a network.
                            Like the example in <a href="ch12-04-ThreadsandNetworking.html">Subsection&nbsp;12.4.5</a>, they use a central "server,"
                            or "master," to which a number of "clients" will connect.  All communication
                            goes through the server; a client cannot send messages directly to another
                            client.  In this section, I will refer to the server as a <span class="newword">hub</span>,
                            in the sense of "communications hub":</p>


                        <p align="center">
                            <img src="./images/hub-and-clients.png" width="385" alt="a central hub communicating with several clients"></p>


                        <p>The main things that you need to understand are that:  The hub must be running
                            before any clients are started.  Clients connect to the hub and can send messages to
                            the hub.  The hub processes all messages from clients sequentially, in the order
                            in which they are received.  The processing can result in the hub sending messages
                            out to one or more clients.  Each client is identified by a unique ID number.
                            This is a <i>framework</i> that can be used in a variety of applications, and the
                            messages and processing will be defined by the particular application.
                            Here are some of the details...</p>


                        <p>In <a href="ch12-04-ThreadsandNetworking.html">Subsection&nbsp;12.4.5</a>,
                            messages were sent back and forth between the server and the client in a definite,
                            predetermined sequence.  Communication between the server and a client
                            was actually communication between one thread running on the server and another
                            thread running on the client.  For the netgame framework, however, I want to
                            allow for asynchronous communication, in which it is not possible to wait for
                            messages to arrive in a predictable sequence.  To make this possible a netgame
                            client will use two threads for communication, one for sending messages to the hub and
                            one for receiving messages from the hub.  Similarly, the netgame hub will use two threads
                            for communicating with <i>each</i> client.</p>


                        <p>The hub is generally connected to many clients and can receive messages
                            from any of those clients at any time.  The hub will have to process each
                            message in some way.  To organize this processing, the hub uses a single
                            thread to process all incoming messages.  When a communication thread
                            receives a message from a client, it simply drops that message into a
                            queue of incoming messages.  There is only one such queue, which is
                            used for messages from all clients.  The message processing thread runs
                            in a loop in which it removes a message from the queue, processes it,
                            removes another message from the queue, processes it, and so on.
                            The queue itself is implemented as an object of type
                            <span class="classname">LinkedBlockingQueue</span> (see <a href="ch12-03-ThreadsandParallelProcessing.html">Subsection&nbsp;12.3.3</a>).</p>


                        <p align="center">
                            <img src="./images/hub-and-client-threads.png" width="592" height="280" alt="hub and clients, showing threads and message queue"></p>


                        <p>There is one more thread in the hub, not shown in the illustration.  This final
                            thread creates a <span class="classname">ServerSocket</span> and uses it to listen
                            for connection requests from clients. Each time it accepts a connection request,
                            it hands off the client socket to another object, defined by the nested class
                            <span class="classname">ConnectionToClient</span>, which will handle communication with that client.
                            Each connected client is identified by an ID number.  ID numbers 1, 2, 3,&nbsp;...&nbsp;are
                            assigned to clients as they connect.  Since clients can also disconnect, the clients
                            connected at any give time might not have consecutive IDs. A variable
                            of type <span class="classname">TreeMap&lt;Integer,ConnectionToClient&gt;</span>
                            associates the ID numbers of connected clients with the objects that
                            handle their connections.</p>


                        <p>The messages that are sent and received are objects.  The I/O streams
                            that are used for reading and writing objects are of type
                            <span class="classname">ObjectInputStream</span> and <span class="classname">ObjectOutputStream</span>.
                            (See <a href="ch11-01-IOStreamsReadersAndWriters.html">Subsection&nbsp;11.1.6</a>.)  The output stream of a socket is wrapped
                            in an <span class="classname">ObjectOutputStream</span> to make it possible to transmit
                            objects through that socket.  The socket's input stream is wrapped in
                            an <span class="classname">ObjectInputStream</span> to make it possible to receive
                            objects.  Remember that the objects that are used with such streams
                            must implement the interface <span class="code">java.io.Serializable</span>.</p>


                        <p>The netgame <span class="classname">Hub</span> class is defined in the file
                            <span class="sourceref"><a href="./source/chapter12/netgame/common/Hub.java">Hub.java</a></span>, in the
                            package <span class="sourceref"><a href="./source/chapter12/netgame/common/">netgame.common</a></span>.
                            The port on which the server socket will listen must be specified as a
                            parameter to the <span class="classname">Hub</span> constructor.
                            The <span class="classname">Hub</span> class defines a method
                        </p>


                        <pre><code class="java">protected void messageReceived(int playerID, Object message)</code></pre>


                        <p>When a message from some client arrives at the front of the
                            queue of messages, the message-processing thread removes it
                            from the queue and calls this method.  This is the point at which
                            the message from the client is actually processed.</p>


                        <p>The first parameter, <span class="code">playerID</span>, is the ID number of the client
                            from whom the message was received, and the second parameter is the message
                            itself.  In the <span class="classname">Hub</span> class, this method will simply
                            forward a copy of the message to every connected client.  This defines the default processing
                            for incoming messages to the hub.  To forward the message, it
                            wraps both the <span class="code">playerID</span> and the <span class="code">message</span> in
                            an object of type <span class="classname">ForwardedMessage</span> (defined in the
                            file <span class="sourceref"><a href="./source/chapter12/netgame/common/ForwardedMessage.java">ForwardedMessage.java</a></span>,
                            in the package <span class="code">netgame.common</span>).  In a simple application such as
                            the chat room discussed in the <a href="ch12-05-NetworkProgrammingExample.html">next&nbsp;subsection</a>,
                            this default processing might be exactly what is needed by the application.
                            For most applications, however, it will be necessary
                            to define a subclass of <span class="classname">Hub</span> and redefine
                            the <span class="code">messageReceived()</span> method to do more complicated message processing.
                            There are several other methods in the <span class="classname">Hub</span>
                            class that you might want to redefine in a subclass, including
                        </p>


                        <ul>

                            <li>
                                <span class="codedef">protected void playerConnected(int playerID)</span> &mdash; This method is
                                called each time a player connects to the hub.  The parameter <span class="code">playerID</span>
                                is the ID number of the newly connected player. In the <span class="classname">Hub</span>
                                class, this method does nothing.  (The hub has already sent a
                                <span class="sourceref"><a href="./source/chapter12/netgame/common/StatusMessage.java">StatusMessage</a></span> to
                                every client to inform them about the new player; <span class="code">playerConnected()</span>
                                is for any additional actions that a subclass of <span class="classname">Hub</span>
                                might want to take.)  Note that the complete list of ID numbers
                                for currently connected players can be obtained by calling
                                <span class="code">getPlayerList()</span>.</li>

                            <li>
                                <span class="codedef">protected void playerDisconnected(int playerID)</span> &mdash; This
                                is called each time a player disconnects from the hub (after the hub sends a
                                <span class="classname">StatusMessage</span> to the clients).  The parameter tells
                                which player has just disconnected.  In the <span class="classname">Hub</span> class,
                                this method does nothing.</li>

                        </ul>


                        <p>The <span class="classname">Hub</span> class also defines a number of useful public
                            methods, notably</p>


                        <ul>

                            <li>
                                <span class="codedef">sendToAll(message)</span> &mdash; sends the specified <span class="code">message</span>
                                to every client that is currently connected to the hub.  The message must be a non-null
                                object that implements the <span class="classname">Serializable</span> interface.</li>

                            <li>
                                <span class="codedef">sendToOne(recipientID,message)</span> &mdash; sends a
                                specified <span class="code">message</span> to just one user.  The first parameter,
                                <span class="code">recipientID</span> is the ID number of the client who will receive the
                                message.  This method returns a <span class="ptype">boolean</span> value, which is false if
                                there is no connected client with the specified <span class="code">recipientID</span>.</li>

                            <li>
                                <span class="codedef">shutDownServerSocket()</span> &mdash; shuts down the hub's
                                server socket, so that no additional clients will be able to connect.  This could
                                be used, for example, in a two-person game, after the second client has connected.</li>

                            <li>
                                <span class="codedef">setAutoreset(autoreset)</span> &mdash; sets the <span class="ptype">boolean</span>
                                value of the <span class="code">autoreset</span> property.  If this property is <span class="code">true</span>,
                                then the <span class="classname">ObjectOutputStreams</span> that are used to transmit
                                messages to clients will automatically be reset before each message is
                                transmitted.  The default value is false.
                                (Resetting an <span class="classname">ObjectOutputStream</span> is something
                                that has to be done if an object is written to the stream, modified, and then
                                written to the stream again.  If the stream is not reset before writing the
                                modified object, then the old, unmodified value is sent to the stream instead of the new value.
                                See <a href="ch11-01-IOStreamsReadersAndWriters.html">Subsection&nbsp;11.1.6</a> for a discussion of this technicality.  The preferred solution
                                is to use only immutable objects for communication; in that case, no resetting is necessary.)</li>

                        </ul>


                        <p>For more information&mdash;and to see how all this is implemented&mdash;you
                            should read the source code file <span class="sourceref"><a href="./source/chapter12/netgame/common/Hub.java">Hub.java</a></span>.
                            With some effort and study, you should be able to understand everything in that file.
                            (However, you only need to understand the public and protected interface of
                            <span class="classname">Hub</span> and other classes in the netgame framework
                            to write applications based on it.)</p>





                        <p>Turning to the client side, the basic netgame client class is defined in the file
                            <span class="sourceref"><a href="./source/chapter12/netgame/common/Client.java">Client.java</a></span>, in
                            the package <span class="sourceref"><a href="./source/chapter12/netgame/common/">netgame.common</a></span>.
                            The <span class="classname">Client</span> class has a constructor that specifies
                            the host name (or IP address) and port number of the hub to which the client will connect.
                            This constructor blocks until the connection has been established.</p>


                        <p>
                            <span class="classname">Client</span> is an <span class="code">abstract</span> class.
                            Every netgame application <b>must</b> define a subclass of <span class="classname">Client</span>
                            and provide a definition for the abstract method:</p>


                        <pre><code class="java">abstract protected void messageReceived(Object message);</code></pre>


                        <p>This method is called each time a message is received from
                            the netgame hub.  A subclass of client
                            might also override the <span class="code">protected</span> methods
                            <span class="code">playerConnected</span>, <span class="code">playerDisconnected</span>,
                            <span class="code">serverShutdown</span>, and <span class="code">connectionClosedByError</span>.
                            See the <span class="sourceref"><a href="./source/chapter12/netgame/common/Client.java">source&nbsp;code</a></span>
                            for more information.  I should also note that <span class="classname">Client</span>
                            contains the <span class="code">protected</span> instance variable <span class="code">connectedPlayerIDs</span>,
                            of type <span class="code">int[]</span>, an array containing the ID numbers of all the clients
                            that are currently connected to the hub. The most important <span class="code">public</span>
                            methods that are provided by the <span class="code">Client</span> class are</p>


                        <ul>

                            <li>
                                <span class="codedef">send(message)</span> &mdash; transmits a message to the hub.  The
                                <span class="code">message</span> can be any non-null object that implements the
                                <span class="classname">Serializable</span> interface.</li>

                            <li>
                                <span class="codedef">getID()</span> &mdash; gets the ID number that was assigned to this client by the hub.</li>

                            <li>
                                <span class="codedef">disconnect()</span> &mdash; closes the client's connection to the hub.
                                It is not possible to send messages after disconnecting.  The <span class="code">send()</span>
                                method will throw an <span class="classname">IllegalStateException</span> if an attempt is
                                made to do so.</li>

                        </ul>


                        <p>The <span class="classname">Hub</span> and <span class="classname">Client</span> classes
                            are meant to define a general framework that can be used as the basis for
                            a variety of networked games&mdash;and, indeed, of other distributed programs.
                            The low level details of network communication and multithreading are hidden
                            in the <span class="code">private</span> sections of these classes.  Applications that
                            build on these classes can work in terms of higher-level concepts such
                            as players and messages.  The design of these classes was developed though several
                            iterations, based on experience with several actual applications.  I urge
                            you to look at the source code to see how <span class="classname">Hub</span> and
                            <span class="classname">Client</span> use threads, sockets, and I/O streams.  In the
                            remainder of this section, I will discuss three applications built on
                            the netgame framework.  I will not discuss these applications in great detail.
                            You can find the complete source code for all three in the
                            <span class="sourceref"><a href="./source/chapter12/netgame/">netgame</a></span> package.</p>


                        <h3 id="A Simple Chat Room"><a class="header" href="#A Simple Chat Room">A Simple Chat Room</a></h3>


                        <p>Our first example is a "chat room," a network application
                            where users can connect to a server and can then post messages
                            that will be seen by all current users of the room.  It is similar
                            to the <span class="sourceref"><a href="./source/chapter12/GUIChat.java">GUIChat</a></span> program
                            from <a href="ch12-04-ThreadsandNetworking.html">Subsection&nbsp;12.4.2</a>, except that any number of
                            users can participate in a chat.  While this application is not
                            a game, it does show the basic functionality of the
                            netgame framework.
                        </p>


                        <p>The chat room application consists of two programs.  The first,
                            <span class="sourceref"><a href="./source/chapter12/netgame/chat/ChatRoomServer.java">ChatRoomServer.java</a></span>,
                            is a completely trivial program that simply creates a netgame
                            <span class="classname">Hub</span> to listen for connection requests
                            from netgame clients:</p>


                        <pre><code class="java">public static void main(String[] args) {
    try {
        new Hub(PORT);
    }
    catch (IOException e) {
        System.out.println("Can't create listening socket.  Shutting down.");
    }
}</code></pre>


                        <p>The port number, <span class="code">PORT</span>, is defined as a constant in the
                            program and is arbitrary, as long as both the server and the
                            clients use the same port.  Note that
                            ChatRoom uses the <span class="classname">Hub</span> class itself, not a subclass.</p>


                        <p>The second part of the chat room application is the program
                            <span class="sourceref"><a href="./source/chapter12/netgame/chat/ChatRoomWindow.java">ChatRoomWindow.java</a></span>,
                            which is meant to be run by users who want to participate in the chat room.
                            A potential user must know the name (or IP address) of the computer
                            where the hub is running.  (For testing, it is possible to run
                            the client program on the same computer as the hub, using <span class="code">localhost</span>
                            as the name of the computer where the hub is running.)
                            When <span class="classname">ChatRoomWindow</span> is
                            run, it uses a dialog box to ask the user for this information.  It
                            then opens a window that will serve as the user's interface to the chat
                            room.  The window has a large transcript area that displays messages that
                            users post to the chat room.  It also has a text input box where the
                            user can enter messages.  When the user enters a message, that message
                            will be posted to the transcript of every user who is connected to the
                            hub, so all users see every message sent by every user.  Let's look
                            at some of the programming.</p>


                        <p>Any netgame application must define a subclass of the abstract
                            <span class="sourceref"><a href="./source/chapter12/netgame/common/Client.java">Client</a></span> class.
                            For the chat room application, clients are defined by a nested
                            class <span class="classname">ChatClient</span> inside <span class="classname">ChatRoomWindow</span>.
                            The program has an instance variable, <span class="code">connection</span>, of type
                            <span class="classname">ChatClient</span>, which represents the program's
                            connection to the hub.  When the user enters a message, that message
                            is sent to the hub by calling</p>


                        <pre><code class="java">connection.send(message);</code></pre>


                        <p>When the hub receives the message, it packages it into an object
                            of type <span class="sourceref"><a href="./source/chapter12/netgame/common/ForwardedMessage.java">ForwardedMessage</a></span>,
                            along with the ID number of the client who sent the message.  The hub
                            sends a copy of that <span class="classname">ForwardedMessage</span> to every
                            connected client, including the client who sent the message.  On the client
                            side in each client, when the message is received from the hub,
                            the <span class="code">messageReceived()</span> method of the <span class="classname">ChatClient</span>
                            object in that client is called.
                            <span class="classname">ChatClient</span> overrides this method to program it to
                            add the message to the transcript of the <span class="classname">ChatClientWindow</span>.
                            To summarize: Every message entered by any user is sent to the hub, which
                            just sends out copies of each message that it receives to every client.  Each
                            client will see exactly the same stream of messages from the hub.
                        </p>


                        <p>A client is also notified when a player connects to or disconnects from
                            the hub and when the connection with the hub is lost.  <span class="classname">ChatClient</span>
                            overrides the methods that are called when these events happen so that
                            they post appropriate messages to the transcript.   Here's the complete definition
                            of the client class for the chat room application:</p>


                        <pre><code class="java">/**
 * A ChatClient connects to the Hub and is used to send messages to
 * the Hub and receive messages from the Hub.  Messages received from
 * the Hub will be of type ForwardedMessage and will contain the
 * ID number of the sender and the string that was sent by
 * that user.
 */
private class ChatClient extends Client {

    /**
     * Opens a connection to the chat room server on a specified computer.
     */
    ChatClient(String host) throws IOException {
        super(host, PORT);
    }

    /**
     * Responds when a message is received from the server.  It should be
     * a ForwardedMessage representing something that one of the participants
     * in the chat room is saying.  The message is simply added to the
     * transcript, along with the ID number of the sender.
     */
    protected void messageReceived(Object message) {
        if (message instanceof ForwardedMessage) {
                  // (no other message types are expected)
            ForwardedMessage bm = (ForwardedMessage)message;
            addToTranscript("#" + bm.senderID + " SAYS:  " + bm.message);
        }
    }

    /**
     * Called when the connection to the client is shut down because of some
     * error message.  (This will happen if the server program is terminated.)
     */
    protected void connectionClosedByError(String message) {
        addToTranscript(
           "Sorry, communication has shut down due to an error:\n     "
                                     + message );
        Platform.runLater( () -&gt; {
            sendButton.setDisable(true);
            messageInput.setEditable(false);
            messageInput.setDisable(true);
            messageInput.setText("");
        });
        connected = false;
        connection = null;
    }

    /**
     * Posts a message to the transcript when someone joins the chat room.
     */
    protected void playerConnected(int newPlayerID) {
        addToTranscript(
                "Someone new has joined the chat room, with ID number "
                + newPlayerID );
    }

    /**
     * Posts a message to the transcript when someone leaves the chat room.
     */
    protected void playerDisconnected(int departingPlayerID) {
        addToTranscript( "The person with ID number "
                            + departingPlayerID + " has left the chat room");
    }

} // end nested class ChatClient</code></pre>


                        <p>Except for the constructor, none of the methods in the <span class="classname">ChatClient</span>
                            class are called by the <span class="classname">ChatRoomWindow</span> program; they are called from
                            the connection-handling thread in the client object, which was programmed in
                            <span class="sourceref"><a href="./source/chapter12/netgame/common/Client.java">Client.java</a></span>.
                            For the full source code of the chat room application, see the
                            source code files, which can be found in the package
                            <span class="sourceref"><a href="./source/chapter12/netgame/chat">netgame.chat</a></span>.</p>


                        <p>Note: A user of my chat room application is identified only by an ID number that
                            is assigned by the hub when the client connects.  Essentially, users are
                            anonymous, which is not very satisfying.  See <a href="ch12-06-Exercises.html">Exercise&nbsp;12.7</a>
                            at the end of this chapter for a way of addressing this issue.</p>


                        <h3 id="A Networked TicTacToe Game"><a class="header" href="#A Networked TicTacToe Game">A Networked TicTacToe Game</a></h3>

                        <p>My second example is a very simple game: the familiar children's game
                            TicTacToe.  In TicTacToe, two players alternate placing marks on a
                            three-by-three board.  One player plays X's; the other plays O's.
                            The object is to get three X's or three O's in a row.</p>


                        <p>At a given time, the state of a TicTacToe game consists of
                            various pieces of information such as the current contents of
                            the board, whose turn it is, and&mdash;when the game is over&mdash;who
                            won or lost.  In a typical non-networked version of the game,
                            this state would be represented by instance variables.  The
                            program would consult those instance variables to determine
                            how to draw the board and how to respond to user actions such
                            as mouse clicks.  In the networked netgame version, however,
                            there are <b>three</b> objects involved:  Two objects belonging to a
                            client class, which provide the interface to the two players
                            of the game, and the hub object that manages the connections to the
                            clients.  These objects are not even on the same
                            computer, so they certainly can't use the same state variables!
                            Nevertheless, the game has to have a single, well-defined
                            state at any time, and both players have to be aware of
                            that state.</p>


                        <p>My solution for TicTacToe is to store the "official" game state in
                            the hub, and to send a copy of that state to each player
                            every time the state changes.  The players can't change
                            the state directly.  When a player takes some action, such
                            as placing a piece on the board, that action is sent
                            as a message to the hub.  The hub changes the state to
                            reflect the result of the action, and it sends the new
                            state to both players.  The window used by each player will
                            then be updated to reflect the new state.  In this way, we
                            can be sure that the game always looks the same to both players.
                            (Instead of sending a complete copy of the state each time the state
                            changes, I might have sent just the change.  But that would require
                            some way to encode the changes into messages that can be sent
                            over the network.  Since the state is so simple, it seemed easier
                            just to send the entire state as the message in this case.)
                        </p>


                        <p>Networked TicTacToe is defined in several classes in the
                            package <span class="sourceref"><a href="./source/chapter12/netgame/tictactoe/">netgame.tictactoe</a></span>. The class
                            <span class="sourceref"><a href="./source/chapter12/netgame/tictactoe/TicTacToeGameState.java">TicTacToeGameState</a></span>
                            represents the state of a game.  It includes a method
                        </p>


                        <pre><code class="java">public void applyMessage(int senderID, Object message)</code></pre>


                        <p>that modifies the state of the game to reflect the effect of a message
                            received from one of the players of the game.  The message will
                            represent some action taken by the player, such as clicking
                            on the board.</p>


                        <p>The basic <span class="classname">Hub</span> class knows nothing about TicTacToe.
                            Since the hub for the TicTacToe game has to keep track of the state
                            of the game, it has to be defined by a subclass of <span class="classname">Hub</span>.
                            The <span class="sourceref"><a href="./source/chapter12/netgame/tictactoe/TicTacToeGameHub.java">TicTacToeGameHub</a></span>
                            class is quite simple.  It overrides the <span class="code">messageReceived()</span> method
                            so that it responds to a message from a player by applying that message
                            to the game state and sending a copy of the new state to both players.  It
                            also overrides the <span class="code">playerConnected()</span> and <span class="code">playerDisconnected()</span>
                            methods to take appropriate actions, since the game can only be played when
                            there are exactly two connected players.  Here is the complete source code:</p>


                        <pre><code class="java">package netgame.tictactoe;

import java.io.IOException;

import netgame.common.Hub;

/**
 * A "Hub" for the network TicTacToe game.  There is only one Hub
 * for a game, and both network players connect to the same Hub.
 * Official information about the state of the game is maintained
 * on the Hub.  When the state changes, the Hub sends the new
 * state to both players, ensuring that both players see the
 * same state.
 */
public class TicTacToeGameHub extends Hub {

    private TicTacToeGameState state;  // Records the state of the game.

    /**
     * Create a hub, listening on the specified port.  Note that this
     * method calls setAutoreset(true), which will cause the output stream
     * to each client to be reset before sending each message.  This is
     * essential since the same state object will be transmitted over and
     * over, with changes between each transmission.
     * @param port the port number on which the hub will listen.
     * @throws IOException if a listener cannot be opened on the specified port.
     */
    public TicTacToeGameHub(int port) throws IOException {
        super(port);
        state = new TicTacToeGameState();
        setAutoreset(true);
    }

    /**
     * Responds when a message is received from a client.  In this case,
     * the message is applied to the game state, by calling state.applyMessage().
     * Then the possibly changed state is transmitted to all connected players.
     */
    protected void messageReceived(int playerID, Object message) {
        state.applyMessage(playerID, message);
        sendToAll(state);
    }

    /**
     * This method is called when a player connects.  If that player
     * is the second player, then the server's listening socket is
     * shut down (because only two players are allowed), the
     * first game is started, and the new state -- with the game
     * now in progress -- is transmitted to both players.
     */
    protected void playerConnected(int playerID) {
        if (getPlayerList().length == 2) {
            shutdownServerSocket();
            state.startFirstGame();
            sendToAll(state);
        }
    }

    /**
     * This method is called when a player disconnects.  This will
     * end the game and cause the other player to shut down as
     * well.  This is accomplished by setting state.playerDisconnected
     * to true and sending the new state to the remaining player, if
     * there is one, to notify that player that the game is over.
     */
    protected void playerDisconnected(int playerID) {
        state.playerDisconnected = true;
        sendToAll(state);
    }
}</code></pre>



                        <p>A player's interface to the game is represented by the
                            class <span class="sourceref"><a href="./source/chapter12/netgame/tictactoe/TicTacToeWindow.java">TicTacToeWindow</a></span>.
                            As in the chat room application, this class defines a nested subclass
                            of <span class="classname">Client</span> to represent the client's connection
                            to the hub.  When the state of the game changes, a message is sent
                            to each client, and the client's <span class="code">messageReceived()</span> method
                            is called to process that message.  That method, in turn, calls a
                            <span class="code">newState()</span> method in the <span class="classname">TicTacToeWindow</span>
                            class to update the window.  That method is called on the JavaFX
                            application  thread using <span class="code">Platform.runLater()</span>:</p>



                        <pre><code class="java">protected void messageReceived(Object message) {
    if (message instanceof TicTacToeGameState) {
        Platform.runLater( () -&gt; newState( (TicTacToeGameState)message ) );
    }
}</code></pre>



                        <p>To run the TicTacToe netgame, the two players should each run the program
                            <span class="sourceref"><a href="./source/chapter12/netgame/tictactoe/Main.java">Main.java</a></span>
                            in the package <span class="sourceref"><a href="./source/chapter12/netgame/tictactoe/">netgame.tictactoe</a></span>.
                            This program presents the user with a window where the user can
                            choose to start a new game or to join an existing game.  If the user
                            starts a new game, then a <span class="classname">TicTacToeHub</span> is created
                            to manage the game, and a second window of type <span class="classname">TicTacToeWindow</span> is opened
                            that immediately connects to the hub.  The game will start as soon as a second
                            player connects to the hub.  On the other hand, if the user running
                            <span class="classname">Main</span> chooses to connect to an existing
                            game, then no hub is created.  A <span class="classname">TicTacToeWindow</span> is created,
                            and that window connects to the
                            hub that was created by the first player.  The second player has to know
                            the name of the computer where the first player's program is running.
                            As usual, for testing, you can run everything on one computer and use
                            "localhost" as the computer name.</p>



                        <p>(This is the first program that we have seen that uses two different windows.
                            Note that <span class="classname">TicTacToeWindow</span> is defined as a subclass of
                            <span class="classname">Stage</span>, the JavaFX class that represents windows.
                            A JavaFX program starts with a "primary stage" that is created by the system
                            and passed as a parameter to the <span class="code">start()</span> method.  But an application
                            can certainly create additional windows.)</p>


                        <h3 id="A Networked Poker Game"><a class="header" href="#A Networked Poker Game">A Networked Poker Game</a></h3>

                        <p>And finally, we turn very briefly to the application that inspired the
                            netgame framework:  Poker.  In particular, I have implemented a
                            two-player version of the traditional "five card draw" version of
                            that game.  This is a rather complex application, and I do not
                            intend to say much about it here other than to describe the general
                            design.  The full source code can be found in the package
                            <span class="sourceref"><a href="./source/chapter12/netgame/fivecarddraw/">netgame.fivecarddraw</a></span>.
                            To fully understand it, you will need to be familiar with the
                            game of five card draw poker.
                        </p>


                        <p>In general outline, the Poker game is similar to the TicTacToe game.
                            There is a <span class="sourceref"><a href="./source/chapter12/netgame/fivecarddraw/Main.java">Main</a></span>
                            class that is run by both players. The first player starts a new game; the second
                            must join that existing game.  There is a class
                            <span class="sourceref"><a href="./source/chapter12/netgame/fivecarddraw/PokerGameState.java">PokerGameState</a></span>
                            to represent the state of a game.  And there is a subclass,
                            <span class="sourceref"><a href="./source/chapter12/netgame/fivecarddraw/PokerHub.java">PokerHub</a></span>,
                            of <span class="classname">Hub</span> to manage the game.</p>


                        <p>But Poker is a much more complicated game than TicTacToe, and the
                            game state is correspondingly more complicated.  It's not clear that we
                            want to broadcast a new copy of the complete game state to the players
                            every time some minor change is made in the state.  Furthermore, it
                            doesn't really make sense for both players to know the full game state&mdash;that
                            would include the opponent's hand and full knowledge of the deck from which
                            the cards are dealt.  (Of course, our client programs wouldn't have to show
                            the full state to the players, but it would be easy enough for a player to
                            substitute their own client program to enable cheating.)  So in the Poker
                            application, the full game state is known only to the <span class="classname">PokerHub</span>.
                            A <span class="classname">PokerGameState</span> object represents a view of the
                            game from the point of view of one player only.  When the state of the game
                            changes, the <span class="classname">PokerHub</span> creates two different
                            <span class="classname">PokerGameState</span> objects, representing the state of the
                            game from each player's point of view, and it sends the appropriate game state
                            object to each player.</p>


                        <p>(One of the hard parts in poker is to implement some way to compare
                            two hands, to see which is higher.  In my game, this is handled by the
                            class <span class="sourceref"><a href="./source/chapter12/netgame/fivecarddraw/PokerRank.java">PokerRank</a></span>.
                            You might find this class useful in other poker games.)</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch12-04-ThreadsandNetworking.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch12-06-Exercises.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch12-04-ThreadsandNetworking.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch12-06-Exercises.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </body>
</html>
