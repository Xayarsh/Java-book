<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Complete Programs - Introduction to Programming Using Java</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

<link rel="stylesheet" href="code-class.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html" >Introduction to Programming Using Java</a></li><li class="chapter-item expanded affix "><a href="preface.html">Preface</a></li><li class="chapter-item expanded "><a href="ch01-00-Overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-FetchExecuteCycle.html"><strong aria-hidden="true">1.1.</strong> Fetch and Execute Cycle</a></li><li class="chapter-item expanded "><a href="ch01-02-AsynchronousEvents.html"><strong aria-hidden="true">1.2.</strong> Asynchronous Events</a></li><li class="chapter-item expanded "><a href="ch01-03-JavaVirtualMachine.html"><strong aria-hidden="true">1.3.</strong> The Java Virtual Machine</a></li><li class="chapter-item expanded "><a href="ch01-04-FundamentalBuildingBlocks.html"><strong aria-hidden="true">1.4.</strong> Fundamentals</a></li><li class="chapter-item expanded "><a href="ch01-05-OOP.html"><strong aria-hidden="true">1.5.</strong> Object Oriented Programming</a></li><li class="chapter-item expanded "><a href="ch01-06-ModernUserInterface.html"><strong aria-hidden="true">1.6.</strong> Modern User Interface</a></li><li class="chapter-item expanded "><a href="ch01-07-InternetAndBeyond.html"><strong aria-hidden="true">1.7.</strong> Internet and Beyond</a></li><li class="chapter-item expanded "><a href="ch01-08-Quiz.html"><strong aria-hidden="true">1.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-NameAndThings.html"><strong aria-hidden="true">2.</strong> Name and Things</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-BasicJavaApplication.html"><strong aria-hidden="true">2.1.</strong> Basic Java Application</a></li><li class="chapter-item expanded "><a href="ch02-02-VariablesAndTypes.html"><strong aria-hidden="true">2.2.</strong> Variables and Types</a></li><li class="chapter-item expanded "><a href="ch02-03-ObjectsAndSubroutines.html"><strong aria-hidden="true">2.3.</strong> Objects and Subroutines</a></li><li class="chapter-item expanded "><a href="ch02-04-TextInputAndOutput.html"><strong aria-hidden="true">2.4.</strong> Text Input and Output</a></li><li class="chapter-item expanded "><a href="ch02-05-DetailsOfExpressions.html"><strong aria-hidden="true">2.5.</strong> Details of Expressions</a></li><li class="chapter-item expanded "><a href="ch02-06-ProgrammingEnvironments.html"><strong aria-hidden="true">2.6.</strong> Programming and Environments</a></li><li class="chapter-item expanded "><a href="ch02-07-Exercises.html"><strong aria-hidden="true">2.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch02-08-Quiz.html"><strong aria-hidden="true">2.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-Control.html"><strong aria-hidden="true">3.</strong> Control</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-BlocksLoopsBranches.html"><strong aria-hidden="true">3.1.</strong> Blocks, Loops and Branches</a></li><li class="chapter-item expanded "><a href="ch03-02-AlgorithmDevelopment.html"><strong aria-hidden="true">3.2.</strong> Algorithm Development</a></li><li class="chapter-item expanded "><a href="ch03-03-While.html"><strong aria-hidden="true">3.3.</strong> while and do...while</a></li><li class="chapter-item expanded "><a href="ch03-04-For.html"><strong aria-hidden="true">3.4.</strong> The for statement</a></li><li class="chapter-item expanded "><a href="ch03-05-If.html"><strong aria-hidden="true">3.5.</strong> The If Statement</a></li><li class="chapter-item expanded "><a href="ch03-06-Switch.html"><strong aria-hidden="true">3.6.</strong> The Switch Statement</a></li><li class="chapter-item expanded "><a href="ch03-07-ExceptionsTryCatch.html"><strong aria-hidden="true">3.7.</strong> Exceptions and try...catch</a></li><li class="chapter-item expanded "><a href="ch03-08-Arrays.html"><strong aria-hidden="true">3.8.</strong> Arrays: An Introduction</a></li><li class="chapter-item expanded "><a href="ch03-09-GUI.html"><strong aria-hidden="true">3.9.</strong> GUI: An Introduction</a></li><li class="chapter-item expanded "><a href="ch03-10-Exercises.html"><strong aria-hidden="true">3.10.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch03-11-Quiz.html"><strong aria-hidden="true">3.11.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-Subroutines.html"><strong aria-hidden="true">4.</strong> Subroutines</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-BlackBoxes.html"><strong aria-hidden="true">4.1.</strong> Black Boxes</a></li><li class="chapter-item expanded "><a href="ch04-02-StaticSubroutines.html"><strong aria-hidden="true">4.2.</strong> Static Subroutines and Variables</a></li><li class="chapter-item expanded "><a href="ch04-03-Parameters.html"><strong aria-hidden="true">4.3.</strong> Parameters</a></li><li class="chapter-item expanded "><a href="ch04-04-ReturnValues.html"><strong aria-hidden="true">4.4.</strong> Return Values</a></li><li class="chapter-item expanded "><a href="ch04-05-Lambda.html"><strong aria-hidden="true">4.5.</strong> Lambda Expressions</a></li><li class="chapter-item expanded "><a href="ch04-06-APIPackagesModulesJavadoc.html"><strong aria-hidden="true">4.6.</strong> API, Packages, Modules and Javadoc</a></li><li class="chapter-item expanded "><a href="ch04-07-MoreOnProgramDesign.html"><strong aria-hidden="true">4.7.</strong> More on Program Design</a></li><li class="chapter-item expanded "><a href="ch04-08-TruthAboutDeclarations.html"><strong aria-hidden="true">4.8.</strong> Truth about Declarations</a></li><li class="chapter-item expanded "><a href="ch04-09-Exercises.html"><strong aria-hidden="true">4.9.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch04-10-Quiz.html"><strong aria-hidden="true">4.10.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-ObjectsClasses.html"><strong aria-hidden="true">5.</strong> Objects and Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-ObjectsAndInstanceMethods.html"><strong aria-hidden="true">5.1.</strong> Objects and Instance Methods</a></li><li class="chapter-item expanded "><a href="ch05-02-ConstructorObjectInit.html"><strong aria-hidden="true">5.2.</strong> Constructor and Object Initialization</a></li><li class="chapter-item expanded "><a href="ch05-03-ProgrammingWithObjects.html"><strong aria-hidden="true">5.3.</strong> Programming with Objects</a></li><li class="chapter-item expanded "><a href="ch05-04-AnExample.html"><strong aria-hidden="true">5.4.</strong> An Example</a></li><li class="chapter-item expanded "><a href="ch05-05-InheritanceAndPolymorphism.html"><strong aria-hidden="true">5.5.</strong> Inheritance and Polymorphism</a></li><li class="chapter-item expanded "><a href="ch05-06-thisandsuper.html"><strong aria-hidden="true">5.6.</strong> this and super</a></li><li class="chapter-item expanded "><a href="ch05-07-Interfaces.html"><strong aria-hidden="true">5.7.</strong> Interfaces</a></li><li class="chapter-item expanded "><a href="ch05-08-NestedClasses.html"><strong aria-hidden="true">5.8.</strong> Nested Classes</a></li><li class="chapter-item expanded "><a href="ch05-09-Exercises.html"><strong aria-hidden="true">5.9.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch05-10-Quiz.html"><strong aria-hidden="true">5.10.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-GUIProgramming.html"><strong aria-hidden="true">6.</strong> Introduction to GUI Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-BasicJavaFXApp.html"><strong aria-hidden="true">6.1.</strong> A Basic JavaFX Application</a></li><li class="chapter-item expanded "><a href="ch06-02-BasicClasses.html"><strong aria-hidden="true">6.2.</strong> Basic Classes</a></li><li class="chapter-item expanded "><a href="ch06-03-BasicEvents.html"><strong aria-hidden="true">6.3.</strong> Basic Events</a></li><li class="chapter-item expanded "><a href="ch06-04-BasicControls.html"><strong aria-hidden="true">6.4.</strong> Basic Controls</a></li><li class="chapter-item expanded "><a href="ch06-05-BasicLayout.html"><strong aria-hidden="true">6.5.</strong> Basic Layout</a></li><li class="chapter-item expanded "><a class="active" href="ch06-06-CompetePrograms.html"><strong aria-hidden="true">6.6.</strong> Complete Programs</a></li><li class="chapter-item expanded "><a href="ch06-07-Exercises.html"><strong aria-hidden="true">6.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch06-08-Quiz.html"><strong aria-hidden="true">6.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-ArraysArraylistsRecords.html"><strong aria-hidden="true">7.</strong> Arrays, ArrayLists and Records</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-ArrayDetails.html"><strong aria-hidden="true">7.1.</strong> Array Details</a></li><li class="chapter-item expanded "><a href="ch07-02-ArrayProcessing.html"><strong aria-hidden="true">7.2.</strong> Array Processing</a></li><li class="chapter-item expanded "><a href="ch07-03-ArrayLists.html"><strong aria-hidden="true">7.3.</strong> ArrayLists</a></li><li class="chapter-item expanded "><a href="ch07-04-Records.html"><strong aria-hidden="true">7.4.</strong> Records</a></li><li class="chapter-item expanded "><a href="ch07-05-SearchingAndSorting.html"><strong aria-hidden="true">7.5.</strong> Searching and Sorting</a></li><li class="chapter-item expanded "><a href="ch07-06-2DArrays.html"><strong aria-hidden="true">7.6.</strong> 2D Arrays</a></li><li class="chapter-item expanded "><a href="ch07-07-Exercises.html"><strong aria-hidden="true">7.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch07-08-Quiz.html"><strong aria-hidden="true">7.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-CorrectnessRobustnessEfficiency.html"><strong aria-hidden="true">8.</strong> Correctness, Robustness, Efficiency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-IntroductionCorrectnessandRobustness.html"><strong aria-hidden="true">8.1.</strong> Introduction to Correctness and Robustness</a></li><li class="chapter-item expanded "><a href="ch08-02-WritingCorrectPrograms.html"><strong aria-hidden="true">8.2.</strong> Writing Correct Programs</a></li><li class="chapter-item expanded "><a href="ch08-03-ExceptionsAndtrycatch.html"><strong aria-hidden="true">8.3.</strong> Exceptions and try..catch</a></li><li class="chapter-item expanded "><a href="ch08-04-AssertionsAnnotations.html"><strong aria-hidden="true">8.4.</strong> Assertions and Annotations</a></li><li class="chapter-item expanded "><a href="ch08-05-AnalysisofAlgorithms.html"><strong aria-hidden="true">8.5.</strong> Analysis of Algorithms</a></li><li class="chapter-item expanded "><a href="ch08-06-Exercises.html"><strong aria-hidden="true">8.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch08-07-Quiz.html"><strong aria-hidden="true">8.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-LinkedDataStructuresRecursion.html"><strong aria-hidden="true">9.</strong> Linked Data Structures and Recursion</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-Recursion.html"><strong aria-hidden="true">9.1.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="ch09-02-LinkedDataStructures.html"><strong aria-hidden="true">9.2.</strong> Linked Data Structures</a></li><li class="chapter-item expanded "><a href="ch09-03-StacksQueuesADTs.html"><strong aria-hidden="true">9.3.</strong> Stacks, Queues and ADTs</a></li><li class="chapter-item expanded "><a href="ch09-04-BinaryTrees.html"><strong aria-hidden="true">9.4.</strong> Binary Trees</a></li><li class="chapter-item expanded "><a href="ch09-05-SimpleRecursiveDescentParser.html"><strong aria-hidden="true">9.5.</strong> A Simple Recursive Descent Parser</a></li><li class="chapter-item expanded "><a href="ch09-06-Exercises.html"><strong aria-hidden="true">9.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch09-07-Quiz.html"><strong aria-hidden="true">9.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-GenericProgrammingandCollectionClasses.html"><strong aria-hidden="true">10.</strong> Generic Programmingand Collection Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-GenericProgramming.html"><strong aria-hidden="true">10.1.</strong> Generic Programming</a></li><li class="chapter-item expanded "><a href="ch10-02-ListsandSets.html"><strong aria-hidden="true">10.2.</strong> Lists and Sets</a></li><li class="chapter-item expanded "><a href="ch10-03-Maps.html"><strong aria-hidden="true">10.3.</strong> Maps</a></li><li class="chapter-item expanded "><a href="ch10-04-JCF.html"><strong aria-hidden="true">10.4.</strong> Programming with the JCF</a></li><li class="chapter-item expanded "><a href="ch10-05-WritingGenericClassesandMethods.html"><strong aria-hidden="true">10.5.</strong> Writing Generic Classes and Methods</a></li><li class="chapter-item expanded "><a href="ch10-06-StreamAPI.html"><strong aria-hidden="true">10.6.</strong> Stream APIs</a></li><li class="chapter-item expanded "><a href="ch10-07-Exercises.html"><strong aria-hidden="true">10.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch10-08-Quiz.html"><strong aria-hidden="true">10.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-IOStreamsFilesNetworking.html"><strong aria-hidden="true">11.</strong> I/O Streams, Files, and Networking</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-IOStreamsReadersAndWriters.html"><strong aria-hidden="true">11.1.</strong> I/O Streams, Readers, and Writers</a></li><li class="chapter-item expanded "><a href="ch11-02-Files.html"><strong aria-hidden="true">11.2.</strong> Files</a></li><li class="chapter-item expanded "><a href="ch11-03-ProgrammingWithFiles.html"><strong aria-hidden="true">11.3.</strong> Programming With Files</a></li><li class="chapter-item expanded "><a href="ch11-04-Networking.html"><strong aria-hidden="true">11.4.</strong> Networking</a></li><li class="chapter-item expanded "><a href="ch11-05-XML.html"><strong aria-hidden="true">11.5.</strong> A Brief Introduction to XML</a></li><li class="chapter-item expanded "><a href="ch11-06-Exercises.html"><strong aria-hidden="true">11.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch11-07-Quiz.html"><strong aria-hidden="true">11.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-ThreadsandMultiprocessing.html"><strong aria-hidden="true">12.</strong> Threads and Multiprocessing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-IntroductiontoThreads.html"><strong aria-hidden="true">12.1.</strong> Introduction to Threads</a></li><li class="chapter-item expanded "><a href="ch12-02-ProgrammingwithThreads.html"><strong aria-hidden="true">12.2.</strong> Programming with Threads</a></li><li class="chapter-item expanded "><a href="ch12-03-ThreadsandParallelProcessing.html"><strong aria-hidden="true">12.3.</strong> Threads and Parallel Processing</a></li><li class="chapter-item expanded "><a href="ch12-04-ThreadsandNetworking.html"><strong aria-hidden="true">12.4.</strong> Threads and Networking</a></li><li class="chapter-item expanded "><a href="ch12-05-NetworkProgrammingExample.html"><strong aria-hidden="true">12.5.</strong> Network Programming Example</a></li><li class="chapter-item expanded "><a href="ch12-06-Exercises.html"><strong aria-hidden="true">12.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch12-07-Quiz.html"><strong aria-hidden="true">12.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-GUIProgrammingContinued.html"><strong aria-hidden="true">13.</strong> GUI Programming Continued</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-PropertiesandBindings.html"><strong aria-hidden="true">13.1.</strong> Properties and Bindings</a></li><li class="chapter-item expanded "><a href="ch13-02-FancierGraphics.html"><strong aria-hidden="true">13.2.</strong> Fancier Graphics</a></li><li class="chapter-item expanded "><a href="ch13-03-ComplexComponentsandMVC.html"><strong aria-hidden="true">13.3.</strong> Complex Components and MVC</a></li><li class="chapter-item expanded "><a href="ch13-04-MostlyWindowsandDialogs.html"><strong aria-hidden="true">13.4.</strong> Mostly Windows and Dialogs</a></li><li class="chapter-item expanded "><a href="ch13-05-FinishingTouches.html"><strong aria-hidden="true">13.5.</strong> Finishing Touches</a></li><li class="chapter-item expanded "><a href="ch13-06-Exercises.html"><strong aria-hidden="true">13.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch13-07-Quiz.html"><strong aria-hidden="true">13.7.</strong> Quiz</a></li></ol><li class="chapter-item expanded "><a href="appendix-00.html"> Appendix</a></li><li class="chapter-item expanded "><a href="glossary-00.html"> Glossary</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="Java">Java</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Introduction to Programming Using Java</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Xayarsh/Java-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Complete Programs"><a class="header" href="#Complete Programs">Complete Programs</a></h2>
                        <p>
                            In this chapter, we have covered many of the
                            basic aspects of GUI programming.  There is still a lot more to learn,
                            and we will return to the topic in <a href="ch13-00-GUIProgrammingContinued.html">Chapter&nbsp;13</a>.  But you
                            already know enough to write some interesting programs.  In this
                            section, we look at two complete programs that use what you have
                            learned about GUI programming in this chapter, as well as what you
                            learned about programming in general in earlier chapters.  Along
                            the way, we will also encounter a few new ideas.</p>


                       <h3 id="A Little Card Game"><a class="header" href="#A Little Card Game">A Little Card Game</a></h3>

                        <p>The first program that we will consider is a GUI version
                            of the command-line card game <span class="sourceref"><a href="./source/chapter5/HighLow.java">HighLow.java</a></span>
                            from <a href="ch05-04-AnExample.html">Subsection&nbsp;5.4.3</a>.  In the new version,
                            <span class="sourceref"><a href="./source/chapter6/HighLowGUI.java">HighLowGUI.java</a></span>, you look at a playing card and try to
                            predict whether the next card will be higher or lower in value. (Aces have the
                            lowest value in this game.)  In this GUI version of the program,
                            you click on a button to make your
                            prediction. If you predict wrong, you lose. If you make three correct
                            predictions, you win.  After completing a game, you can click "New Game"
                            to start another game. Here is
                            what the program looks like in the middle of a game:</p>


                        <p align="center">
                            <img src="./images/high-low-gui.png" width="334" height="205" alt="GUI version of the HighLow card game"></p>


                        <p>The complete source code for the program can be found in the file
                            <span class="sourceref"><a href="./source/chapter6/HighLowGUI.java">HighLowGUI.java</a></span>.  I encourage you to compile and run it.
                            Note that the program also requires <span class="sourceref"><a href="./source/chapter6/Card.java">Card.java</a></span>, <span class="sourceref"><a href="./source/chapter6/Deck.java">Deck.java</a></span>,
                            and <span class="sourceref"><a href="./source/chapter6/Hand.java">Hand.java</a></span>, from <a href="ch05-04-AnExample.html">Section&nbsp;5.4</a>,
                            since they define classes that are used in the program. And it requires
                            the file of card images, <span class="sourceref"><a href="./source/chapter6/cards.png">cards.png</a></span>, that was used
                            in <span class="sourceref"><a href="./source/chapter6/RandomCards.java">RandomCards.java</a></span> from <a href="ch06-02-BasicClasses.html">Subsection&nbsp;6.2.4</a>.</p>


                        <p>The layout of the program should be easy to guess:
                            <span class="code">HighLowGUI</span> uses a <span class="classname">BorderPane</span> as the root
                            of the scene graph.  The center position is occupied by a <span class="classname">Canvas</span>
                            on which the cards and a message are drawn.  The bottom position contains an
                            <span class="classname">HBox</span> that in turn contains three <span class="classname">Buttons</span>.
                            In order to make the buttons fill the <span class="classname">HBox</span>, I set them
                            all to have the same width, as discussed in <a href="ch06-05-BasicLayout.html">Subsection&nbsp;6.5.3</a>.
                            You can see all this in the <span class="code">start()</span> method from the program:</p>


                        <pre><code class="java">public void start(Stage stage) {

    cardImages = new Image("cards.png");     // Load card images.
    board = new Canvas(4*99 + 20, 123 + 80); // Space for 4 cards.

    Button higher = new Button("Higher");    // Create the buttons, and
    higher.setOnAction( e -&gt; doHigher() );   //    install event handlers.
    Button lower = new Button("Lower");
    lower.setOnAction( e -&gt; doLower() );
    Button newGame = new Button("New Game");
    newGame.setOnAction( e -&gt; doNewGame() );

    HBox buttonBar = new HBox( higher, lower, newGame );

    higher.setPrefWidth(board.getWidth()/3.0);  // Make each button fill
    lower.setPrefWidth(board.getWidth()/3.0);   //     1/3 of the width.
    newGame.setPrefWidth(board.getWidth()/3.0);

    BorderPane root = new BorderPane();  // Create the scene graph root node.
    root.setCenter(board);
    root.setBottom(buttonBar);

    doNewGame();  // set up for the first game

    Scene scene = new Scene(root);  // Finish setting up the scene and stage.
    stage.setScene(scene);
    stage.setTitle("High/Low Game");
    stage.setResizable(false);
    stage.show();

}  // end start()</code></pre>



                        <p>Note that the event handlers call methods such as
                            <span class="code">doNewGame()</span> that are defined elsewhere in the program.
                            The programming of those methods
                            is a nice example of thinking in terms of a state machine.  (See <a href="ch06-03-BasicEvents.html">Subsection&nbsp;6.3.6</a>.)
                            It is important to think in terms of the states that the game can be in, how the
                            state can change, and how the response to events can depend on the state. The
                            approach that produced the original, text-oriented game in
                            <a href="ch05-04-AnExample.html">Subsection&nbsp;5.4.3</a> is not appropriate here. Trying to think about
                            the game in terms of a process that goes step-by-step from beginning to end is
                            more likely to confuse you than to help you.</p>


                        <p>The state of the game includes the cards and the message. The cards are
                            stored in an object of type <span class="classname">Hand</span>.
                            The message is a <span class="classname">String</span>.
                            These values are stored in instance variables. There is also another, less
                            obvious aspect of the state: Sometimes a game is in progress, and the user is
                            supposed to make a prediction about the next card. Sometimes we are between
                            games, and the user is supposed to click the "New Game" button. It's a good
                            idea to keep track of this basic difference in state. The program uses a
                            boolean instance variable named <span class="code">gameInProgress</span> for this purpose.</p>


                        <p>The state of the game can change whenever the user clicks on a button. The
                            program has three methods to respond to button clicks:
                            <span class="code">doHigher()</span>, <span class="code">doLower()</span>, and <span class="code">newGame()</span>.
                            It's in these three event-handling methods that the action of the game takes place.</p>


                        <p>We don't want to let the user start a new game if a game is currently in
                            progress. That would be cheating. So, the response in the <span class="code">newGame()</span>
                            method is different depending on whether the state variable
                            <span class="code">gameInProgress</span> is true or false. If a game is in progress, the
                            <span class="code">message</span> instance variable should be set to be an error message. If a
                            game is not in progress, then all the state variables should be set to
                            appropriate values for the beginning of a new game. In any case, the board must
                            be redrawn so that the user can see that the state has changed. The complete
                            <span class="code">newGame()</span> method is as follows:</p>


                        <pre><code class="java">/**
 * Called by the start() method, and called by an event handler if
 * the user clicks the "New Game" button.  Start a new game.
 */
private void doNewGame() {
    if (gameInProgress) {
            // If the current game is not over, it is an error to try
            // to start a new game.
        message = "You still have to finish this game!";
        drawBoard();
        return;
    }
    deck = new Deck();   // Create the deck and hand to use for this game.
    hand = new Hand();
    deck.shuffle();
    hand.addCard( deck.dealCard() );  // Deal the first card into the hand.
    message = "Is the next card higher or lower?";
    gameInProgress = true;
    drawBoard();
} // end doNewGame()</code></pre>


                        <p>The <span class="code">doHigher()</span> and <span class="code">doLower()</span> methods are almost identical
                            to each other (and could probably have been combined into one method with a
                            parameter, if I were more clever). Let's look at the <span class="code">doHigher()</span>
                            routine. This is called when the user clicks the "Higher" button. This only
                            makes sense if a game is in progress, so the first thing <span class="code">doHigher()</span>
                            should do is check the value of the state variable <span class="code">gameInProgress</span>. If
                            the value is <span class="code">false</span>, then <span class="code">doHigher()</span> should just set up an
                            error message. If a game is in progress, a new card should be added to the hand
                            and the user's prediction should be tested. The user might win or lose at this
                            time. If so, the value of the state variable <span class="code">gameInProgress</span> must be
                            set to <span class="code">false</span> because the game is over. In any case, the board is
                            redrawn to show the new state. Here is the <span class="code">doHigher()</span> method:</p>


                        <pre><code class="java">/**
 * Called by an event handler when user clicks "Higher" button.
 * Check the user's prediction.  Game ends if user guessed
 * wrong or if the user has made three correct predictions.
 */
private void doHigher() {
    if (gameInProgress == false) {
            // If the game has ended, it was an error to click "Higher",
            // So set up an error message and abort processing.
        message = "Click \"New Game\" to start a new game!";
        drawBoard();
        return;
    }
    hand.addCard( deck.dealCard() );     // Deal a card to the hand.
    int cardCt = hand.getCardCount();
    Card thisCard = hand.getCard( cardCt - 1 );  // Card just dealt.
    Card prevCard = hand.getCard( cardCt - 2 );  // The previous card.
    if ( thisCard.getValue() &lt; prevCard.getValue() ) {
        gameInProgress = false;
        message = "Too bad! You lose.";
    }
    else if ( thisCard.getValue() == prevCard.getValue() ) {
        gameInProgress = false;
        message = "Too bad!  You lose on ties.";
    }
    else if ( cardCt == 4) {
        gameInProgress = false;
        message = "You win!  You made three correct guesses.";
    }
    else {
        message = "Got it right!  Try for " + cardCt + ".";
    }
    drawBoard();
} // end doHigher()</code></pre>


                        <p>The <span class="code">drawBoard()</span> method, which is responsible for drawing the content
                            of the canvas, uses the values in the state variables to decide what to show. It displays the
                            string stored in the <span class="code">message</span> variable. It draws each of the cards in
                            the <span class="code">hand</span>. There is one little tricky bit: If a game is in progress, it
                            draws an extra face-down card, which is not in the hand, to represent the next
                            card in the deck.  The technique for drawing the individual cards was
                            explained in <a href="ch06-02-BasicClasses.html">Section&nbsp;6.2</a>.  See the <span class="sourceref"><a href="./source/chapter6/HighLowGUI.java">source code</a></span>
                            for the method definition.</p>

                       <h3 id="Menus and Menubars"><a class="header" href="#Menus and Menubars">Menus and Menubars</a></h3>

                        <p>Our second example program, "MosaicDraw," is a kind of drawing program.
                            The source code for the program is in the file <span class="sourceref"><a href="./source/chapter6/MosaicDraw.java">MosaicDraw.java</a></span>.
                            The program also requires <span class="sourceref"><a href="./source/chapter6/MosaicCanvas.java">MosaicCanvas.java</a></span>.  Here is a half-size
                            screenshot showing a sample drawing made with the program:</p>


                        <p align="center">
                            <img src="./images/mosaic-draw.png" width="300" height="328" alt="a face drawn with MosaicDraw"></p>


                        <p>As the user clicks-and-drags the
                            mouse in the large drawing area of this program, it leaves a trail of little colored
                            squares. There is some random variation in the color of the squares.  (This is meant
                            to make the picture look a little more like a real mosaic, which is a picture made out of
                            small colored stones in which there would be some natural color variation.)  The program has
                            one feature that we have not encountered before:
                            There is a menu bar above the drawing area.  The "Control" menu contains
                            commands for filling and clearing the drawing area, along with a few options that affect
                            the appearance of the picture.  The "Color" menu lets the user select the color that will
                            be used when the user draws.  The "Tools" menu affects the behavior of the mouse.
                            Using the default "Draw" tool, the mouse leaves a trail of single squares.  Using the
                            "Draw&nbsp;3x3" tool, the mouse leaves a swatch of colored squares that is three squares wide.
                            There are also "Erase" tools, which let the user set squares back to their default
                            black color.</p>


                        <p>The drawing area of the program is a panel that belongs to the <span class="classname">MosaicCanvas</span>
                            class, a subclass of <span class="classname">Canvas</span> that is defined in <span class="sourceref"><a href="./source/chapter6/MosaicCanvas.java">MosaicCanvas.java</a></span>.
                            <span class="classname">MosaicCanvas</span> is a highly reusable class for representing mosaics of colored
                            rectangles.  It was also used behind the scenes in the sample program in <a href="ch04-07-MoreOnProgramDesign.html">Subsection&nbsp;4.7.3</a>.
                            The <span class="classname">MosaicCanvas</span> class
                            does not directly support drawing on the mosaic, but it does support setting
                            the color of each individual square.  The MosaicDraw program installs mouse handlers on
                            the canvas.  The handlers respond to <span class="code">MousePressed</span> and <span class="code">MouseDragged</span> events on the
                            canvas by applying the currently selected tool to the canvas at the square
                            that contains the mouse position.  This is a nice example of
                            applying event listeners to an object to do something that was not programmed into the object
                            itself.</p>


                        <p>I urge you to study <span class="sourceref"><a href="./source/chapter6/MosaicDraw.java">MosaicDraw.java</a></span>.  I will not be discussing all aspects
                            of the code here, but you should be able to understand it all after reading this section. As for
                            <span class="sourceref"><a href="./source/chapter6/MosaicCanvas.java">MosaicCanvas.java</a></span>, it uses some techniques that you would not understand at this
                            point, but I encourage you to at least read the comments in that file to learn about the API
                            for <span class="classname">MosaicCanvas</span>.</p>


                        <p>MosaicDraw is the first example that we have seen that uses a menu bar.  Fortunately,
                            menus are very easy to use in JavaFX.  The items in a menu are represented by objects belonging
                            to class <span class="classname">MenuItem</span> or to one of its subclasses.
                            (<span class="classname">MenuItem</span> and other menu-related classes are in package <span class="code">javafx.scene.control</span>.)
                            Menu items are used in almost exactly the
                            same way as buttons.  In particular, a <span class="classname">MenuItem</span> can be created using
                            a constructor that specifies the text of the menu item, such as:</p>


                        <pre><code class="java">MenuItem fillCommand = new MenuItem("Fill");</code></pre>


                        <p>Menu items, like buttons, can have a graphic as well as text, and there is a second
                            constructor that allows you to specify both text and graphic.
                            When the user selects a <span class="classname">MenuItem</span> from a menu, an <span class="classname">ActionEvent</span>
                            is generated.  Just as for a button, you can add an action event listener to the menu item using its
                            <span class="code">setOnAction(handler)</span> method.  A menu item has a <span class="code">setDisable(disabled)</span> method
                            that can be used to enable and disable the item.  And it has a <span class="code">setText()</span> method for
                            changing the text that is displayed in the item.</p>


                        <p>The main difference between a menu item and a button, of course, is that a menu
                            item is meant to appear in a menu.  (Actually, a menu item is a <span class="classname">Node</span>
                            that can appear anywhere in a scene graph, but the usual place for it is in a menu.)
                            A menu in JavaFX is
                            represented by the class <span class="classname">Menu</span>.  (In fact, <span class="classname">Menu</span>
                            is actually a subclass of <span class="classname">MenuItem</span>, which means that you can
                            add a menu as an item in another menu.  The menu that you add becomes a submenu of the
                            menu that you add it to.)  A <span class="classname">Menu</span> has a name,
                            which is specified in the constructor.  It has an instance method <span class="code">getItems()</span>
                            that returns a list of menu items contained in the menu.  To add items to the
                            menu, you need to add them to that list:</p>


                        <pre><code class="java">Menu sampleMenu = new Menu("Sample");
sampleMenu.getItems().add( menuItem );  // Add one menu item to the menu.
sampleMenu.getItems().addAll( item1, item2, item3 );  // Add multiple items.</code></pre>


                        <p>Once a menu has been created, it can be added to a menu bar.  A menu bar is represented
                            by the class <span class="classname">MenuBar</span>.  A menu bar is just a container for menus.
                            It does not have a name.  The <span class="classname">MenuBar</span> constructor can be called
                            with no parameters, or it can have a parameter list containing <span class="classname">Menus</span>
                            to be added to the menu bar.  The instance method <span class="code">getMenus()</span>
                            returns a list of menus, with methods <span class="code">add()</span> and <span class="code">addAll()</span>
                            for adding menus to the menu bar.  For example,
                            the <span class="code">MosaicDraw</span> program uses three menus, <span class="code">controlMenu</span>, <span class="code">colorMenu</span>,
                            and <span class="code">toolMenu</span>.  We could create a menu bar and add the menus to it with
                            the statements:</p>


                        <pre><code class="java">MenuBar menuBar = new MenuBar();
menuBar.getMenus().addAll(controlMenu, colorMenu, toolMenu);</code></pre>


                        <p>Or we could list the menus in the menu bar constructor:</p>


                        <pre><code class="java">MenuBar menuBar = new MenuBar(controlMenu, colorMenu, toolMenu);</code></pre>


                        <p>The final step in using menus is to add the menu bar to the program's
                            scene graph.  The menu bar could actually appear anywhere, but typically,
                            it should be at the top of the window.  A program that has a menu bar
                            will usually use a <span class="classname">BorderPane</span> as the root of
                            its scene graph, and it will add the menu bar as the top component
                            in that root pane.  The rest of the GUI for the program can be placed
                            in the other four positions of the border pane.</p>


                        <p>So using menus generally follows the same pattern:  Create a menu bar.  Create menus
                            and add them to the menu bar.  Create menu items and add them to the menus (and set up
                            listening to handle action events from the menu items).  Place the menu bar at the
                            top of a <span class="classname">BorderPane</span>, which is the root of the scene graph.</p>





                        <p>There are other kinds of menu items, defined by subclasses of <span class="classname">MenuItem</span>,
                            that can be added to menus.  A very simple example is <span class="classname">SeparatorMenuItem</span>,
                            which appears in a menu as a line between other menu items.  You can see an example
                            in the "Control" menu of <span class="classname">MosaicDraw</span>. To add a separator to
                            a <span class="classname">Menu</span>, <span class="code">menu</span>, you just need to say</p>


                        <pre><code class="java">menu.getItems().add( new SeparatorMenuItem() );</code></pre>


                        <p>Much more interesting are the subclasses <span class="classname">CheckMenuItem</span>
                            and <span class="classname">RadioMenuItem</span>.</p>


                        <p>A <span class="classname">CheckMenuItem</span> represents a menu item that can be in one
                            of two states, selected or not selected. The state is changed when the user
                            selects the item from the menu that contains it.
                            A <span class="classname">CheckMenuItem</span> has the same functionality and is used in
                            the same way as a <span class="classname">CheckBox</span> (see <a href="ch06-04-BasicControls.html">Subsection&nbsp;6.4.3</a>).
                            Three <span class="classname">CheckMenuItems</span> are used in the "Control" menu
                            of the MosaicDraw program.  One is used to turn the random color variation of
                            the squares on and off.  Another turns a symmetry feature on and off; when symmetry is
                            turned on, the user's drawing is reflected horizontally and vertically to produce
                            a symmetric pattern.  And the third <span class="classname">CheckMenuItem</span> shows and hides
                            "grouting" in the mosaic (grouting consists of gray lines drawn around each
                            of the little squares in the mosaic).  The <span class="classname">CheckMenuItem</span> that corresponds to the
                            "Use Randomness" option in the "Control" menu could be set up with the statements:</p>


                        <pre><code class="java">useRandomness = new CheckMenuItem("Use Randomness");
useRandomness.setSelected(true);  // Randomness is initially turned on.
controlMenu.getMenus().add(useRandomness);   // Add menu item to the menu.</code></pre>


                        <p>No <span class="classname">ActionEvent</span> handler is added to <span class="code">useRandomness</span>;
                            the program simply checks its state by calling <span class="code">useRandomness.isSelected()</span>
                            whenever it is coloring a square, to decide whether to
                            add some random variation to the color.  On the other hand, when the user selects the
                            "Use&nbsp;Grouting" check box from the menu, the canvas must immediately be redrawn to
                            reflect the new state.  A handler is added to the <span class="classname">CheckMenuItem</span>
                            to take care of that by calling an appropriate method:</p>


                        <pre><code class="java">useGrouting.setOnAction( e -&gt; doUseGrouting(useGrouting.isSelected()) );</code></pre>





                        <p>The "Color" and "Tools" menus contain items of type <span class="classname">RadioMenuItem</span>,
                            which are used in the same way as the <span class="classname">RadioButtons</span> that were
                            discussed in <a href="ch06-04-BasicControls.html">Subsection&nbsp;6.4.3</a>:  A <span class="classname">RadioMenuItem</span>,
                            like a check box, can be either selected or unselected, but when several
                            <span class="classname">RadioMenuItems</span> are added to a <span class="classname">ToggleGroup</span>,
                            then at most one of the group members can be selected.  In the program, the user
                            selects the tool that they want to use from the "Tools" menu.  Only one
                            tool can be selected at a time, so it makes sense to use <span class="classname">RadioMenuItems</span>
                            to represent the available tools, and to put all of those items into the same
                            <span class="classname">ToggleGroup</span>.  The currently selected option in the "Tools" menu will be
                            marked as selected; when the user chooses a new tool, the mark is moved.  This gives the
                            user some visible feedback about which tool is currently selected for use.
                            Furthermore, the <span class="classname">ToggleGroup</span> has an observable property
                            representing the currently selected option (see <a href="ch06-03-BasicEvents.html">Subsection&nbsp;6.3.7</a>).  The program
                            adds a listener to that property with an event handler that will be
                            called whenever the user selects a new tool.  Here is the code that creates the
                            "Tools" menu:</p>


                        <pre><code class="java">Menu toolMenu = new Menu("Tools");
ToggleGroup toolGroup = new ToggleGroup();
toolGroup.selectedToggleProperty().addListener(
                 e -&gt; doToolChoice(toolGroup.getSelectedToggle()) );
addRadioMenuItem(toolMenu,"Draw",toolGroup, true);
addRadioMenuItem(toolMenu,"Erase",toolGroup, false);
addRadioMenuItem(toolMenu,"Draw 3x3",toolGroup, false);
addRadioMenuItem(toolMenu,"Erase 3x3",toolGroup, false);</code></pre>


                        <p>The <span class="code">addRadioMenuItem</span> method that is used in this code
                            is a utility method that is defined elsewhere in the program:</p>


                        <pre><code class="java">/**
 * Utility method to create a radio menu item, add it
 * to a ToggleGroup, and add it to a menu.
 */
private void addRadioMenuItem(Menu menu, String command,
                                   ToggleGroup group, boolean selected) {
    RadioMenuItem menuItem = new RadioMenuItem(command);
    menuItem.setToggleGroup(group);
    menu.getItems().add(menuItem);
    if (selected) {
        menuItem.setSelected(true);
    }
}</code></pre>


                        <p>The complete code for creating the menu bar in <span class="code">MosaicDraw</span> can
                            be found in a method <span class="code">createMenuBar()</span>.  Again, I encourage you
                            to study the <span class="sourceref"><a href="./source/chapter6/MosaicDraw.java">source code</a></span>.</p>

                       <h3 id="Scene and Stage"><a class="header" href="#Scene and Stage">Scene and Stage</a></h3>

                        <p>Before ending this brief introduction to GUI programming,
                            we look at two fundamental classes in a little more detail:
                            <span class="classname">Scene</span>, from package <span class="code">javafx.scene</span>,
                            and <span class="classname">Stage</span>, from package <span class="code">javafx.stage</span>.</p>


                        <p>A <span class="classname">Scene</span> represents the content area of a window
                            (that is, not including the window's border and title bar),
                            and it serves as a holder for the root of the scene graph.
                            The <span class="classname">Scene</span> class has several constructors, but they
                            all require the root of the scene graph as one of the parameters, and the
                            root cannot be <span class="code">null</span>.  Perhaps the most common constructor is
                            the one that has only the root as parameter: <span class="code">new&nbsp;Scene(root)</span>.</p>


                        <p>A scene has a width and a height, which can be specified as parameters to the
                            constructor: <span class="code">new Scene(root,width,height)</span>.  In the typical case
                            where the <span class="code">root</span> is a <span class="classname">Pane</span>, the size of the
                            pane will be set to match the size of the scene, and the pane will lay out
                            its contents based on that size.  If the size of the scene is not specified in the constructor,
                            then the size of the scene will be set to the preferred size of the pane.
                            It is not possible for a program to set the width or
                            height of a <span class="classname">Scene</span> after it has been created, but if the size of the stage that
                            contains a scene is changed, then the size of the scene is automatically changed
                            to match the new size of the stage's content area, and the root node of the
                            scene (if it is a <span class="classname">Pane</span>) will be resized as well.</p>


                        <p>A <span class="classname">Scene</span> can have a background fill <span class="classname">color</span> (actually
                            a <span class="classname">Paint</span>), which can be specified in the constructor.  Generally, the scene's
                            background is not seen, since it is covered by the background of the root node.  The default
                            style sets the background of the root to be light gray.  However, you can set the background color
                            of the root to be transparent if you want to see the scene background instead.</p>





                        <p>A <span class="classname">Stage</span>, from package <span class="code">javafx.stage</span>, represents a
                            window on the computer's screen.  Any JavaFX <span class="classname">Application</span> has at
                            least one stage, called the primary stage, which is created by the system and passed
                            as a parameter to the application's <span class="code">start()</span> method.  Although we have not seen any
                            examples so far in this textbook, many programs
                            use more than one window.  It is possible for a program to create new <span class="classname">Stage</span>
                            objects; we will see how to do that in <a href="ch13-00-GUIProgrammingContinued.html">Chapter&nbsp;13</a>.</p>


                        <p>A stage contains a scene, which fills its content area.  The scene is installed in the stage by calling the
                            instance method <span class="code">stage.setScene(scene)</span>.  It is possible to show a stage
                            that does not contain a scene, but its content area will just be a blank rectangle.</p>


                        <p>In addition to a content area, a stage has a title bar above the content.  The title bar
                            contains a title for the window and some "decorations"&mdash;little controls that the
                            user can click to do things like close and maximize the window.  The title bar is provided
                            by the operating system, not by Java, and its style is set by the operating system.
                            The instance method <span class="code">stage.setTitle(string)</span> sets the text that is shown in
                            the title bar.  The title can be changed at any time.</p>


                        <p>By default a stage is resizable.  That is, the size of the window can be changed by the
                            user, by dragging its borders or corners.  To prevent the user from changing the
                            window size, you can call <span class="code">stage.setResizable(false)</span>.  However, a program
                            can change the size of a stage with the instance methods <span class="code">stage.setWidth(w)</span>
                            and <span class="code">stage.setHeight(h)</span>, and this can be done even if the stage has
                            been made non-resizable.  Usually, the initial size of a stage is determined by the
                            size of the scene that it contains, but it is also possible to set the initial size before
                            showing the window using <span class="code">setWidth()</span> and <span class="code">setHeight()</span>.</p>


                        <p>By default, when a stage is resizable, the user can make the window arbitrarily small
                            and arbitrarily large.  It is possible to put limits on the resizability of a window
                            with the instance methods <span class="code">stage.setMinWidth(w)</span>, <span class="code">stage.setMaxWidth(w)</span>,
                            <span class="code">stage.setMinHeight(h)</span>, and <span class="code">stage.setMaxHeight(h)</span>.  The size
                            limits apply only to what the user can do by dragging the borders or corners of the window.
                        </p>


                        <p>It is also possible to change the position of a stage on the screen, using the
                            instance methods <span class="code">stage.setX(x)</span> and <span class="code">stage.setY(y)</span>.
                            The x and y coordinates specify the position of the top left corner of the window,
                            in the coordinate system of the screen.  Typically, you would do this before showing
                            the stage.</p>


                        <p>Finally, for now, remember that a stage is not visible on the screen until you
                            show it by calling the instance method <span class="code">stage.show()</span>.  Showing the
                            primary stage is typically the last thing that you do in a application's
                            <span class="code">start()</span> method.</p>


                       <h3 id="Creating Jar Files"><a class="header" href="#Creating Jar Files">Creating Jar Files</a></h3>

                        <p>Java classes and resource files are often distributed in jar ("java archive") files.
                            For a program that consists of multiple files, it can make sense to pack them
                            into a single jar file.  As the last topic for this chapter, we look at how to do that.
                            The program can be run directly from the jar file, without unpacking it.  However, for
                            JavaFX programs, the user will still need access to the JavaFX SDK.
                            A jar file can be "executable," meaning that it specifies the class that
                            contains the <span class="code">main()</span> routine that will be run when the jar file is
                            executed.  If you have an executable jar file that does not require JavaFX or
                            other external resources, you can run it on the command line using a command
                            of the form:</p>


                        <pre><code class="console">$ java  -jar  JarFileName.jar</code></pre>


                        <p>and you might even be able to run the jar file by double-clicking its icon in
                            a file browser window.  If an executable jar file requires JavaFX, you will need
                            to add the same options to the <span class="code">java</span> command that were discussed in
                            <a href="ch02-06-ProgrammingEnvironments.html">Subsection&nbsp;2.6.7</a>.  For example,</p>


                        <pre><code class="console">$ java -p /opt/jfx17/lib --add-modules=ALL-MODULE-PATH JarFileName.jar</code></pre>



                        <p>The question, then, is how to create a jar file.  The answer depends on what
                            programming environment you are using.  The two basic types of programming environment&mdash;command line
                            and IDE&mdash;were discussed in <a href="ch02-06-ProgrammingEnvironments.html">Section&nbsp;2.6</a>.  Any IDE (Integrated Development Environment)
                            for Java should have a command for creating jar files.  In the Eclipse IDE, for example,
                            it can be done as follows:  In the Package Explorer pane, select the programming project (or just
                            all the individual source and resource files that you want to include).  Right-click on the selection, and
                            choose "Export" from the menu that pops up.  In the window that appears, select "JAR file"
                            and click "Next".  In the window that appears next, enter a full path name for the jar file in
                            the box labeled "JAR file".  (Click the "Browse" button next to this box to select the
                            file name using a file dialog box.)  The name of the file should end with ".jar".
                            If you are creating a regular jar file, not an executable
                            one, you can hit "Finish" at this point, and the jar file will be created.  To create an
                            executable file, hit the "Next" button <i>twice</i> to get to the "Jar Manifest
                            Specification" screen.  At the bottom of this screen is an input box labeled "Main class".
                            You have to enter the name of the class that contains the <span class="code">main()</span> routine
                            that will be run when the jar file is executed.  If you hit the "Browse" button next to
                            the "Main class" box, you can select the class from a list of classes that contain
                            <span class="code">main()</span> routines.  Once you've selected the main class, you can
                            click the "Finish" button to create the executable jar file.</p>


                        <p>It is also possible to create jar files on the command line.  The Java Development Kit
                            includes a command-line program named <span class="code">jar</span> that can be used to create jar files.
                            If all your classes are in the default package (like most of the examples in this book), then
                            the <span class="code">jar</span> command is easy to use.  To create a non-executable jar file on the command line,
                            change to the directory that contains the class files that you want to include in the jar.
                            Then give the command</p>


                        <pre><code class="console">$ jar  -c  -f  JarFileName.jar  *.class</code></pre>


                        <p>where <span class="code">JarFileName</span> can be any name that you want to use for the jar file.
                            The <span class="code">-c</span> option is used to create a jar file.  The <span class="code">-f</span> is followed by
                            the name of the jar file that is to be created.
                            The "<span class="code">*</span>" in "<span class="code">*.class</span>" is a wildcard that makes <span class="code">*.class</span> match every class
                            file in the current directory.  This means that all the class files in the directory will be
                            included in the jar file.  If you want to include only certain class files, you
                            can name them individually, separated by spaces. You can also list the class file names separately.
                            If the program uses resource files, such as images, they should
                            also be listed in the command.  (Things get more complicated if your classes and resources are not in the
                            default package.  In that case, the files must be in subdirectories of the
                            directory in which you issue the <span class="code">jar</span> command, and you have to include the path to
                            the file in the name.  For example: <span class="code">textio/TextIO.class</span> on MacOS and Linux,
                            or <span class="code">textio\TextIO.class</span> on Windows.)</p>


                        <p>Making an executable jar file on the command line is  only a little more complicated.
                            There has to be some way of specifying which class contains the <span class="code">main()</span>
                            routine.  This can be done by adding the <span class="code">-e</span> option to the command,
                            with a value giving the full name of the class that is to be executed when the
                            jar file is run.  For example, if the name of the class is <span class="classname">MyMainClass</span>,
                            then the jar file could be created with:</p>


                        <pre><code class="console">$ jar  -c  -f  JarFileName.jar  -e  MyMainClass  *.class</code></pre>


                        <p>For a program defined in two packages, <span class="code">grapher.ui</span> and <span class="code">grapher.util</span>,
                            with a main class defined in the file <span class="code">Main.java</span> in package <span class="code">grapher.ui</span>,
                            the command would become</p>


                        <pre><code class="console">$ jar -c -f Grapher.jar -e grapher.ui.Main grapher/ui/*.class grapher/util/*.class</code></pre>


                        <p>except that on Windows, the slashes would be replaced by backslashes.</p>


                        <p>(The options <span class="code">-c</span>, <span class="code">-f</span>, and <span class="code">-e</span> are abbreviations
                            for the longer forms <span class="code">--create</span>, <span class="code">--file</span>, and <span class="code">--main-class</span>,
                            and you can use the longer forms, if you prefer clarity to brevity.)</p>

                       <h3 id="jpackage"><a class="header" href="#jpackage">jpackage</a></h3>

                        <p>You can collect the class files and resource files for a program into a jar file,
                            and you can give that jar file to someone who would like to use your
                            program.  However, that person will still need to have Java installed on their
                            computer&mdash;something that is really not very likely these days, unless that person
                            is a Java developer.  A possible solution is to bundle a Java virtual machine
                            along with your program.  The Java Development Kit includes the <span class="code">jpackage</span>
                            command to make that possible.</p>


                        <p>The <span class="code">jpackage</span> command can create an installer that will install your
                            program along with as much Java support as is needed to run it.  It has some
                            significant limitations.  It can only make an installer for the type of computer
                            and operating system that you are using; for example, it is not possible to use <span class="code">jpackage</span>
                            on Linux to make an installer for Windows.  And the files that it makes are very
                            large, since they have to include large parts of a Java execution environment.
                            So <span class="code">jpackage</span> is really meant for packaging large, serious applications.
                            But if you want to try it, here is a basic example, using only a few of the
                            options that are available for <span class="code">jpackage</span>.  For the example,
                            I&nbsp;made an installer for the network poker game from <a href="ch12-05-NetworkProgrammingExample.html">Subsection&nbsp;12.5.4</a>.
                            This might also help you understand how to work with packages in general.</p>


                        <p>To apply <span class="code">jpackage</span> to a program that uses JavaFX, you have to make
                            Java packages available to the <span class="code">jpackage</span> command.  For this purpose,
                            you can't use the JavaFX SDK.  Instead, you need the JavaFX "jmods".  See
                            <a href="ch02-06-ProgrammingEnvironments.html">Subsection&nbsp;2.6.7</a> for a discussion of the JavaFX SDK. For <span class="code">jpackage</span>,
                            you will need to download the jmods for your operating system from
                            <a href="https://gluonhq.com/products/javafx/">https://gluonhq.com/products/javafx/</a>.
                            For my computer, I extracted the downloaded file into <span class="code">/opt/javafx-jmods-17.0.2</span>.
                            (The jmods are required because they include specific operating system support that is not in
                            the SDK jar files.)</p>


                        <p>To use <span class="code">jpackage</span>, you need a jar file that contains the classes and resource files for your
                            program.  The poker game uses classes from the packages <span class="code">netgame.common</span> and
                            <span class="code">netgame.fivecarddraw</span>, plus a resource image file <span class="code">cards.png</span>
                            in <span class="code">netgame.fivecarddraw</span>.  To make the jar file, I first compiled
                            the Java files for the program.  Since the poker game uses JavaFX, I included the
                            necessary options in the <span class="code">javac</span> command.
                            I used the following command in the directory that contained
                            the <span class="sourceref"><a href="./source/chapter12/netgame">netgame</a></span> directory, <i>typed all on one line</i>:</p>


                        <pre><code class="console">$ javac  --module-path  /opt/jfx17/lib  --add-modules=ALL-MODULE-PATH
                    netgame/common/*.java  netgame/fivecarddraw/*.java</code></pre>


                        <p>I then created a jar file, <span class="code">Poker.jar</span>, with this command,
                            <i>typed all on one line</i>:</p>


                        <pre><code class="console">$ jar -c -f Poker.jar  netgame/common/*.class  netgame/fivecarddraw/*.class
                netgame/fivecarddraw/cards.png</code></pre>


                        <p>It is important to include the image resource file along with the class files.
                            (Note that on Windows, the slashes, "/", would be replaced by backslashes, "\".)</p>


                        <p>I moved <span class="code">Poker.jar</span> to a new directory.  Working in that new directory,
                            I used the following very long <span class="code">jpackage</span> command, again <i>typed all on one line</i>:</p>


                        <pre><code class="console">$ jpackage  --input  <b>.</b>  --main-jar  Poker.jar
            --main-class  netgame.fivecarddraw.Main  --name  NetPoker
            --module-path /opt/javafx-jmods-17.0.2
            --add-modules  javafx.base,javafx.controls,javafx.graphics</code></pre>


                        <p>The value for the <span class="code">--input</span> option is a period, which represents the current working
                            directory; it could be replaced by a path to the directory that contains <span class="code">Poker.jar</span>.
                            The value for the <span class="code">--main-class</span> option is the full name of the class that
                            contains the main program; this option is not needed if the jar file is executable.
                            The value of the <span class="code">--name</span> option is used to name the installer and
                            to name the executable file that it will install.  The <span class="code">--module-path</span>
                            refers to the directory that contains the JavaFX jmods.  And the added modules
                            are just those JavaFX modules that are needed for this program.</p>


                        <p>When used on my computer, running Linux Mint, this produced a file named
                            <span class="code">netpoker_1.0-1_amd64.deb</span> that I could
                            then install in the usual way. It installed the poker executable
                            as <span class="code">/opt/netpoker/bin/NetPoker</span>.</p>


                        <p>On MacOS 10.15, using the JDK from adoptium.net (see <a href="ch02-06-ProgrammingEnvironments.html">Subsection&nbsp;2.6.1</a>),
                            I found that <span class="code">jpackage</span> was installed as part of the
                            JDK, but it was not made available on the command-line.  I was able to define it
                            myself as an alias: </p>


                        <pre><code class="console">$ alias jpackage=
     "/Library/Java/JavaVirtualMachines/temurin-17.jdk/Contents/Home/bin/jpackage"</code></pre>


                        <p>Again, type this all on one line.  With that done, I used the same commands
                            as given above, with appropriate directory names for the JavaFX SDK and jmods.
                            The result was a .dmg file containing a program, <span class="code">netpoker.app</span>,
                            that could be run by double-clicking. (The jpackage command might be properly set up
                            in newer versions of MacOS.)</p>


                        <p>The <span class="code">jpackage</span> command should also work on Windows, but it requires
                            something called the "WiX toolset" in addition to the JDK.  I have not tried it.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch06-05-BasicLayout.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch06-07-Exercises.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch06-05-BasicLayout.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch06-07-Exercises.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </body>
</html>
