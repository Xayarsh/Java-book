<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Maps - Introduction to Programming Using Java</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

<link rel="stylesheet" href="code-class.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html" >Introduction to Programming Using Java</a></li><li class="chapter-item expanded affix "><a href="preface.html">Preface</a></li><li class="chapter-item expanded "><a href="ch01-00-Overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-FetchExecuteCycle.html"><strong aria-hidden="true">1.1.</strong> Fetch and Execute Cycle</a></li><li class="chapter-item expanded "><a href="ch01-02-AsynchronousEvents.html"><strong aria-hidden="true">1.2.</strong> Asynchronous Events</a></li><li class="chapter-item expanded "><a href="ch01-03-JavaVirtualMachine.html"><strong aria-hidden="true">1.3.</strong> The Java Virtual Machine</a></li><li class="chapter-item expanded "><a href="ch01-04-FundamentalBuildingBlocks.html"><strong aria-hidden="true">1.4.</strong> Fundamentals</a></li><li class="chapter-item expanded "><a href="ch01-05-OOP.html"><strong aria-hidden="true">1.5.</strong> Object Oriented Programming</a></li><li class="chapter-item expanded "><a href="ch01-06-ModernUserInterface.html"><strong aria-hidden="true">1.6.</strong> Modern User Interface</a></li><li class="chapter-item expanded "><a href="ch01-07-InternetAndBeyond.html"><strong aria-hidden="true">1.7.</strong> Internet and Beyond</a></li><li class="chapter-item expanded "><a href="ch01-08-Quiz.html"><strong aria-hidden="true">1.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-NameAndThings.html"><strong aria-hidden="true">2.</strong> Name and Things</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-BasicJavaApplication.html"><strong aria-hidden="true">2.1.</strong> Basic Java Application</a></li><li class="chapter-item expanded "><a href="ch02-02-VariablesAndTypes.html"><strong aria-hidden="true">2.2.</strong> Variables and Types</a></li><li class="chapter-item expanded "><a href="ch02-03-ObjectsAndSubroutines.html"><strong aria-hidden="true">2.3.</strong> Objects and Subroutines</a></li><li class="chapter-item expanded "><a href="ch02-04-TextInputAndOutput.html"><strong aria-hidden="true">2.4.</strong> Text Input and Output</a></li><li class="chapter-item expanded "><a href="ch02-05-DetailsOfExpressions.html"><strong aria-hidden="true">2.5.</strong> Details of Expressions</a></li><li class="chapter-item expanded "><a href="ch02-06-ProgrammingEnvironments.html"><strong aria-hidden="true">2.6.</strong> Programming and Environments</a></li><li class="chapter-item expanded "><a href="ch02-07-Exercises.html"><strong aria-hidden="true">2.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch02-08-Quiz.html"><strong aria-hidden="true">2.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-Control.html"><strong aria-hidden="true">3.</strong> Control</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-BlocksLoopsBranches.html"><strong aria-hidden="true">3.1.</strong> Blocks, Loops and Branches</a></li><li class="chapter-item expanded "><a href="ch03-02-AlgorithmDevelopment.html"><strong aria-hidden="true">3.2.</strong> Algorithm Development</a></li><li class="chapter-item expanded "><a href="ch03-03-While.html"><strong aria-hidden="true">3.3.</strong> while and do...while</a></li><li class="chapter-item expanded "><a href="ch03-04-For.html"><strong aria-hidden="true">3.4.</strong> The for statement</a></li><li class="chapter-item expanded "><a href="ch03-05-If.html"><strong aria-hidden="true">3.5.</strong> The If Statement</a></li><li class="chapter-item expanded "><a href="ch03-06-Switch.html"><strong aria-hidden="true">3.6.</strong> The Switch Statement</a></li><li class="chapter-item expanded "><a href="ch03-07-ExceptionsTryCatch.html"><strong aria-hidden="true">3.7.</strong> Exceptions and try...catch</a></li><li class="chapter-item expanded "><a href="ch03-08-Arrays.html"><strong aria-hidden="true">3.8.</strong> Arrays: An Introduction</a></li><li class="chapter-item expanded "><a href="ch03-09-GUI.html"><strong aria-hidden="true">3.9.</strong> GUI: An Introduction</a></li><li class="chapter-item expanded "><a href="ch03-10-Exercises.html"><strong aria-hidden="true">3.10.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch03-11-Quiz.html"><strong aria-hidden="true">3.11.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-Subroutines.html"><strong aria-hidden="true">4.</strong> Subroutines</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-BlackBoxes.html"><strong aria-hidden="true">4.1.</strong> Black Boxes</a></li><li class="chapter-item expanded "><a href="ch04-02-StaticSubroutines.html"><strong aria-hidden="true">4.2.</strong> Static Subroutines and Variables</a></li><li class="chapter-item expanded "><a href="ch04-03-Parameters.html"><strong aria-hidden="true">4.3.</strong> Parameters</a></li><li class="chapter-item expanded "><a href="ch04-04-ReturnValues.html"><strong aria-hidden="true">4.4.</strong> Return Values</a></li><li class="chapter-item expanded "><a href="ch04-05-Lambda.html"><strong aria-hidden="true">4.5.</strong> Lambda Expressions</a></li><li class="chapter-item expanded "><a href="ch04-06-APIPackagesModulesJavadoc.html"><strong aria-hidden="true">4.6.</strong> API, Packages, Modules and Javadoc</a></li><li class="chapter-item expanded "><a href="ch04-07-MoreOnProgramDesign.html"><strong aria-hidden="true">4.7.</strong> More on Program Design</a></li><li class="chapter-item expanded "><a href="ch04-08-TruthAboutDeclarations.html"><strong aria-hidden="true">4.8.</strong> Truth about Declarations</a></li><li class="chapter-item expanded "><a href="ch04-09-Exercises.html"><strong aria-hidden="true">4.9.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch04-10-Quiz.html"><strong aria-hidden="true">4.10.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-ObjectsClasses.html"><strong aria-hidden="true">5.</strong> Objects and Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-ObjectsAndInstanceMethods.html"><strong aria-hidden="true">5.1.</strong> Objects and Instance Methods</a></li><li class="chapter-item expanded "><a href="ch05-02-ConstructorObjectInit.html"><strong aria-hidden="true">5.2.</strong> Constructor and Object Initialization</a></li><li class="chapter-item expanded "><a href="ch05-03-ProgrammingWithObjects.html"><strong aria-hidden="true">5.3.</strong> Programming with Objects</a></li><li class="chapter-item expanded "><a href="ch05-04-AnExample.html"><strong aria-hidden="true">5.4.</strong> An Example</a></li><li class="chapter-item expanded "><a href="ch05-05-InheritanceAndPolymorphism.html"><strong aria-hidden="true">5.5.</strong> Inheritance and Polymorphism</a></li><li class="chapter-item expanded "><a href="ch05-06-thisandsuper.html"><strong aria-hidden="true">5.6.</strong> this and super</a></li><li class="chapter-item expanded "><a href="ch05-07-Interfaces.html"><strong aria-hidden="true">5.7.</strong> Interfaces</a></li><li class="chapter-item expanded "><a href="ch05-08-NestedClasses.html"><strong aria-hidden="true">5.8.</strong> Nested Classes</a></li><li class="chapter-item expanded "><a href="ch05-09-Exercises.html"><strong aria-hidden="true">5.9.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch05-10-Quiz.html"><strong aria-hidden="true">5.10.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-GUIProgramming.html"><strong aria-hidden="true">6.</strong> Introduction to GUI Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-BasicJavaFXApp.html"><strong aria-hidden="true">6.1.</strong> A Basic JavaFX Application</a></li><li class="chapter-item expanded "><a href="ch06-02-BasicClasses.html"><strong aria-hidden="true">6.2.</strong> Basic Classes</a></li><li class="chapter-item expanded "><a href="ch06-03-BasicEvents.html"><strong aria-hidden="true">6.3.</strong> Basic Events</a></li><li class="chapter-item expanded "><a href="ch06-04-BasicControls.html"><strong aria-hidden="true">6.4.</strong> Basic Controls</a></li><li class="chapter-item expanded "><a href="ch06-05-BasicLayout.html"><strong aria-hidden="true">6.5.</strong> Basic Layout</a></li><li class="chapter-item expanded "><a href="ch06-06-CompetePrograms.html"><strong aria-hidden="true">6.6.</strong> Complete Programs</a></li><li class="chapter-item expanded "><a href="ch06-07-Exercises.html"><strong aria-hidden="true">6.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch06-08-Quiz.html"><strong aria-hidden="true">6.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-ArraysArraylistsRecords.html"><strong aria-hidden="true">7.</strong> Arrays, ArrayLists and Records</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-ArrayDetails.html"><strong aria-hidden="true">7.1.</strong> Array Details</a></li><li class="chapter-item expanded "><a href="ch07-02-ArrayProcessing.html"><strong aria-hidden="true">7.2.</strong> Array Processing</a></li><li class="chapter-item expanded "><a href="ch07-03-ArrayLists.html"><strong aria-hidden="true">7.3.</strong> ArrayLists</a></li><li class="chapter-item expanded "><a href="ch07-04-Records.html"><strong aria-hidden="true">7.4.</strong> Records</a></li><li class="chapter-item expanded "><a href="ch07-05-SearchingAndSorting.html"><strong aria-hidden="true">7.5.</strong> Searching and Sorting</a></li><li class="chapter-item expanded "><a href="ch07-06-2DArrays.html"><strong aria-hidden="true">7.6.</strong> 2D Arrays</a></li><li class="chapter-item expanded "><a href="ch07-07-Exercises.html"><strong aria-hidden="true">7.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch07-08-Quiz.html"><strong aria-hidden="true">7.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-CorrectnessRobustnessEfficiency.html"><strong aria-hidden="true">8.</strong> Correctness, Robustness, Efficiency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-IntroductionCorrectnessandRobustness.html"><strong aria-hidden="true">8.1.</strong> Introduction to Correctness and Robustness</a></li><li class="chapter-item expanded "><a href="ch08-02-WritingCorrectPrograms.html"><strong aria-hidden="true">8.2.</strong> Writing Correct Programs</a></li><li class="chapter-item expanded "><a href="ch08-03-ExceptionsAndtrycatch.html"><strong aria-hidden="true">8.3.</strong> Exceptions and try..catch</a></li><li class="chapter-item expanded "><a href="ch08-04-AssertionsAnnotations.html"><strong aria-hidden="true">8.4.</strong> Assertions and Annotations</a></li><li class="chapter-item expanded "><a href="ch08-05-AnalysisofAlgorithms.html"><strong aria-hidden="true">8.5.</strong> Analysis of Algorithms</a></li><li class="chapter-item expanded "><a href="ch08-06-Exercises.html"><strong aria-hidden="true">8.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch08-07-Quiz.html"><strong aria-hidden="true">8.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-LinkedDataStructuresRecursion.html"><strong aria-hidden="true">9.</strong> Linked Data Structures and Recursion</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-Recursion.html"><strong aria-hidden="true">9.1.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="ch09-02-LinkedDataStructures.html"><strong aria-hidden="true">9.2.</strong> Linked Data Structures</a></li><li class="chapter-item expanded "><a href="ch09-03-StacksQueuesADTs.html"><strong aria-hidden="true">9.3.</strong> Stacks, Queues and ADTs</a></li><li class="chapter-item expanded "><a href="ch09-04-BinaryTrees.html"><strong aria-hidden="true">9.4.</strong> Binary Trees</a></li><li class="chapter-item expanded "><a href="ch09-05-SimpleRecursiveDescentParser.html"><strong aria-hidden="true">9.5.</strong> A Simple Recursive Descent Parser</a></li><li class="chapter-item expanded "><a href="ch09-06-Exercises.html"><strong aria-hidden="true">9.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch09-07-Quiz.html"><strong aria-hidden="true">9.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-GenericProgrammingandCollectionClasses.html"><strong aria-hidden="true">10.</strong> Generic Programmingand Collection Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-GenericProgramming.html"><strong aria-hidden="true">10.1.</strong> Generic Programming</a></li><li class="chapter-item expanded "><a href="ch10-02-ListsandSets.html"><strong aria-hidden="true">10.2.</strong> Lists and Sets</a></li><li class="chapter-item expanded "><a class="active" href="ch10-03-Maps.html"><strong aria-hidden="true">10.3.</strong> Maps</a></li><li class="chapter-item expanded "><a href="ch10-04-JCF.html"><strong aria-hidden="true">10.4.</strong> Programming with the JCF</a></li><li class="chapter-item expanded "><a href="ch10-05-WritingGenericClassesandMethods.html"><strong aria-hidden="true">10.5.</strong> Writing Generic Classes and Methods</a></li><li class="chapter-item expanded "><a href="ch10-06-StreamAPI.html"><strong aria-hidden="true">10.6.</strong> Stream APIs</a></li><li class="chapter-item expanded "><a href="ch10-07-Exercises.html"><strong aria-hidden="true">10.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch10-08-Quiz.html"><strong aria-hidden="true">10.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-IOStreamsFilesNetworking.html"><strong aria-hidden="true">11.</strong> I/O Streams, Files, and Networking</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-IOStreamsReadersAndWriters.html"><strong aria-hidden="true">11.1.</strong> I/O Streams, Readers, and Writers</a></li><li class="chapter-item expanded "><a href="ch11-02-Files.html"><strong aria-hidden="true">11.2.</strong> Files</a></li><li class="chapter-item expanded "><a href="ch11-03-ProgrammingWithFiles.html"><strong aria-hidden="true">11.3.</strong> Programming With Files</a></li><li class="chapter-item expanded "><a href="ch11-04-Networking.html"><strong aria-hidden="true">11.4.</strong> Networking</a></li><li class="chapter-item expanded "><a href="ch11-05-XML.html"><strong aria-hidden="true">11.5.</strong> A Brief Introduction to XML</a></li><li class="chapter-item expanded "><a href="ch11-06-Exercises.html"><strong aria-hidden="true">11.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch11-07-Quiz.html"><strong aria-hidden="true">11.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-ThreadsandMultiprocessing.html"><strong aria-hidden="true">12.</strong> Threads and Multiprocessing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-IntroductiontoThreads.html"><strong aria-hidden="true">12.1.</strong> Introduction to Threads</a></li><li class="chapter-item expanded "><a href="ch12-02-ProgrammingwithThreads.html"><strong aria-hidden="true">12.2.</strong> Programming with Threads</a></li><li class="chapter-item expanded "><a href="ch12-03-ThreadsandParallelProcessing.html"><strong aria-hidden="true">12.3.</strong> Threads and Networking</a></li><li class="chapter-item expanded "><a href="ch12-04-ThreadsandNetworking.html"><strong aria-hidden="true">12.4.</strong> Threads and Networking</a></li><li class="chapter-item expanded "><a href="ch12-05-NetworkProgrammingExample.html"><strong aria-hidden="true">12.5.</strong> Network Programming Example</a></li><li class="chapter-item expanded "><a href="ch12-06-Exercises.html"><strong aria-hidden="true">12.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch12-07-Quiz.html"><strong aria-hidden="true">12.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-GUIProgrammingContinued.html"><strong aria-hidden="true">13.</strong> GUI Programming Continued</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-PropertiesandBindings.html"><strong aria-hidden="true">13.1.</strong> Properties and Bindings</a></li><li class="chapter-item expanded "><a href="ch13-02-FancierGraphics.html"><strong aria-hidden="true">13.2.</strong> Fancier Graphics</a></li><li class="chapter-item expanded "><a href="ch13-03-ComplexComponentsandMVC.html"><strong aria-hidden="true">13.3.</strong> Complex Components and MVC</a></li><li class="chapter-item expanded "><a href="ch13-04-MostlyWindowsandDialogs.html"><strong aria-hidden="true">13.4.</strong> Mostly Windows and Dialogs</a></li><li class="chapter-item expanded "><a href="ch13-05-FinishingTouches.html"><strong aria-hidden="true">13.5.</strong> Finishing Touches</a></li><li class="chapter-item expanded "><a href="ch13-06-Exercises.html"><strong aria-hidden="true">13.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch13-07-Quiz.html"><strong aria-hidden="true">13.7.</strong> Quiz</a></li></ol><li class="chapter-item expanded "><a href="appendix-00.html"> Appendix</a></li><li class="chapter-item expanded "><a href="glossary-00.html"> Glossary</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="Java">Java</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Introduction to Programming Using Java</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Xayarsh/Java-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Maps"><a class="header" href="#Maps">Maps</a></h2>
                        <p>
                            An array of N elements can be thought of as a way
                            of associating some item with each of the integers <span class="code">0</span>, <span class="code">1</span>,
                            ...,&nbsp;<span class="code">N-1</span>. If <span class="code">i</span> is one of these integers, it's possible
                            to <span class="newword">get</span> the item associated with <span class="code">i</span>, and
                            it's possible to <span class="newword">put</span> a new item in the <span class="code">i</span>-th
                            position. These "get" and "put" operations define what it means to be an
                            array.</p>


                        <p>A <span class="newword">map</span> is a kind of generalized array. Like an
                            array, a map is defined by "get" and "put" operations. But in a map, these
                            operations are defined not for integers <span class="code">0</span>, <span class="code">1</span>,
                            ...,&nbsp;<span class="code">N-1</span>, but for arbitrary objects of some specified
                            type <span class="classname">T</span>.  Associated to these objects of type <span class="classname">T</span>
                            are objects of some possibly different type&nbsp;<span class="classname">S</span>.</p>


                        <p>In fact, some
                            programming languages use the term <span class="newword">associative array</span>
                            instead of "map" and use the same notation for associative arrays
                            as for regular arrays. In those languages, for example, you might see the
                            notation <span class="code">A["fred"]</span> used to indicate the item associated to the string
                            "fred" in an associative array&nbsp;<span class="code">A</span>. Java does not use array notation for maps,
                            unfortunately, but the idea is the same: A map is like an array, but the indices for a map
                            are objects, not integers. In a map, an object that serves as an
                            "index" is called a <span class="newword">key</span>. The object that is
                            associated with a key is called a <span class="newword">value</span>. Note that
                            a key can have at most one associated value, but the same value can be
                            associated to several different keys.  A map can be considered to be
                            a set of "associations," where each association is a key/value pair.</p>


                        <h3 id="The Map Interface"><a class="header" href="#The Map Interface">The Map Interface</a></h3>


                        <p>In Java, maps are defined by the interface <span class="code">java.util.Map</span>, which
                            includes <span class="code">put</span> and <span class="code">get</span> methods as well as other general methods
                            for working with maps.  The map interface, <span class="classname">Map&lt;K,V&gt;</span>, is
                            parameterized by <b>two</b> types.  The first type parameter, <span class="classname">K</span>,
                            specifies the type of objects that are possible keys in the map; the second type parameter,
                            <span class="classname">V</span>, specifies the type of objects that are possible values in the
                            map.  For example, a map of type <span class="classname">Map&lt;Date,Color&gt;</span>
                            would associate values of type <span class="classname">Color</span> to keys of
                            type <span class="classname">Date</span>.  For a map of type
                            <span class="classname">Map&lt;String,String&gt;</span>, both the keys and the values
                            are of type <span class="classname">String</span>.</p>


                        <p>Suppose that <span class="code">map</span> is a variable of type <span class="classname">Map&lt;K,V&gt;</span>
                            for some specific types <span class="classname">K</span> and <span class="classname">V</span>. Then
                            the following are some of the methods that are defined for <span class="code">map</span>:</p>


                        <ul>

                            <li>
                                <span class="codedef">map.get(key)</span> &mdash; returns the
                                object of type <span class="classname">V</span> that is associated by the map to the
                                <span class="code">key</span>.
                                If the map does not associate any value with <span class="code">key</span>, then
                                the return value is <span class="code">null</span>. Note that it's also possible for the return
                                value to be <span class="code">null</span> when the map explicitly associates the value
                                <span class="code">null</span> with the key. Referring to "<span class="code">map.get(key)</span>" is similar to
                                referring to "<span class="code">A[key]</span>" for an array&nbsp;<span class="code">A</span>. (But note that
                                there is nothing like an <span class="classname">IndexOutOfBoundsException</span> for maps.)</li>


                            <li>
                                <span class="codedef">map.put(key,value)</span> &mdash; Associates the
                                specified <span class="code">value</span> with the specified <span class="code">key</span>, where <span class="code">key</span>
                                must be of type <span class="classname">K</span> and <span class="code">value</span> must be of
                                type <span class="classname">V</span>. If the map already associated some other
                                value with the key, then the new value replaces the old one. This is similar to
                                the command "<span class="code">A[key]&nbsp;=&nbsp;value</span>" for an array.</li>


                            <li>
                                <span class="codedef">map.putAll(map2)</span> &mdash; if <span class="code">map2</span>
                                is another map of type <span class="classname">Map&lt;K,V&gt;</span>,
                                this copies all the associations from <span class="code">map2</span> into map.
                            </li>


                            <li>
                                <span class="codedef">map.remove(key)</span> &mdash; if <span class="code">map</span>
                                associates a value to the specified <span class="code">key</span>, that association is removed
                                from the map.</li>


                            <li>
                                <span class="codedef">map.containsKey(key)</span> &mdash; returns a
                                boolean value that is <span class="code">true</span> if the map associates some value to the
                                specified <span class="code">key</span>.</li>


                            <li>
                                <span class="codedef">map.containsValue(value)</span> &mdash; returns a
                                boolean value that is <span class="code">true</span> if the map associates the specified
                                <span class="code">value</span> to some key.</li>


                            <li>
                                <span class="codedef">map.size()</span> &mdash; returns an <span class="ptype">int</span>
                                that gives the number of key/value associations in the map.</li>


                            <li>
                                <span class="codedef">map.isEmpty()</span> &mdash; returns a boolean
                                value that is <span class="code">true</span> if the map is empty, that is if it contains no
                                associations.</li>


                            <li>
                                <span class="codedef">map.clear()</span> &mdash; removes all
                                associations from the map, leaving it empty.</li>

                        </ul>


                        <p>The <span class="code">put</span> and <span class="code">get</span> methods are certainly the most commonly
                            used of the methods in the <span class="classname">Map</span> interface. In many applications, these
                            are the only methods that are needed, and in such cases a map is really no more
                            difficult to use than a standard array.</p>


                        <p>Java includes two classes that implement the interface <span class="classname">Map&lt;K,V&gt;</span>:
                            <span class="classname">TreeMap&lt;K,V&gt;</span> and <span class="classname">HashMap&lt;K,V&gt;</span>.
                            In a <span class="classname">TreeMap</span>, the key/value
                            associations are stored in a sorted tree, in which they are sorted according to
                            their <span class="code">keys</span>. For this to work, it must be possible to compare the keys
                            to one another. This means either that the keys must implement the interface
                            <span class="classname">Comparable&lt;K&gt;</span>, or that a <span class="classname">Comparator</span> must be provided
                            for comparing keys. (The <span class="classname">Comparator</span> can be provided as a parameter to
                            the <span class="classname">TreeMap</span> constructor.)  Note that in a <span class="classname">TreeMap</span>,
                            as in a <span class="classname">TreeSet</span>, the <span class="code">compareTo()</span> (or <span class="code">compare()</span>) method is used
                            to decide whether two keys are to be considered the same.  This can have undesirable
                            consequences if the comparison method does not agree with the usual
                            notion of equality, and you should keep this in mind when using <span class="classname">TreeMaps</span>.</p>


                        <p>A <span class="classname">HashMap</span> does not store associations in any particular order, so
                            the keys that can be used in a <span class="classname">HashMap</span> do not have to be comparable.
                            However, the key class should have reasonable definitions for the <span class="code">equals()</span> method
                            and for a <span class="code">hashCode()</span> method that is discussed later in this section; most of Java's
                            standard classes define these methods correctly.
                            Most operations are a little faster on <span class="classname">HashMaps</span> than they are on
                            <span class="classname">TreeMaps</span>. In general, you should use a <span class="classname">HashMap</span> unless you
                            have some particular need for the ordering property of a <span class="classname">TreeMap</span>. In
                            particular, if you are only using the <span class="code">put</span> and <span class="code">get</span> operations,
                            you can safely use a <span class="classname">HashMap</span>.</p>


                        <p>Let's consider an example where maps would be useful. In <a href="ch07-05-SearchingAndSorting.html">Subsection&nbsp;7.5.2</a>, I
                            presented a simple <span class="classname">PhoneDirectory</span> class that associated phone numbers
                            with names. That class defined operations <span class="code">addEntry(name,number)</span> and
                            <span class="code">getNumber(name)</span>, where both <span class="code">name</span> and <span class="code">number</span> are
                            given as <span class="classname">Strings</span>. In fact, the phone directory is acting just like a
                            map, with the <span class="code">addEntry</span> method playing the role of the <span class="code">put</span>
                            operation and <span class="code">getNumber</span> playing the role of <span class="code">get</span>. In a real
                            programming application, there would be no need to define a new class; we could
                            simply use a map of type <span class="classname">Map&lt;String,String&gt;</span>. A directory
                            could be defined as</p>


                        <pre><code class="java">Map&lt;String,String&gt; directory = new TreeMap&lt;&gt;();</code></pre>


                        <p>(using <span class="classname">TreeMap</span> so that the entries are kept in sorted order by name).
                            Then <span class="code">directory.put(name,number)</span> would record a phone number
                            in the directory and <span class="code">directory.get(name)</span> would retrieve the phone number
                            associated with a given name.</p>


                        <h3 id="Views, SubSets, and SubMaps"><a class="header" href="#Views, SubSets, and SubMaps">Views, SubSets, and SubMaps</a></h3>

                        <p>A <span class="classname">Map</span> is not a <span class="classname">Collection</span>, and maps do not implement all
                            the operations defined on collections. In particular, there are no iterators
                            for maps. Sometimes, though, it's useful to be able to iterate through all the
                            associations in a map. Java makes this possible in a roundabout but clever
                            way. If <span class="code">map</span> is a variable of type <span class="classname">Map&lt;K,V&gt;</span>, then the method</p>


                        <pre><code class="java">map.keySet()</code></pre>


                        <p>returns the set of all objects that occur as keys for associations in the
                            map. The value returned by this method is an object that implements the interface
                            <span class="classname">Set&lt;K&gt;</span>. The elements of this set are the map's keys. The obvious way to
                            implement the <span class="code">keySet()</span> method would be to create a new set object, add
                            all the keys from the map, and return that set. But that's not how it's done.
                            The value returned by <span class="code">map.keySet()</span> is not an independent object. It is
                            what is called a <span class="newword">view</span> of the actual objects that are stored
                            in the map. This "view" of the map implements the <span class="classname">Set&lt;K&gt;</span> interface, but
                            it does it in such a way that the methods defined in the interface refer
                            directly to keys in the map. For example, if you remove a key from the view,
                            that key&mdash;along with its associated value&mdash;is actually removed from the
                            map. It's not legal to add an object to the view, since it doesn't make sense
                            to add a key to a map without specifying the value that should be associated to
                            the key. Since <span class="code">map.keySet()</span> does not create a new set, it's very
                            efficient, even for very large maps.</p>


                        <p>One of the things that you can do with a <span class="classname">Set</span> is get an
                            <span class="classname">Iterator</span> for it and use the iterator to visit each of the elements of
                            the set in turn. We can use an iterator for the key set of a map to traverse
                            the map. For example, if <span class="code">map</span> is of type <span class="classname">Map&lt;String,Double&gt;</span>,
                            we could write:</p>


                        <pre><code class="java">Set&lt;String&gt; keys = map.keySet();     // The set of keys in the map.
Iterator&lt;String&gt; keyIter = keys.iterator();
System.out.println("The map contains the following associations:");
while (keyIter.hasNext()) {
   String key = keyIter.next();  // Get the next key.
   Double value = map.get(key);  // Get the value for that key.
   System.out.println( "   (" + key + "," + value + ")" );
}</code></pre>


                        <p>Or we could do the same thing more easily, avoiding the explicit use of an iterator,
                            with a for-each loop:</p>


                        <pre><code class="java">System.out.println("The map contains the following associations:");
for ( String key : map.keySet() ) {  // "for each key in the map's key set"
    Double value = map.get(key);
    System.out.println( "   (" + key + "," + value + ")" );
}</code></pre>



                        <p>If the map is a <span class="classname">TreeMap</span>, then the key set of the map is a sorted
                            set, and the iterator will visit the keys in ascending order.  For a <span class="classname">HashMap</span>,
                            the keys are visited in an arbitrary, unpredictable order.</p>


                        <p>The <span class="classname">Map</span> interface defines two other views. If <span class="code">map</span> is a
                            variable of type <span class="classname">Map&lt;K,V&gt;</span>, then the method:</p>


                        <pre><code class="java">map.values()</code></pre>


                        <p>returns an object of type <span class="classname">Collection&lt;V&gt;</span>
                            that contains all the values from the
                            associations that are stored in the map. The return value is a
                            <span class="classname">Collection</span> rather than a <span class="classname">Set</span> because it can contain duplicate
                            elements (since a map can associate the same value to any number of keys). The
                            method:</p>


                        <pre><code class="java">map.entrySet()</code></pre>


                        <p>returns a set that contains all the associations from the map.  The
                            elements in the set are objects of type <span class="classname">Map.Entry&lt;K,V&gt;</span>.
                            <span class="classname">Map.Entry&lt;K,V&gt;</span> is defined as a static nested interface
                            inside the interface <span class="classname">Map&lt;K,V&gt;</span>, so
                            its full name contains a period. However, the name can be used in the same way as
                            any other type name.  (The return type
                            of the method <span class="code">map.entrySet()</span> is written as
                            <span class="classname">Set&lt;Map.Entry&lt;K,V&gt;&gt;</span>.  The type parameter
                            in this case is itself a parameterized type.  Although this might look
                            confusing, it's just Java's way of saying that the elements of the
                            set are of type <span class="classname">Map.Entry&lt;K,V&gt;</span>.)
                            The information in the set returned by <span class="code">map.entrySet()</span>
                            is actually no different from the information in the
                            map itself, but the set provides a different view of this information, with
                            different operations. Each <span class="code">Map.Entry</span>
                            object contains one key/value pair, and defines methods <span class="code">getKey()</span> and
                            <span class="code">getValue()</span> for retrieving the key and the value. There is also a
                            method, <span class="code">setValue(value)</span>, for setting the value; calling this
                            method for a <span class="code">Map.Entry</span> object will modify the map itself,
                            just as if the map's <span class="code">put</span> method were called.
                            As an example, we can use the entry
                            set of a map to print all the key/value pairs in the map. This is more efficient than
                            using the key set to print the same information, as I did in the above example,
                            since we don't have to use the <span class="code">get()</span> method to look up the value associated with each key.
                            Suppose again that <span class="code">map</span> is of type <span class="classname">Map&lt;String,Double&gt;</span>.
                            Then we can write:</p>


                        <pre><code class="java">Set&lt;Map.Entry&lt;String,Double&gt;&gt; entries = map.entrySet();
Iterator&lt;Map.Entry&lt;String,Double&gt;&gt; entryIter = entries.iterator();
System.out.println("The map contains the following associations:");
while (entryIter.hasNext()) {
   Map.Entry&lt;String,Double&gt; entry = entryIter.next();
   String key = entry.getKey();  // Get the key from the entry.
   Double value = entry.getValue();  // Get the value.
   System.out.println( "   (" + key + "," + value + ")" );
}</code></pre>


                        <p>or, using a for-each loop to avoid some of the ugly type names:</p>


                        <pre><code class="java">System.out.println("The map contains the following associations:");
for ( Map.Entry&lt;String,Double&gt; entry : map.entrySet() ) {
   System.out.println( "   (" + entry.getKey() + "," + entry.getValue() + ")" );
}</code></pre>


                        <p>This is certainly a place where it would be convenient to use <span class="code">var</span>
                            to declare the variables (See <a href="ch04-08-TruthAboutDeclarations.html">Subsection&nbsp;4.8.2</a>).  With <span class="code">var</span>,
                            the example using an iterator becomes:
                        </p>


                        <pre><code class="java">
<span class="newcode">var</span> entries = map.entrySet();
<span class="newcode">var</span> entryIter = entries.iterator();
System.out.println("The map contains the following associations:");
while (entryIter.hasNext()) { . . .</code></pre>



                        <p>Maps are not the only place in Java's generic programming framework where
                            views are used. For example, the interface <span class="classname">List&lt;T&gt;</span> defines a
                            <span class="newword">sublist</span> as a view of a part of a list. If <span class="code">list</span>
                            implements the interface <span class="classname">List&lt;T&gt;</span>, then
                            the method</p>


                        <pre><code class="java">list.subList( fromIndex, toIndex )</code></pre>


                        <p>where <span class="code">fromIndex</span> and <span class="code">toIndex</span> are integers,
                            returns a view of the part of the list consisting of the list elements in
                            positions between <span class="code">fromIndex</span> and <span class="code">toIndex</span> (including
                            <span class="code">fromIndex</span> but excluding <span class="code">toIndex</span>). This view lets you operate
                            on the sublist using any of the operations defined for lists, but the sublist
                            is not an independent list. Changes made to the sublist are actually  made
                            to the original list.</p>


                        <p>Similarly, it is possible to obtain views that represent certain subsets of
                            a sorted set. If <span class="code">set</span> is of type <span class="classname">TreeSet&lt;T&gt;</span>, then
                            <span class="code">set.subSet(fromElement,toElement)</span> returns a <span class="classname">Set&lt;T&gt;</span> that contains
                            all the elements of <span class="code">set</span> that are between <span class="code">fromElement</span> and
                            <span class="code">toElement</span> (including <span class="code">fromElement</span> and excluding
                            <span class="code">toElement</span>).  The parameters <span class="code">fromElement</span> and <span class="code">toElement</span>
                            must be objects of type&nbsp;<span class="classname">T</span>.
                            For example, if <span class="code">words</span> is a set of type <span class="classname">TreeSet&lt;String&gt;</span> in
                            which all the elements are strings of lower case letters, then
                            <span class="code">words.subSet("m","n")</span> contains all the elements of <span class="code">words</span> that
                            begin with the letter&nbsp;'m'. This subset is a view of part of the original set.
                            That is, creating the subset does not involve copying elements. And changes
                            made to the subset, such as adding or removing elements, are actually made to
                            the original set. The view <span class="code">set.headSet(toElement)</span> consists of all
                            elements from the set which are strictly less than <span class="code">toElement</span>, and
                            <span class="code">set.tailSet(fromElement)</span> is a view that contains all elements from the
                            set that are greater than or equal to <span class="code">fromElement</span>.</p>


                        <p>The class <span class="classname">TreeMap&lt;K,V&gt;</span> defines three submap views. A submap is similar
                            to a subset. A submap is a <span class="classname">Map</span> that contains a subset of the keys from
                            the original <span class="classname">Map</span>, along with their associated values. If <span class="code">map</span>
                            is a variable of type <span class="classname">TreeMap&lt;K,V&gt;</span>, and if <span class="code">fromKey</span>
                            and <span class="code">toKey</span> are of type&nbsp;<span class="classname">K</span>,
                            then <span class="code">map.subMap(fromKey,toKey)</span>
                            returns a view that contains all key/value pairs from <span class="code">map</span> whose keys
                            are between <span class="code">fromKey</span> and <span class="code">toKey</span> (including <span class="code">fromKey</span> and
                            excluding <span class="code">toKey</span>). There are also views <span class="code">map.headMap(toKey)</span> and
                            <span class="code">map.tailMap(fromKey)</span> which are defined analogously to <span class="code">headSet</span>
                            and <span class="code">tailSet</span>. Suppose,
                            for example, that <span class="code">phoneBook</span> is a map of type
                            <span class="classname">TreeMap&lt;String,String&gt;</span> in which the keys
                            are names and the values are phone numbers. We can print out all the entries
                            from <span class="code">phoneBook</span> where the name begins with "M" as follows:</p>


                        <pre><code class="java">Map&lt;String,String&gt; ems = phoneBook.subMap("M","N");
     // This submap contains entries for which the key is greater
     // than or equal to "M" and strictly less than "N".

if (ems.isEmpty()) {
   System.out.println("No entries beginning with M.");
}
else {
   System.out.println("Entries beginning with M:");
   for ( var entry : ems.entrySet() ) {
         // Note: type for entry is Map.Entry&lt;String,String&gt;
         // but it's easier to user var to declare the variable!
      System.out.println( "   " + entry.getKey() + ": " + entry.getValue() );
   }
}</code></pre>


                        <p>Subsets and submaps are probably best thought of as generalized search
                            operations that make it possible to find all the items in a range of values,
                            rather than just to find a single value. For example, suppose that a database
                            of scheduled events is stored in a map of type <span class="classname">TreeMap&lt;DateTime,Event&gt;</span>
                            in which the a key gives the date and
                            time of an event, and suppose you want a listing of all events that are
                            scheduled for some time on July 4, 2022. Just make a submap containing all keys
                            in the range from 12:00 AM, July 4, 2022 to 12:00 AM, July 5, 2022, and output
                            all the entries from that submap. This type of search, which is known as a
                            <span class="newword">subrange query</span>, is quite common.</p>


                        <h3 id="Hash Tables and Hash Codes"><a class="header" href="#Hash Tables and Hash Codes">Hash Tables and Hash Codes</a></h3>

                        <p>
                            <span class="classname">HashSets</span> and <span class="classname">HashMaps</span> are implemented using a data
                            structure known as a <span class="newword">hash table</span>. You don't need to
                            understand hash tables to use <span class="classname">HashSets</span> or <span class="classname">HashMaps</span>, but any
                            computer programmer should be familiar with hash tables and how they work.</p>


                        <p>Hash tables are an elegant solution to the search problem. A hash table,
                            like a <span class="classname">HashMap</span>, stores key/value pairs. Given a key, you have to
                            search the table for the corresponding key/value pair. When a hash table is
                            used to implement a set, there are no values, and the only question is
                            whether or not the key occurs in the set. You still have to search for the key
                            to check whether it is there or not.</p>


                        <p>In most search algorithms, in order to find the item you are interested in,
                            you have to look through a bunch of other items that don't interest you. To
                            find something in an unsorted list, you have to go through the items one-by-one
                            until you come to the one you are looking for. In a binary sort tree, you have
                            to start at the root and move down the tree until you find the item you want.
                            When you search for a key/value pair in a hash table, you can go directly to
                            the location that contains the item you want. You don't have to look through
                            any other items. (This is not quite true, but if the hash table is working properly,
                            it's close.) The location of the
                            key/value pair is computed from the key: You just look at the key, and then you
                            go directly to the location where it is stored.</p>


                        <p>How can this work? If the keys were integers in the range 0 to 99, we could
                            store the key/value pairs in an array, <span class="code">A</span>, of 100 elements. The
                            key/value pair with key <span class="code">K</span> would be stored in <span class="code">A[K]</span>. The key
                            takes us directly to the location of the key/value pair. The problem is that
                            there are usually far too many different possible keys for us to be able to use
                            an array with one location for each possible key. For example, if the key can
                            be any value of type <span class="ptype">int</span>, then we would need an array with over four
                            billion locations&mdash;quite a waste of space if we are only going to store, say,
                            a few thousand items! If the key can be a string of any length, then the number
                            of possible keys is infinite, and using an array with one location for each
                            possible key is simply impossible.</p>


                        <p>Nevertheless, hash tables store their data in an array, and the array index
                            where a key is stored is based on the key. The index is not equal to the key,
                            but it is computed from the key. The array index for a key is called the
                            <span class="newword">hash code</span> for that key. A function that computes a
                            hash code, given a key, is called a <span class="newword">hash function</span>.
                            To find a key in a hash table, you just have to compute the hash code of the
                            key and go directly to the array location given by that hash code. If the hash
                            code is 17, look in array location number 17.</p>


                        <p>Now, since there are fewer array locations than there are possible keys,
                            it's possible that we might try to store two or more keys in the same array
                            location. This is called a <span class="newword">collision</span>. A collision
                            is not an error. We can't reject a key just because another key happened to
                            have the same hash code. A hash table must be able to handle collisions in some
                            reasonable way. In the type of hash table that is used in Java, each array
                            location actually holds a linked list of key/value pairs (possibly an empty
                            list). When two items have the same hash code, they are in the same linked
                            list. The structure of the hash table looks something like this:</p>


                        <p align="center">
                            <img src="./images/hash-table.png" width="366" height="324" alt="hash table"></p>



                        <p>In this diagram, there are two items with hash code 0, no items with hash code
                            1, one item with hash code 2, and so on. In a properly designed hash table,
                            most of the linked lists are of length zero or one, and the average length of
                            the lists is less than one. Although the hash code of a key doesn't necessarily
                            take you directly to that key, there are probably no more than one or two other
                            items that you have to look through before finding the key you want. For this
                            to work properly, the number of items in the hash table should be somewhat less
                            than the number of locations in the array. In Java's implementation, whenever
                            the number of items exceeds 75% of the array size, the array is replaced by a
                            larger one and all the items in the old array are inserted into the new
                            one. (This is why adding one new item will sometimes cause the ordering of all
                            the items in the hash table to change completely.)</p>


                        <p>There is still the question of where hash codes come from.  Every object in
                            Java has a hash code.
                            The <span class="classname">Object</span> class defines the method <span class="code">hashCode()</span>, which
                            returns a value of type <span class="ptype">int</span>.  When an object, <span class="code">obj</span>, is stored
                            in a hash table that has <span class="code">N</span> locations, a hash code in the range
                            <span class="code">0</span> to <span class="code">N-1</span> is needed. This hash code is computed as
                            <span class="code">Math.abs(obj.hashCode())&nbsp;%&nbsp;N</span>, the remainder when the absolute value of
                            <span class="code">obj.hashCode()</span> is divided by <span class="code">N</span>. (The <span class="code">Math.abs</span> is
                            necessary because <span class="code">obj.hashCode()</span> can be a negative integer, and we
                            need a non-negative number to use as an array index.)</p>


                        <p>For hashing to work properly, two objects that are equal according to the
                            <span class="code">equals()</span> method must have the same hash code. In the <span class="classname">Object</span>
                            class, this condition is satisfied because
                            both <span class="code">equals()</span> and <span class="code">hashCode()</span> are based on the address
                            of the memory location where the object is stored.
                            However, as noted in
                            <a href="ch10-01-GenericProgramming.html">Subsection&nbsp;10.1.6</a>, many classes redefine the <span class="code">equals()</span>
                            method. If a class redefines the <span class="code">equals()</span> method, and if objects of
                            that class will be used as keys in hash tables, then the class must also
                            redefine the <span class="code">hashCode()</span> method. For example, in the <span class="classname">String</span>
                            class, the <span class="code">equals()</span> method is redefined so that two objects of type
                            <span class="classname">String</span> are considered to be equal if they contain the same sequence of
                            characters. The <span class="code">hashCode()</span> method is also redefined in the
                            <span class="classname">String</span> class, so that the hash code of a string is computed from the
                            characters in that string rather than from its location in memory. For Java's
                            standard classes, you can expect <span class="code">equals()</span> and <span class="code">hashCode()</span> to
                            be correctly defined. However, you might need to define these methods in
                            classes that you write yourself.</p>


                        <p>Writing a good hash function is something of an art.  In order to work well, the hash
                            function must spread the possible keys fairly evenly over the hash table.  Otherwise,
                            the items in a table can be concentrated in a subset of the available locations, and the
                            linked lists at those locations can grow to a large size; that would destroy the efficiency
                            that is the major reason for hash tables to exist in the first place.  However, I won't
                            cover techniques for creating good hash functions in this book.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch10-02-ListsandSets.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch10-04-JCF.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch10-02-ListsandSets.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch10-04-JCF.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </body>
</html>
