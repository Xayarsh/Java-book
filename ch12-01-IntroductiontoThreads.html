<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Introduction to Threads - Introduction to Programming Using Java</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

<link rel="stylesheet" href="code-class.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html" >Introduction to Programming Using Java</a></li><li class="chapter-item expanded affix "><a href="preface.html">Preface</a></li><li class="chapter-item expanded "><a href="ch01-00-Overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-FetchExecuteCycle.html"><strong aria-hidden="true">1.1.</strong> Fetch and Execute Cycle</a></li><li class="chapter-item expanded "><a href="ch01-02-AsynchronousEvents.html"><strong aria-hidden="true">1.2.</strong> Asynchronous Events</a></li><li class="chapter-item expanded "><a href="ch01-03-JavaVirtualMachine.html"><strong aria-hidden="true">1.3.</strong> The Java Virtual Machine</a></li><li class="chapter-item expanded "><a href="ch01-04-FundamentalBuildingBlocks.html"><strong aria-hidden="true">1.4.</strong> Fundamentals</a></li><li class="chapter-item expanded "><a href="ch01-05-OOP.html"><strong aria-hidden="true">1.5.</strong> Object Oriented Programming</a></li><li class="chapter-item expanded "><a href="ch01-06-ModernUserInterface.html"><strong aria-hidden="true">1.6.</strong> Modern User Interface</a></li><li class="chapter-item expanded "><a href="ch01-07-InternetAndBeyond.html"><strong aria-hidden="true">1.7.</strong> Internet and Beyond</a></li><li class="chapter-item expanded "><a href="ch01-08-Quiz.html"><strong aria-hidden="true">1.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-NameAndThings.html"><strong aria-hidden="true">2.</strong> Name and Things</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-BasicJavaApplication.html"><strong aria-hidden="true">2.1.</strong> Basic Java Application</a></li><li class="chapter-item expanded "><a href="ch02-02-VariablesAndTypes.html"><strong aria-hidden="true">2.2.</strong> Variables and Types</a></li><li class="chapter-item expanded "><a href="ch02-03-ObjectsAndSubroutines.html"><strong aria-hidden="true">2.3.</strong> Objects and Subroutines</a></li><li class="chapter-item expanded "><a href="ch02-04-TextInputAndOutput.html"><strong aria-hidden="true">2.4.</strong> Text Input and Output</a></li><li class="chapter-item expanded "><a href="ch02-05-DetailsOfExpressions.html"><strong aria-hidden="true">2.5.</strong> Details of Expressions</a></li><li class="chapter-item expanded "><a href="ch02-06-ProgrammingEnvironments.html"><strong aria-hidden="true">2.6.</strong> Programming and Environments</a></li><li class="chapter-item expanded "><a href="ch02-07-Exercises.html"><strong aria-hidden="true">2.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch02-08-Quiz.html"><strong aria-hidden="true">2.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-Control.html"><strong aria-hidden="true">3.</strong> Control</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-BlocksLoopsBranches.html"><strong aria-hidden="true">3.1.</strong> Blocks, Loops and Branches</a></li><li class="chapter-item expanded "><a href="ch03-02-AlgorithmDevelopment.html"><strong aria-hidden="true">3.2.</strong> Algorithm Development</a></li><li class="chapter-item expanded "><a href="ch03-03-While.html"><strong aria-hidden="true">3.3.</strong> while and do...while</a></li><li class="chapter-item expanded "><a href="ch03-04-For.html"><strong aria-hidden="true">3.4.</strong> The for statement</a></li><li class="chapter-item expanded "><a href="ch03-05-If.html"><strong aria-hidden="true">3.5.</strong> The If Statement</a></li><li class="chapter-item expanded "><a href="ch03-06-Switch.html"><strong aria-hidden="true">3.6.</strong> The Switch Statement</a></li><li class="chapter-item expanded "><a href="ch03-07-ExceptionsTryCatch.html"><strong aria-hidden="true">3.7.</strong> Exceptions and try...catch</a></li><li class="chapter-item expanded "><a href="ch03-08-Arrays.html"><strong aria-hidden="true">3.8.</strong> Arrays: An Introduction</a></li><li class="chapter-item expanded "><a href="ch03-09-GUI.html"><strong aria-hidden="true">3.9.</strong> GUI: An Introduction</a></li><li class="chapter-item expanded "><a href="ch03-10-Exercises.html"><strong aria-hidden="true">3.10.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch03-11-Quiz.html"><strong aria-hidden="true">3.11.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-Subroutines.html"><strong aria-hidden="true">4.</strong> Subroutines</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-BlackBoxes.html"><strong aria-hidden="true">4.1.</strong> Black Boxes</a></li><li class="chapter-item expanded "><a href="ch04-02-StaticSubroutines.html"><strong aria-hidden="true">4.2.</strong> Static Subroutines and Variables</a></li><li class="chapter-item expanded "><a href="ch04-03-Parameters.html"><strong aria-hidden="true">4.3.</strong> Parameters</a></li><li class="chapter-item expanded "><a href="ch04-04-ReturnValues.html"><strong aria-hidden="true">4.4.</strong> Return Values</a></li><li class="chapter-item expanded "><a href="ch04-05-Lambda.html"><strong aria-hidden="true">4.5.</strong> Lambda Expressions</a></li><li class="chapter-item expanded "><a href="ch04-06-APIPackagesModulesJavadoc.html"><strong aria-hidden="true">4.6.</strong> API, Packages, Modules and Javadoc</a></li><li class="chapter-item expanded "><a href="ch04-07-MoreOnProgramDesign.html"><strong aria-hidden="true">4.7.</strong> More on Program Design</a></li><li class="chapter-item expanded "><a href="ch04-08-TruthAboutDeclarations.html"><strong aria-hidden="true">4.8.</strong> Truth about Declarations</a></li><li class="chapter-item expanded "><a href="ch04-09-Exercises.html"><strong aria-hidden="true">4.9.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch04-10-Quiz.html"><strong aria-hidden="true">4.10.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-ObjectsClasses.html"><strong aria-hidden="true">5.</strong> Objects and Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-ObjectsAndInstanceMethods.html"><strong aria-hidden="true">5.1.</strong> Objects and Instance Methods</a></li><li class="chapter-item expanded "><a href="ch05-02-ConstructorObjectInit.html"><strong aria-hidden="true">5.2.</strong> Constructor and Object Initialization</a></li><li class="chapter-item expanded "><a href="ch05-03-ProgrammingWithObjects.html"><strong aria-hidden="true">5.3.</strong> Programming with Objects</a></li><li class="chapter-item expanded "><a href="ch05-04-AnExample.html"><strong aria-hidden="true">5.4.</strong> An Example</a></li><li class="chapter-item expanded "><a href="ch05-05-InheritanceAndPolymorphism.html"><strong aria-hidden="true">5.5.</strong> Inheritance and Polymorphism</a></li><li class="chapter-item expanded "><a href="ch05-06-thisandsuper.html"><strong aria-hidden="true">5.6.</strong> this and super</a></li><li class="chapter-item expanded "><a href="ch05-07-Interfaces.html"><strong aria-hidden="true">5.7.</strong> Interfaces</a></li><li class="chapter-item expanded "><a href="ch05-08-NestedClasses.html"><strong aria-hidden="true">5.8.</strong> Nested Classes</a></li><li class="chapter-item expanded "><a href="ch05-09-Exercises.html"><strong aria-hidden="true">5.9.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch05-10-Quiz.html"><strong aria-hidden="true">5.10.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-GUIProgramming.html"><strong aria-hidden="true">6.</strong> Introduction to GUI Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-BasicJavaFXApp.html"><strong aria-hidden="true">6.1.</strong> A Basic JavaFX Application</a></li><li class="chapter-item expanded "><a href="ch06-02-BasicClasses.html"><strong aria-hidden="true">6.2.</strong> Basic Classes</a></li><li class="chapter-item expanded "><a href="ch06-03-BasicEvents.html"><strong aria-hidden="true">6.3.</strong> Basic Events</a></li><li class="chapter-item expanded "><a href="ch06-04-BasicControls.html"><strong aria-hidden="true">6.4.</strong> Basic Controls</a></li><li class="chapter-item expanded "><a href="ch06-05-BasicLayout.html"><strong aria-hidden="true">6.5.</strong> Basic Layout</a></li><li class="chapter-item expanded "><a href="ch06-06-CompetePrograms.html"><strong aria-hidden="true">6.6.</strong> Complete Programs</a></li><li class="chapter-item expanded "><a href="ch06-07-Exercises.html"><strong aria-hidden="true">6.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch06-08-Quiz.html"><strong aria-hidden="true">6.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-ArraysArraylistsRecords.html"><strong aria-hidden="true">7.</strong> Arrays, ArrayLists and Records</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-ArrayDetails.html"><strong aria-hidden="true">7.1.</strong> Array Details</a></li><li class="chapter-item expanded "><a href="ch07-02-ArrayProcessing.html"><strong aria-hidden="true">7.2.</strong> Array Processing</a></li><li class="chapter-item expanded "><a href="ch07-03-ArrayLists.html"><strong aria-hidden="true">7.3.</strong> ArrayLists</a></li><li class="chapter-item expanded "><a href="ch07-04-Records.html"><strong aria-hidden="true">7.4.</strong> Records</a></li><li class="chapter-item expanded "><a href="ch07-05-SearchingAndSorting.html"><strong aria-hidden="true">7.5.</strong> Searching and Sorting</a></li><li class="chapter-item expanded "><a href="ch07-06-2DArrays.html"><strong aria-hidden="true">7.6.</strong> 2D Arrays</a></li><li class="chapter-item expanded "><a href="ch07-07-Exercises.html"><strong aria-hidden="true">7.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch07-08-Quiz.html"><strong aria-hidden="true">7.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-CorrectnessRobustnessEfficiency.html"><strong aria-hidden="true">8.</strong> Correctness, Robustness, Efficiency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-IntroductionCorrectnessandRobustness.html"><strong aria-hidden="true">8.1.</strong> Introduction to Correctness and Robustness</a></li><li class="chapter-item expanded "><a href="ch08-02-WritingCorrectPrograms.html"><strong aria-hidden="true">8.2.</strong> Writing Correct Programs</a></li><li class="chapter-item expanded "><a href="ch08-03-ExceptionsAndtrycatch.html"><strong aria-hidden="true">8.3.</strong> Exceptions and try..catch</a></li><li class="chapter-item expanded "><a href="ch08-04-AssertionsAnnotations.html"><strong aria-hidden="true">8.4.</strong> Assertions and Annotations</a></li><li class="chapter-item expanded "><a href="ch08-05-AnalysisofAlgorithms.html"><strong aria-hidden="true">8.5.</strong> Analysis of Algorithms</a></li><li class="chapter-item expanded "><a href="ch08-06-Exercises.html"><strong aria-hidden="true">8.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch08-07-Quiz.html"><strong aria-hidden="true">8.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-LinkedDataStructuresRecursion.html"><strong aria-hidden="true">9.</strong> Linked Data Structures and Recursion</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-Recursion.html"><strong aria-hidden="true">9.1.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="ch09-02-LinkedDataStructures.html"><strong aria-hidden="true">9.2.</strong> Linked Data Structures</a></li><li class="chapter-item expanded "><a href="ch09-03-StacksQueuesADTs.html"><strong aria-hidden="true">9.3.</strong> Stacks, Queues and ADTs</a></li><li class="chapter-item expanded "><a href="ch09-04-BinaryTrees.html"><strong aria-hidden="true">9.4.</strong> Binary Trees</a></li><li class="chapter-item expanded "><a href="ch09-05-SimpleRecursiveDescentParser.html"><strong aria-hidden="true">9.5.</strong> A Simple Recursive Descent Parser</a></li><li class="chapter-item expanded "><a href="ch09-06-Exercises.html"><strong aria-hidden="true">9.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch09-07-Quiz.html"><strong aria-hidden="true">9.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-GenericProgrammingandCollectionClasses.html"><strong aria-hidden="true">10.</strong> Generic Programmingand Collection Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-GenericProgramming.html"><strong aria-hidden="true">10.1.</strong> Generic Programming</a></li><li class="chapter-item expanded "><a href="ch10-02-ListsandSets.html"><strong aria-hidden="true">10.2.</strong> Lists and Sets</a></li><li class="chapter-item expanded "><a href="ch10-03-Maps.html"><strong aria-hidden="true">10.3.</strong> Maps</a></li><li class="chapter-item expanded "><a href="ch10-04-JCF.html"><strong aria-hidden="true">10.4.</strong> Programming with the JCF</a></li><li class="chapter-item expanded "><a href="ch10-05-WritingGenericClassesandMethods.html"><strong aria-hidden="true">10.5.</strong> Writing Generic Classes and Methods</a></li><li class="chapter-item expanded "><a href="ch10-06-StreamAPI.html"><strong aria-hidden="true">10.6.</strong> Stream APIs</a></li><li class="chapter-item expanded "><a href="ch10-07-Exercises.html"><strong aria-hidden="true">10.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch10-08-Quiz.html"><strong aria-hidden="true">10.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-IOStreamsFilesNetworking.html"><strong aria-hidden="true">11.</strong> I/O Streams, Files, and Networking</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-IOStreamsReadersAndWriters.html"><strong aria-hidden="true">11.1.</strong> I/O Streams, Readers, and Writers</a></li><li class="chapter-item expanded "><a href="ch11-02-Files.html"><strong aria-hidden="true">11.2.</strong> Files</a></li><li class="chapter-item expanded "><a href="ch11-03-ProgrammingWithFiles.html"><strong aria-hidden="true">11.3.</strong> Programming With Files</a></li><li class="chapter-item expanded "><a href="ch11-04-Networking.html"><strong aria-hidden="true">11.4.</strong> Networking</a></li><li class="chapter-item expanded "><a href="ch11-05-XML.html"><strong aria-hidden="true">11.5.</strong> A Brief Introduction to XML</a></li><li class="chapter-item expanded "><a href="ch11-06-Exercises.html"><strong aria-hidden="true">11.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch11-07-Quiz.html"><strong aria-hidden="true">11.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-ThreadsandMultiprocessing.html"><strong aria-hidden="true">12.</strong> Threads and Multiprocessing</a></li><li><ol class="section"><li class="chapter-item expanded "><a class="active" href="ch12-01-IntroductiontoThreads.html"><strong aria-hidden="true">12.1.</strong> Introduction to Threads</a></li><li class="chapter-item expanded "><a href="ch12-02-ProgrammingwithThreads.html"><strong aria-hidden="true">12.2.</strong> Programming with Threads</a></li><li class="chapter-item expanded "><a href="ch12-03-ThreadsandParallelProcessing.html"><strong aria-hidden="true">12.3.</strong> Threads and Parallel Processing</a></li><li class="chapter-item expanded "><a href="ch12-04-ThreadsandNetworking.html"><strong aria-hidden="true">12.4.</strong> Threads and Networking</a></li><li class="chapter-item expanded "><a href="ch12-05-NetworkProgrammingExample.html"><strong aria-hidden="true">12.5.</strong> Network Programming Example</a></li><li class="chapter-item expanded "><a href="ch12-06-Exercises.html"><strong aria-hidden="true">12.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch12-07-Quiz.html"><strong aria-hidden="true">12.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-GUIProgrammingContinued.html"><strong aria-hidden="true">13.</strong> GUI Programming Continued</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-PropertiesandBindings.html"><strong aria-hidden="true">13.1.</strong> Properties and Bindings</a></li><li class="chapter-item expanded "><a href="ch13-02-FancierGraphics.html"><strong aria-hidden="true">13.2.</strong> Fancier Graphics</a></li><li class="chapter-item expanded "><a href="ch13-03-ComplexComponentsandMVC.html"><strong aria-hidden="true">13.3.</strong> Complex Components and MVC</a></li><li class="chapter-item expanded "><a href="ch13-04-MostlyWindowsandDialogs.html"><strong aria-hidden="true">13.4.</strong> Mostly Windows and Dialogs</a></li><li class="chapter-item expanded "><a href="ch13-05-FinishingTouches.html"><strong aria-hidden="true">13.5.</strong> Finishing Touches</a></li><li class="chapter-item expanded "><a href="ch13-06-Exercises.html"><strong aria-hidden="true">13.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch13-07-Quiz.html"><strong aria-hidden="true">13.7.</strong> Quiz</a></li></ol><li class="chapter-item expanded "><a href="appendix-00.html"> Appendix</a></li><li class="chapter-item expanded "><a href="glossary-00.html"> Glossary</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="Java">Java</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Introduction to Programming Using Java</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Xayarsh/Java-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Introduction to Threads"><a class="header" href="#Introduction to Threads">Introduction to Threads</a></h2>
                        <p>
                            Like people, computers can <span class="newword">multitask</span>.  That
                            is, they can be working on several different tasks at the same time.  A computer that
                            has just a single central processing unit can't literally do two things at the same time,
                            any more than a person can,
                            but it can still switch its attention back and forth among several tasks.  Furthermore,
                            most computers, and even mobile devices, now have more than one processing unit, and
                            such computers can literally work on several tasks simultaneously.  It is likely that
                            from now on, most of the increase in computing power will come from adding additional
                            processors to computers rather than from increasing the speed of individual processors.
                            To use the full
                            power of these multiprocessing computers, a programmer must do <span class="newword">parallel
programming</span>, which means writing a program as a set of several tasks that
                            can be executed simultaneously.  Even on a single-processor computer, parallel programming
                            techniques can be useful, since some problems can be tackled most naturally by breaking
                            the solution into a set of simultaneous tasks that cooperate to solve the problem.</p>


                        <p>In Java, a single task is called a <span class="newword">thread</span>.  The term "thread"
                            refers to a "thread of control" or "thread of execution," meaning a sequence of instructions that are executed
                            one after another&mdash;the thread extends through time, connecting each instruction to
                            the next.  In a multithreaded program, there can be many threads of control, weaving
                            through time in parallel and forming the complete fabric of the program. (Ok, enough
                            with the metaphor, already!)  Every Java program has at least one thread; when the Java
                            virtual machine runs your program, it creates a thread
                            that is responsible for executing the <span class="code">main</span> routine of the program.
                            This main thread can in turn create other threads that can continue even after
                            the main thread has terminated.  In a GUI program, there is at least one additional
                            thread, which is responsible for handling events and drawing components on the screen.
                            In JavaFX, that thread is the application thread.</p>


                        <p>Unfortunately, parallel programming is even more difficult than ordinary,
                            single-threaded programming.  When several threads are working together on a
                            problem, a whole new category of errors is possible.  This just means that
                            techniques for writing correct and robust programs are even more important for
                            parallel programming than they are for normal programming.  On the other
                            hand, fortunately, Java has a nice thread API that makes basic uses of
                            threads reasonably easy.  It also has a variety of standard classes to help with
                            some of the more tricky parts or to hide them entirely.
                            It won't be until midway through <a href="ch12-03-ThreadsandParallelProcessing.html">Section&nbsp;12.3</a>
                            that you'll learn about the low-level techniques that are necessary to handle the
                            trickiest parts of parallel programming.  In fact, a programmer can do a lot with threads
                            without ever learning about the low-level stuff.</p>


                        <h3 id="Creating and Running Threads"><a class="header" href="#Creating and Running Threads">Creating and Running Threads</a></h3>


                        <p>In Java, a thread is represented by an object belonging to the class
                            <span class="code">java.lang.Thread</span> (or to a subclass of this class).  The purpose
                            of a <span class="classname">Thread</span> object is to execute a single method and to
                            execute it just once.  This method represents the task to be carried out by the thread.
                            The method is executed in its own thread of control, which can run in parallel with
                            other threads.  When the execution of the thread's method is finished, either because the
                            method terminates normally or because of an uncaught exception, the thread
                            stops running.  Once this happens, there is no way to restart the thread or
                            to use the same <span class="classname">Thread</span> object to start another thread.</p>


                        <p>There are two ways to program a thread.  One is to create a subclass of
                            <span class="classname">Thread</span> and to define the method <span class="code">public void run()</span>
                            in the subclass.  This <span class="code">run()</span> method defines the task that will be
                            performed by the thread; that is, when the thread is started, it is the <span class="code">run()</span>
                            method that will be executed in the thread.  For example, here is a simple, and
                            rather useless, class that defines a thread that does nothing but print a message
                            on standard output:</p>


                        <pre><code class="java">public class NamedThread extends Thread {
   private String name;  // The name of this thread.
   public NamedThread(String name) {  // Constructor gives name to thread.
      this.name = name;
   }
   public void run() {  // The run method prints a message to standard output.
      System.out.println("Greetings from thread '" + name + "'!");
   }
}</code></pre>


                        <p>To use a <span class="classname">NamedThread</span>, you must of course create an object
                            belonging to this class.  For example,</p>


                        <pre><code class="java">NamedThread greetings = new NamedThread("Fred");</code></pre>


                        <p>However, creating the object does not automatically start
                            the thread running or cause its <span class="code">run()</span> method to be executed.
                            To do that, you must call the <span class="code">start()</span> method in
                            the thread object.  For the example, this would be done with the statement</p>


                        <pre><code class="java">greetings.start();</code></pre>


                        <p>The purpose of the <span class="code">start()</span> method is to create the new thread of
                            control that will execute the <span class="classname">Thread</span> object's <span class="code">run()</span>
                            method.  The new thread runs in parallel with the thread in which the <span class="code">start()</span>
                            method was called, along with any other threads that already existed.  The <span class="code">start()</span>
                            method returns immediately after starting the new thread of control,
                            <b>without waiting for the thread to terminate</b>.  This means that
                            the code in the thread's <span class="code">run()</span> method executes at the same time as the
                            statements that follow the call to the <span class="code">start()</span> method.  Consider this
                            code segment:</p>


                        <pre><code class="java">NamedThread greetings = new NamedThread("Fred");
greetings.start();
System.out.println("Thread has been started");</code></pre>


                        <p>After <span class="code">greetings.start()</span> is executed, there are two threads.
                            One of them will print "Thread has been started" while the other one wants
                            to print "Greetings from thread 'Fred'!".  It is important to note that
                            <i>these messages can be printed in either order</i>.  The two threads run simultaneously
                            and will compete for access to standard output, so that they can print their messages.
                            Whichever thread happens to be the first to get access will be the first to
                            print its message.  In a normal, single-threaded program, things happen in a
                            definite, predictable order from beginning to end.  In a multi-threaded program,
                            there is a fundamental indeterminacy.  You can't be sure what order things will
                            happen in.  This indeterminacy is what makes parallel programming so difficult!</p>


                        <p>Note that calling <span class="code">greetings.start()</span> is <b>very</b> different from calling
                            <span class="code">greetings.run()</span>.  Calling <span class="code">greetings.run()</span> would execute
                            the <span class="code">run()</span> method in the same thread, rather than creating a new thread.
                            This means that all the work of the <span class="code">run()</span> method will be done before the
                            computer moves on to the statements that follow the call to <span class="code">greetings.run()</span>.
                            There is no parallelism and no indeterminacy.</p>


                        <p align="center">
                            <img src="./images/threads-vs-subroutines.png" width="600" height="357" alt=""></p>


                        <p>This discussion has assumed that the computer on which the program is running
                            has more than one processing unit, so that it is possible for the original thread
                            and the newly created thread to literally be executed at the same time.  However, it's
                            possible to create multiple threads even on a computer that has only one processor
                            (and, more generally, it is possible to create many more threads than there are
                            processors, on any computer).  In that case, the two threads will compete for
                            time on the processor.  However, there is still indeterminacy because the processor can
                            switch from one thread to another at unpredictable times.  In fact, from the point
                            of view of the programmer, there is no difference between programming for a single-processor
                            computer and programming for a multi-processor computer, and we will mostly
                            ignore the distinction from now on.</p>





                        <p>I mentioned that there are two ways to program a thread.  The first way was to
                            define a subclass of <span class="classname">Thread</span>.  The second is to define a
                            class that implements the interface <span class="code">java.lang.Runnable</span>.  The
                            <span class="classname">Runnable</span> interface defines a single method,
                            <span class="code">public void run()</span>.  Given a <span class="classname">Runnable</span>,
                            it is possible to create a <span class="classname">Thread</span> whose task is to
                            execute the <span class="classname">Runnable's</span> <span class="code">run()</span> method.</p>


                        <p>The <span class="classname">Thread</span> class has a constructor that
                            takes a <span class="classname">Runnable</span> as its parameter.
                            When an object that implements the <span class="classname">Runnable</span> interface
                            is passed to that constructor, the <span class="code">run()</span> method of the thread
                            will simply call the <span class="code">run()</span> method from the <span class="classname">Runnable</span>,
                            and calling the thread's <span class="code">start()</span> method will create a new thread of
                            control in which the <span class="classname">Runnable's</span> <span class="code">run()</span> method
                            is executed.  For example,
                            as an alternative to the <span class="classname">NamedThread</span> class, we could define
                            the class:</p>


                        <pre><code class="java">public class NamedRunnable implements Runnable {
   private String name;  // The name of this Runnable.
   public NamedRunnable(String name) {  // Constructor gives name to object.
      this.name = name;
   }
   public void run() {  // The run method prints a message to standard output.
      System.out.println("Greetings from runnable '" + name +"'!");
   }
}</code></pre>


                        <p>To use this version of the class, we would create a <span class="classname">NamedRunnable</span>
                            object and use that object to create an object of type <span class="classname">Thread</span>:</p>


                        <pre><code class="java">NamedRunnable greetings = new NamedRunnable("Fred");
Thread greetingsThread = new Thread(greetings);
greetingsThread.start();</code></pre>


                        <p>The advantage of doing things this way is that <b>any</b> object can
                            implement the <span class="classname">Runnable</span> interface and can contain a
                            <span class="code">run()</span> method, which can then be executed in a separate thread.
                            That <span class="code">run()</span> method has access to everything in the class, including
                            <span class="code">private</span> variables and methods.  The disadvantage is that this
                            way of doing things is not very object-oriented: It violates the principle that
                            each object should have a single, clearly-defined responsibility.  Instead of
                            making some random object <span class="classname">Runnable</span> just so that you
                            can use it to make a thread, you can consider defining the thread using
                            a nested class that is a subclass of the <span class="classname">Thread</span> class.  (See <a href="ch05-08-NestedClasses.html">Section&nbsp;5.8</a>.)
                        </p>


                        <p>Finally, I'll note that <span class="classname">Runnable</span> is a functional interface,
                            so that a <span class="classname">Runnable</span> object can be given as a lambda expression.
                            In particular, the parameter to <span class="code">new&nbsp;Thread(r)</span> can be a
                            lambda expression. For example:</p>


                        <pre><code class="java">Thread greetingsFromFred = new Thread(
    () -&gt; System.out.println("Greetings from Fred!")
);
greetingsFromFred.start();</code></pre>





                        <p>To help you understand how multiple threads are executed in parallel, we consider
                            the sample program <span class="sourceref"><a href="./source/chapter12/ThreadTest1.java">ThreadTest1.java</a></span>.  This program creates
                            several threads.  Each thread performs exactly the same task.  The task is to count
                            the number of integers less than 10,000,000 that are prime. (The particular task
                            that is done is not important for our purposes here, as long as it is something
                            that takes a non-trivial amount of time.
                            This is a demo program; it would be silly in a real program to have multiple threads that
                            do the same thing, and the method that is used for counting the primes is very inefficient.)
                            This computation should take no more than a few seconds on a modern computer.
                            The threads that perform this task are defined by the
                            following static nested class, where <span class="code">MAX</span> is 10,000,000:</p>


                        <pre><code class="java">/**
 * When a thread belonging to this class is run it will count the
 * number of primes between 2 and MAX.  It will print the result
 * to standard output, along with its ID number and the elapsed
 * time between the start and the end of the computation.
 */
private static class CountPrimesThread extends Thread {
   int id;  // An id number for this thread; specified in the constructor.
   public CountPrimesThread(int id) {
      this.id = id;
   }
   public void run() {
      long startTime = System.currentTimeMillis();
      int count = countPrimes(2,MAX); // Counts the primes.
      long elapsedTime = System.currentTimeMillis() - startTime;
      System.out.println("Thread " + id + " counted " +
            count + " primes in " + (elapsedTime/1000.0) + " seconds.");
   }
}</code></pre>


                        <p>The main program asks the user how many threads to run, and then creates and starts
                            the specified number of threads:</p>


                        <pre><code class="java">public static void main(String[] args) {
   int numberOfThreads = 0;
   while (numberOfThreads &lt; 1 || numberOfThreads &gt; 30) {
      System.out.print("How many threads do you want to use  (1 to 30) ?  ");
      numberOfThreads = TextIO.getlnInt();
      if (numberOfThreads &lt; 1 || numberOfThreads &gt; 30)
         System.out.println("Please enter a number between 1 and 30 !");
   }
   System.out.println("\nCreating " + numberOfThreads
                                           + " prime-counting threads...");
   CountPrimesThread[] worker = new CountPrimesThread[numberOfThreads];
   for (int i = 0; i &lt; numberOfThreads; i++)
      worker[i] = new CountPrimesThread( i );
   for (int i = 0; i &lt; numberOfThreads; i++)
      worker[i].start();
   System.out.println("Threads have been created and started.");
}</code></pre>



                        <p>It would be a good idea for you to compile and run the program.</p>



                        <p>My computer has six processors.  When I ran the program on that computer with
                            using one thread, it took about 3.36 seconds.
                            When I ran it using twelve threads, the output was:</p>


                        <pre><code class="java">Creating 12 prime-counting threads...
Threads have been created and started.
Thread 1 counted 664579 primes in 6.424 seconds.
Thread 11 counted 664579 primes in 6.694 seconds.
Thread 0 counted 664579 primes in 6.727 seconds.
Thread 3 counted 664579 primes in 6.74 seconds.
Thread 10 counted 664579 primes in 6.759 seconds.
Thread 7 counted 664579 primes in 6.77 seconds.
Thread 2 counted 664579 primes in 6.798 seconds.
Thread 9 counted 664579 primes in 6.792 seconds.
Thread 5 counted 664579 primes in 6.824 seconds.
Thread 4 counted 664579 primes in 6.836 seconds.
Thread 8 counted 664579 primes in 6.841 seconds.
Thread 6 counted 664579 primes in 6.877 seconds.</code></pre>


                        <p>The second line was printed immediately after the first. At this point, the main
                            program has ended but the twelve threads continued to run.  After a pause of about 6.5
                            seconds, all eight threads completed at about the same time.  The order in which the
                            threads complete is not the same as the order in which they were started, and
                            the order is indeterminate.  That is, if the program is run again, the order
                            in which the threads complete will probably be different.</p>


                        <p>On this computer, twelve threads took about twice as long as one thread.
                            This is because the computer has six processors.  With twelve threads
                            running on six processors&mdash;one-half processor per thread&mdash;each thread
                            was only actively being executed for about half of the time, so it took
                            twice as long to finish its task.  On a single-processor computer, twelve
                            threads would take about twelve times as long as one thread.
                            On a computer with six or more processors, six threads might take no more time
                            than a single thread.  Because of overhead and other reasons, the actual speedup
                            will probably be a little smaller than this analysis indicates, but on a multiprocessor
                            machine, you should see a definite speedup.  What happens when you run the program
                            on your own computer?  How many processors do you have?</p>


                        <p>Whenever there are more threads to be run than there are processors
                            to run them, the computer divides its attention among all the runnable
                            threads by switching rapidly from one thread to another.  That is, each
                            processor runs one thread for a while then switches to another thread and
                            runs that one for a while, and so on.  Typically, these "context switches"
                            occur about 100 times or more per second.  The result is that the
                            computer makes progress on all the tasks, and it looks to the user as if
                            all the tasks are being executed simultaneously.  This is why in the sample
                            program, in which each thread has the same amount of work to do, all the
                            threads complete at about the same time:  Over any time period longer than
                            a fraction of a second, the computer's time is divided approximately equally
                            among all the threads.</p>


                        <h3 id="Operations on Threads"><a class="header" href="#Operations on Threads">Operations on Threads</a></h3>

                        <p>Much of Java's thread API can be found in the <span class="classname">Thread</span>
                            class.  However, we'll start with a thread-related method in
                            <span class="classname">Runtime</span>, a class that allows a Java program to
                            get information about the environment in which it is running.
                            When you do parallel programming in order to spread the work among
                            several processors, you might want to take into account the number of
                            available processors.  You might, for example, want to create one
                            thread for each processor.  In Java, you can find out
                            the number of processors by calling the function</p>


                        <pre><code class="java">Runtime.getRuntime().availableProcessors()</code></pre>


                        <p>which returns an <span class="ptype">int</span> giving the number of processors that
                            are available to the Java Virtual Machine.  In some cases, this might be
                            less than the actual number of processors in the computer.</p>


                        <p>A <span class="classname">Thread</span> object contains several useful methods
                            for working with threads.  Most important is the <span class="code">start()</span> method,
                            which was discussed above.</p>


                        <p>Once a thread has been started, it will continue to run until its
                            <span class="code">run()</span> method ends for some reason.  Sometimes, it's useful
                            for one thread to be able to tell whether another thread has terminated.
                            If <span class="code">thrd</span> is an object of type <span class="classname">Thread</span>,
                            then the <span class="ptype">boolean</span>-valued function <span class="codedef">thrd.isAlive()</span>
                            can be used to test whether or not <span class="code">thrd</span> has terminated.  A thread is "alive"
                            between the time it is started and the time when it terminates.  After the
                            thread has terminated it is said to be "dead."  (The rather gruesome metaphor
                            is also used when we refer to "killing" or "aborting" a thread.)  Remember that
                            a thread that has terminated cannot be restarted.</p>


                        <p>The static method <span class="codedef">Thread.sleep(milliseconds)</span> causes the
                            thread that executes this method to "sleep" for the specified number of milliseconds.
                            A sleeping thread is still alive, but it is not running.  While a thread is sleeping,
                            the computer can  work on any other runnable threads (or on other programs).
                            <span class="code">Thread.sleep()</span> can be used to insert a pause in the execution of a
                            thread.  The <span class="code">sleep()</span> method can throw an exception of type
                            <span class="classname">InterruptedException</span>, which is a checked exception that
                            requires mandatory exception handling.
                            In practice, this means that the <span class="code">sleep()</span> method is usually called inside a <span class="code">try..catch</span>
                            statement that catches the potential <span class="classname">InterruptedException</span>:</p>


                        <pre><code class="java">try {
   Thread.sleep(lengthOfPause);
}
catch (InterruptedException e) {
}</code></pre>


                        <p>One thread can <span class="newword">interrupt</span> another thread to wake it up when it is sleeping or
                            paused for certain other reasons.  A <span class="classname">Thread</span>, <span class="code">thrd</span>,
                            can be interrupted by calling the method <span class="codedef">thrd.interrupt()</span>.
                            Doing so can be a convenient way to send a signal from one thread to another.
                            A thread knows it has been interrupted when it catches an <span class="classname">InterruptedException</span>.
                            Outside any <span class="code">catch</span> handler for the exception, the
                            thread can check whether it has been interrupted by calling the static method
                            <span class="codedef">Thread.interrupted()</span>.  This method tells whether the current thread&mdash;the
                            thread that executes the method&mdash;has been interrupted.  It also has the unusual property
                            of clearing the interrupted status of the thread, so you only get one chance to check for an
                            interruption.  In your own
                            programs, your threads are not going to be interrupted unless <b>you</b> interrupt them. So most
                            often, you are not likely to need to do anything in response to an <span class="classname">InterruptedException</span>
                            (except to <span class="code">catch</span> it).
                        </p>


                        <p>Sometimes, it's necessary for one thread to wait for another thread to die.
                            This is done with the <span class="code">join()</span> method from the <span class="classname">Thread</span> class.
                            Suppose that <span class="code">thrd</span> is a <span class="classname">Thread</span>.  Then, if another
                            thread calls <span class="codedef">thrd.join()</span>, that other thread will go to sleep until
                            <span class="code">thrd</span> terminates.  If <span class="code">thrd</span> is already dead when <span class="code">thrd.join()</span>
                            is called, then it simply has no effect.  The <span class="code">join()</span> method can throw an
                            <span class="classname">InterruptedException</span>, which must be handled as usual.
                            As an example, the following code starts several threads, waits for them all to terminate,
                            and then outputs the elapsed time:</p>


                        <pre><code class="java">CountPrimesThread[] worker = new CountPrimesThread[numberOfThreads];
long startTime = System.currentTimeMillis();
for (int i = 0; i &lt; numberOfThreads; i++) {
   worker[i] = new CountPrimesThread();
   worker[i].start();
}
for (int i = 0; i &lt; numberOfThreads; i++) {
   try {
      worker[i].join();  // Wait until worker[i] finishes, if it hasn't already.
   }
   catch (InterruptedException e) {
   }
}
// At this point, all the worker threads have terminated.
long elapsedTime = System.currentTimeMillis() - startTime;
System.out.println("Total elapsed time: " + (elapsedTime/1000.0) + " seconds");</code></pre>


                        <p>An observant reader will note that this code assumes that no <span class="classname">InterruptedException</span>
                            will occur.  To be absolutely sure that the thread <span class="code">worker[i]</span> has terminated in an environment
                            where <span class="classname">InterruptedExceptions</span> are possible, you would have to do something like:</p>


                        <pre><code class="java">while (worker[i].isAlive()) {
   try {
      worker[i].join();
   }
   catch (InterruptedException e) {
   }
}</code></pre>


                        <p>Another version of the <span class="code">join()</span> method takes an integer parameter that
                            specifies the maximum number of milliseconds to wait.  A call to <span class="codedef">thrd.join(m)</span>
                            will wait until either <span class="code">thrd</span> has terminated or until <span class="code">m</span> milliseconds
                            have elapsed (or until the waiting thread is interrupted).
                            This can be used to allow a thread to wake up occasionally to perform some task
                            while it is waiting.  Here, for example, is a code segment that will
                            start a thread, <span class="code">thrd</span>, and then will
                            output a period every two seconds as long as <span class="code">thrd</span> continues to run:</p>


                        <pre><code class="java">System.out.print("Running the thread ");
thrd.start();
while (thrd.isAlive()) {
   try {
      thrd.join(2000);
      System.out.print(".");
   }
   catch (InterruptedException e) {
   }
}
System.out.println(" Done!");</code></pre>


                        <p>Threads have two properties that are occasionally useful: a daemon status and a
                            priority.  A <span class="classname">Thread</span> <span class="code">thrd</span> can be designated as
                            a <span class="newword">daemon thread</span> by calling <span class="codedef">thrd.setDaemon(true)</span>.
                            This must be done before the thread is started, and it can throw an exception of
                            type <span class="classname">SecurityException</span> if the calling thread is not allowed
                            to modify <span class="code">thrd's</span> properties.  This has only one effect:  The Java Virtual
                            Machine will exit as soon as there are no <b>non-daemon</b> threads that are still
                            alive.  That is, the fact that a daemon thread is still alive is not enough to keep
                            the Java Virtual Machine running.  A daemon thread might exist, for example, only to provide
                            some service to other, non-daemon threads.  When there are no more non-daemon threads,
                            there will be no further call for the daemon thread's services, so the program might
                            as well shut down. (A call to <span class="code">System.exit()</span> forces the JVM to terminate,
                            even if there are non-daemon threads still running.)</p>


                        <p>The priority of a thread is a more important property.
                            Every thread has a <span class="newword">priority</span>, specified as an integer.  A thread
                            with a greater priority value will be run in preference to a thread with a smaller priority.
                            For example, computations that can be done in the background, when no more important
                            thread has work to do, can be run with a low priority.  In the next section, we will see how
                            this can be useful in GUI programs.  If <span class="code">thrd</span> is of type <span class="classname">Thread</span>,
                            then <span class="codedef">thrd.getPriority()</span> returns the integer that specifies <span class="code">thrd</span>'s
                            priority, and <span class="codedef">thrd.setPriority(p)</span> can be used to set its priority to a given
                            integer,&nbsp;<span class="code">p</span>.
                        </p>


                        <p>Priorities cannot be arbitrary integers, and <span class="code">thrd.setPriority()</span> will
                            throw an <span class="classname">IllegalArgumentException</span> if the specified priority
                            is not in the legal range for the thread. The range of legal priority values can
                            differ from one computer to another.  The range of legal values is specified by
                            the constants <span class="code">Thread.MIN_PRIORITY</span> and <span class="code">Thread.MAX_PRIORITY</span>,
                            but a given thread might be further restricted to values less than <span class="code">Thread.MAX_PRIORITY</span>.
                            The default priority is given by <span class="code">Thread.NORM_PRIORITY.</span>  To set <span class="code">thrd</span>
                            to run with a priority value just below the normal priority, you can call</p>


                        <pre><code class="java">thrd.setPriority( Thread.NORM_PRIORITY - 1 );</code></pre>


                        <p>Note that <span class="code">thrd.setPriority()</span> can also throw an exception of type
                            <span class="classname">SecurityException</span>, if the thread that calls the method is not
                            allowed to set the priority of <span class="code">thrd</span> to the specified value.</p>


                        <p>Finally, I'll note that the static method <span class="codedef">Thread.currentThread()</span> returns the current
                            thread.  That is, the return value of this method is the thread that executed the method.  This allows a
                            thread to get a reference to itself, so that it can modify its own properties.  For
                            example,  you can determine the priority of the currently running
                            thread by calling <span class="code">Thread.currentThread().getPriority()</span>.
                        </p>


                        <h3 id="Mutual Exclusion with synchronized"><a class="header" href="#Mutual Exclusion with synchronized">Mutual Exclusion with "synchronized"</a></h3>

                        <p>It's pretty easy to program several threads to carry out completely independent tasks.
                            The real difficulty arises when threads have to interact in some way.
                            One way that threads interact is by sharing resources.
                            When two threads need access to the same resource, such as a variable
                            or a window on the screen, some care must be taken that they don't try to
                            use the same resource at the same time.  Otherwise, the situation could
                            be something like this:  Imagine several cooks sharing the use of just one measuring cup,
                            and imagine that Cook&nbsp;A fills the measuring cup with milk, only to
                            have Cook&nbsp;B grab the cup before Cook&nbsp;A has a chance to empty the
                            milk into his bowl.  There has to be some way for Cook&nbsp;A to claim
                            exclusive rights to the cup while he performs the two operations:
                            Add-Milk-To-Cup and Empty-Cup-Into-Bowl.</p>


                        <p>Something similar happens with threads, even with something as simple
                            as adding one to a counter.  The statement</p>


                        <pre><code class="java">count = count + 1;</code></pre>


                        <p>is actually a sequence of three operations:</p>


                        <pre><code class="java">Step 1.  Get the value of count
Step 2.  Add 1 to the value.
Step 3.  Store the new value in count</code></pre>


                        <p>Suppose that each of several threads performs these three steps.  Remember that it's possible for
                            two threads to run at the same time, and even if there is only one processor, it's
                            possible for that processor to switch from one thread to another at any point.
                            Suppose that while one thread is between Step&nbsp;2 and Step&nbsp;3, another thread
                            starts executing the same sequence of steps.  Since the first thread has not
                            yet stored the new value in <span class="code">count</span>, the second thread reads the
                            <b>old</b> value of <span class="code">count</span> and adds one to that old value.  Both threads
                            have computed the same new value for <span class="code">count</span>, and both threads then go
                            on to store that value back into <span class="code">count</span> by executing Step&nbsp;3. After
                            both threads have done so, the value of <span class="code">count</span> has gone up
                            only by 1 instead of by&nbsp;2!  This type of problem is called a
                            <span class="newword">race condition</span>.  This occurs when one thread is in the middle
                            of a multi-step operation, and another thread can change some value or condition
                            that the first thread is depending upon.  (The first thread is "in a race" to
                            complete all the steps before it is interrupted by another thread.)</p>


                        <p>Another
                            example of a race condition can occur in an <span class="code">if</span> statement.
                            Consider the following statement, which is meant to avoid a division-by-zero error:
                        </p>


                        <pre><code class="java">if ( A != 0 ) {
   B = C / A;
}</code></pre>


                        <p>Suppose that this statement is executed by some thread.
                            If the variable <span class="code">A</span> is shared by one or more other threads, and if nothing is
                            done to guard against the race condition, then it is possible that one of those other threads
                            will change the value of <span class="code">A</span> to zero between the time that the first
                            thread checks the condition <span class="code">A&nbsp;!=&nbsp;0</span> and the time that
                            it does the division.  This means that the thread can end up dividing by zero,
                            even though it just checked that <span class="code">A</span> was not zero!</p>


                        <p>To fix the problem of race conditions, there has to be some way for a thread
                            to get <span class="newword">exclusive access</span> to a shared resource.  This is not a trivial
                            thing to implement, but Java provides a high-level and relatively easy-to-use approach
                            to exclusive access.  It's done with <span class="newword">synchronized methods</span> and with the
                            <span class="newword">synchronized statement</span>.  These are used to protect shared
                            resources by making sure that only one thread at a time will try to access the resource.
                            Synchronization in Java actually provides only <span class="newword">mutual exclusion</span>,
                            which means that exclusive access to a resource is only guaranteed if <b>every</b> thread
                            that needs access to that resource uses synchronization.  Synchronization is like a cook
                            leaving a note that says, "I'm using the measuring cup."  This will get the cook exclusive
                            access to the cup&mdash;but only if all the cooks agree to check the note before
                            trying to grab the cup.</p>


                        <p>Because this is a difficult topic, I will start with a simple example.  Suppose that
                            we want to avoid the race condition that occurs when several threads all want to
                            add 1 to a counter.  We can do this by defining a class to represent the counter
                            and by using synchronized methods in that class.  A method is declared to be
                            synchronized by adding the reserved word <span class="code">synchronized</span> as a modifier
                            to the definition of the method:</p>


                        <pre><code class="java">public class ThreadSafeCounter {

   private int count = 0;  // The value of the counter.

   synchronized public void increment() {
      count = count + 1;
   }

   synchronized public int getValue() {
      return count;
   }

}</code></pre>


                        <p>If <span class="code">tsc</span> is of type <span class="classname">ThreadSafeCounter</span>, then
                            any thread can call <span class="code">tsc.increment()</span> to add 1 to the counter in a completely
                            safe way.  The fact that <span class="code">tsc.increment()</span> is <span class="code">synchronized</span> means
                            that only one thread can be in this method at a time; once a thread starts executing
                            this method, it is guaranteed that it will finish executing it before another
                            thread is allowed to access <span class="code">count</span>.  There is
                            no possibility of a race condition.
                            Note that the guarantee depends on the fact that <span class="code">count</span> is a <span class="code">private</span>
                            variable.  This forces <b>all</b> access to <span class="code">tsc.count</span> to occur in the
                            <span class="code">synchronized</span> methods that are provided by the class.
                            If <span class="code">count</span> were <span class="code">public</span>, it would be possible
                            for a thread to bypass the synchronization by, for example, saying <span class="code">tsc.count++</span>.
                            This could change the value of <span class="code">count</span> while another thread is in the
                            middle of <span class="code">tsc.increment()</span>.  Remember that synchronization by itself does <b>not</b> guarantee
                            exclusive access; it only guarantees <b>mutual exclusion</b> among all the threads that are
                            synchronized.</p>


                        <p>However, the <span class="classname">ThreadSafeCounter</span> class does not prevent all possible
                            race conditions that might arise when using a counter.  Consider the <span class="code">if</span>
                            statement:</p>


                        <pre><code class="java">if ( tsc.getValue() == 10 ) {
   doSomething();
}</code></pre>


                        <p>where <span class="code">doSomething()</span> is some method that requires the value of the counter
                            to be &nbsp;10.  There is still a race condition here, which occurs if a second thread
                            increments the counter between the time the first thread tests <span class="code">tsc.getValue()&nbsp;==&nbsp;10</span>
                            and the time it executes <span class="code">doSomething()</span>.  The first thread needs exclusive
                            access to the counter during the execution of the whole <span class="code">if</span> statement.
                            (The synchronization in the <span class="classname">ThreadSafeCounter</span> class only gives it
                            exclusive access during the time it is evaluating <span class="code">tsc.getValue()</span>.)
                            We can solve the race condition by putting the <span class="code">if</span> statement in a <span class="code">synchronized</span>
                            statement:</p>


                        <pre><code class="java">synchronized(tsc) {
   if ( tsc.getValue() == 10 )
      doSomething();
}</code></pre>


                        <p>Note that the <span class="code">synchronized</span> statement takes an object&mdash;<span class="code">tsc</span> in
                            this case&mdash;as a kind of parameter.  The syntax of the <span class="code">synchronized</span> statement
                            is:</p>


                        <pre><code class="java">synchronized( <span class="bnf">object</span> ) {
   <span class="bnf">statements</span>
}</code></pre>


                        <p>In Java, mutual exclusion is always associated with an object; we say that the
                            synchronization is "on" that object.  For example, the <span class="code">if</span> statement above
                            is "synchronized on <span class="code">tsc</span>."  A synchronized instance method, such as those in the
                            class <span class="classname">ThreadSafeCounter</span>, is synchronized on the object that
                            contains the instance method.  In fact, adding the <span class="code">synchronized</span> modifier
                            to the definition of an instance method is pretty much equivalent to putting the body
                            of the method in a <span class="code">synchronized</span> statement of the form
                            <span class="code">synchronized(this)&nbsp;{...}</span>.  It is also possible to have
                            synchronized static methods; a synchronized static method is synchronized on
                            the special class object that represents the class containing the static method.</p>


                        <p>The real rule of synchronization in Java is this:  <b>Two threads cannot be
                            synchronized on the same object at the same time</b>; that is, they cannot simultaneously
                            be executing code segments that are synchronized on that object.  If one thread is synchronized
                            on an object, and a second thread tries to synchronize on the <b>same</b> object,
                            the second thread is forced to wait until the first thread has finished with the
                            object.  This means that it is not only true that two threads cannot be executing the same
                            synchronized method at the same time, but in fact two threads cannot be
                            executing two different methods at the same time, if the two methods are synchronized on the same object.
                            This is implemented using something called a <span class="newword">synchronization lock</span>.
                            Every object has a synchronization lock, and that lock can be "held" by only one
                            thread at a time.  To enter a synchronized statement or synchronized method,
                            a thread must obtain the associated object's lock.  If the lock is available,
                            then the thread obtains the lock and immediately begins executing the synchronized
                            code.  It releases the lock after it finishes executing the synchronized code.
                            If Thread&nbsp;A tries to obtain a lock that is already held by Thread&nbsp;B,
                            then Thread&nbsp;A has to wait until Thread&nbsp;B releases the lock.  In fact,
                            Thread&nbsp;A will go to sleep, and will not be awoken until the lock becomes
                            available.</p>


                        <p>The discussion of invariants in <a href="ch08-02-WritingCorrectPrograms.html">Subsection&nbsp;8.2.3</a> mentioned
                            that reasoning about invariants becomes much more complicated when threads are
                            involved.  The problem is race conditions.  We would like our <span class="classname">ThreadSafeCounter</span>
                            class to have the class invariant that "the value of <span class="code">count</span> is the number of times that
                            <span class="code">increment()</span> has been called."  In a single-threaded program, that would be
                            true even without synchronization.  However, in a multithreaded program, synchronization is
                            needed to ensure that the class invariant is really invariant.</p>


                        <p>As a simple example of shared resources, we return to the prime-counting
                            problem.  In this case, instead of having every thread perform exactly the
                            same task, we'll do some real parallel processing.  The program will
                            count the prime numbers in a given range of
                            integers, and it will do so by dividing the work up among several
                            threads.  Each thread will be assigned a part of the full range of integers,
                            and it will count the primes in its assigned part.  At the end of its
                            computation, the thread has to add its count to the overall total of primes
                            in the entire range.  The variable that represents the total is shared by
                            all the threads, since each thread has to add a number to the total.
                            If each thread just says</p>


                        <pre><code class="java">total = total + count;</code></pre>


                        <p>then there is a (small) chance that two threads will try to do this
                            at the same time and that the final total will be wrong.  To prevent this
                            race condition, access to <span class="code">total</span> has to be synchronized. My
                            program uses a synchronized method to add the counts to the total.  This
                            method is called once by each thread, and it is the only method in which
                            the value of <span class="code">total</span> is changed:</p>


                        <pre><code class="java">synchronized private static void addToTotal(int x) {
   total = total + x;
   System.out.println(total + " primes found so far.");
}</code></pre>


                        <p>The source code for the program can be found in <span class="sourceref"><a href="./source/chapter12/ThreadTest2.java">ThreadTest2.java</a></span>.
                            This program counts the primes in the range 6,000,001 to 12,000,000.  (The numbers are
                            rather arbitrary.)  The <span class="code">main()</span> routine in this program creates between
                            1 and 6 threads and assigns part of the job to each thread.  It waits for
                            all the threads to finish, using the <span class="code">join()</span> method as described above.
                            It then reports the total number of primes found, along with the elapsed time.
                            Note that <span class="code">join()</span> is required here, since it doesn't make sense to report the
                            number of primes until all of the threads have finished.
                            If you run the program on a multiprocessor
                            computer, it should take less time for the program to run when you use more than
                            one thread.</p>






                        <p>Synchronization can help to prevent race conditions, but it introduces the
                            possibility of another type of error, <span class="newword">deadlock</span>.
                            A deadlock occurs when a thread waits forever for a resource that it
                            will never get.  In the kitchen, a deadlock might occur if two very
                            simple-minded cooks both want to measure a cup of milk at the same
                            time.  The first cook grabs the measuring cup, while the second cook grabs
                            the milk.  The first cook needs the milk, but can't find it because the
                            second cook has it.  The second cook needs the measuring cup, but can't
                            find it because the first cook has it.  Neither cook can continue and
                            nothing more gets done.  This is deadlock.  Exactly the same thing
                            can happen in a program, for example if there are two threads (like the two cooks)
                            both of which need to obtain locks on the same two objects (like the milk and
                            the measuring cup) before they can proceed.  Deadlocks can easily occur,
                            unless great care is taken to avoid them.</p>

                        <h3 id="Volatile Variables"><a class="header" href="#Volatile Variables">Volatile Variables</a></h3>

                        <p>Synchronization is only one way of controlling communication among threads.
                            We will cover several other techniques later in the chapter.  For now,
                            we finish this section with two such techniques: volatile variables
                            and atomic variables.</p>


                        <p>In general, threads communicate
                            by sharing variables and accessing those variables in synchronized methods or
                            synchronized statements.  However, synchronization is fairly expensive computationally,
                            and excessive use of it should be avoided.  So in some cases, it can make sense for
                            threads to refer to shared variables without synchronizing their access to those
                            variables.</p>


                        <p>However, a subtle problem arises when the value of a shared variable is set in one
                            thread and used in another.  Because of the way that threads are implemented in Java,
                            the second thread might not see the changed value of the variable immediately.  That is,
                            it is possible that a thread will continue to see the <b>old</b> value of
                            the shared variable for some time after the value of the variable has been changed
                            by another thread. This is because threads are allowed to <span class="newword">cache</span> shared data.
                            That is, each thread can keep its own local copy of the shared data.  When one thread
                            changes the value of a shared variable, the local copies in the caches of other threads
                            are not immediately changed, so the other threads can continue to see the old value,
                            at least briefly.</p>


                        <p>It is safe to use a shared variable in a synchronized method or statement, as long as
                            all access to that variable is synchronized, using the same synchronization object
                            in all cases.  More precisely, any thread that accesses a variable in synchronized
                            code is guaranteed to see changes that were made by other threads, as long as the
                            changes were made in code that was synchronized on the same object.</p>


                        <p>It is possible to use a shared variable safely <b>outside</b> of synchronized code,
                            but in that case, the variable must be declared to be <span class="newword">volatile</span>.
                            The <span class="code">volatile</span> keyword is a modifier that can be added to a global variable
                            declaration, as in</p>


                        <pre><code class="java">private volatile int count;</code></pre>


                        <p>If a variable is declared to be <span class="code">volatile</span>, no thread will keep
                            a local copy of that variable in its cache.  Instead, the thread will always use
                            the official, main copy of the variable.  This means that any change that is made to
                            the variable will immediately be visible to all threads.  This makes it safe
                            for threads to refer to <span class="code">volatile</span> shared variables even outside of synchronized code.
                            Access to volatile variables is less efficient than access to
                            non-volatile variables, but more efficient than using synchronization.
                            (Remember, though, that using a volatile variable does not solve race
                            conditions that occur, for example, when the value of the variable is
                            incremented.  The increment operation can still be interrupted by
                            another thread.)</p>


                        <p>When the <span class="code">volatile</span> modifier is applied to an object variable,
                            only the variable itself is declared to be volatile, not the contents of the
                            object that the variable points to.  For this reason, <span class="code">volatile</span> is
                            used mostly for variables of simple types such as primitive types
                            or immutable types like <span class="classname">String</span>.</p>


                        <p>A typical example of using volatile variables is to send a signal from
                            one thread to another that tells the second thread to terminate.  The two threads
                            would share a variable</p>


                        <pre><code class="java">volatile boolean terminate = false;</code></pre>


                        <p>The run method of the second thread would check the value of <span class="code">terminate</span>
                            frequently, and it would end when the value of <span class="code">terminate</span> becomes true:</p>


                        <pre><code class="java">public void run() {
   while ( terminate == false ) {
      .
      .  // Do some work.
      .
   }
}</code></pre>


                        <p>This thread will run until some other thread sets the value of <span class="code">terminate</span>
                            to true.  Something like this is really the only clean way for one thread to cause
                            another thread to die.</p>


                        <p>(By the way, you might be wondering why threads should use local data caches in the
                            first place, since it seems to complicate things unnecessarily.  Caching is allowed because
                            of the structure of multiprocessing computers.   In many multiprocessing computers,
                            each processor has some local memory that is directly connected to the processor.
                            A thread's cache can be stored in the local memory of the processor on which the thread is running.
                            Access to this local memory is much faster than access to the main memory that is shared by all processors, so it
                            is more efficient for a thread to use a local copy of a shared variable rather
                            than some "master copy" that is stored in main memory.)</p>


                        <h3 id="Atomic Variables"><a class="header" href="#Atomic Variables">Atomic Variables</a></h3>

                        <p>The problem with a statement like "<span class="code">count = count&nbsp;+&nbsp;1</span>" for
                            parallel programming is that it takes several steps to execute the statement.   The
                            statement is only correctly executed if those steps are completed without interruption.</p>


                        <p>An <span class="newword">atomic</span> operation is something that cannot be interrupted.
                            It is an all-or-nothing affair.  It cannot be partly completed.  Most computers
                            have operations that are atomic on the machine language level.  For example,
                            there might be  a machine language instruction that can atomically increment
                            the value in a memory location.  Such an instruction could be used without fear
                            of race conditions.</p>


                        <p>In a program, an operation can be atomic even if it is not literally atomic
                            on the machine language level.  An operation can be considered atomic if it
                            can never be <b>seen</b> by any thread as partly completed.  For example,
                            we can say that the  <span class="classname">ThreadSafeCounter</span> class that was
                            defined above has an atomic increment operation.  Synchronization can be
                            seen as a way of ensuring that operations are, at least effectively, atomic.</p>


                        <p>Still, it would be nice to have atomic operations that don't require
                            synchronization, especially since such operations might be implemented
                            very efficiently on the hardware level.</p>


                        <p>Java has a package <span class="code">java.util.concurrent.atomic</span> that defines
                            classes that implement atomic operations on several simple variable types.
                            We will look at the class <span class="classname">AtomicInteger</span>, which
                            defines some atomic operations on an integer value, including atomic add, increment,
                            and decrement.  Suppose, for example, that we want to add some integer values
                            that are being produced by a number of different threads.  We can do that
                            with an <span class="classname">AtomicInteger</span> such as</p>


                        <pre><code class="java">private static AtomicInteger total = new AtomicInteger();</code></pre>


                        <p>The total is created with an initial value of zero.
                            When a thread wants to add a value to the total, it can use the
                            method <span class="code">total.addAndGet(x)</span>, which adds <span class="code">x</span>
                            to the total and returns the new value of total after <span class="code">x</span>
                            has been added.  This is an atomic operation, which cannot be
                            interrupted, so we can be sure that the value of total will be
                            correct in the end.  The sample program <span class="sourceref"><a href="./source/chapter12/ThreadTest3.java">ThreadTest3.java</a></span>
                            is a small variation on <span class="sourceref"><a href="./source/chapter12/ThreadTest2.java">ThreadTest2.java</a></span> that uses
                            an <span class="classname">AtomicInteger</span> instead of synchronization
                            to safely add up values from several threads.</p>


                        <p>
                            <span class="classname">AtomicInteger</span> has similar methods for adding one to the total and
                            subtracting one from the total: <span class="code">total.incrementAndGet()</span>
                            and <span class="code">total.decrementAndGet()</span>.  The method
                            <span class="code">total.getAndSet(x)</span> sets the value of the total to
                            <span class="code">x</span> and returns the previous value that <span class="code">x</span>
                            is replacing.  All of these operations are done atomically (either because
                            they use atomic machine language instructions or because they
                            use synchronization internally).</p>


                        <p>I should close with my usual warning: Using an atomic variable does not
                            automatically solve all race conditions involving that variable.  For example,
                            in the code</p>


                        <pre><code class="java">int currentTotal = total.addAndGet(x);
System.out.println("Current total is " + currentTotal);</code></pre>


                        <p>it is possible that by the time the output statement is executed,
                            the total has been changed by another thread so that <span class="code">currentTotal</span>
                            is no longer the current value of total!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch12-00-ThreadsandMultiprocessing.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch12-02-ProgrammingwithThreads.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch12-00-ThreadsandMultiprocessing.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch12-02-ProgrammingwithThreads.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </body>
</html>
