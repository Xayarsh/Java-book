<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Threads and Parallel Processing - Introduction to Programming Using Java</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

<link rel="stylesheet" href="code-class.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html" >Introduction to Programming Using Java</a></li><li class="chapter-item expanded affix "><a href="preface.html">Preface</a></li><li class="chapter-item expanded "><a href="ch01-00-Overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-FetchExecuteCycle.html"><strong aria-hidden="true">1.1.</strong> Fetch and Execute Cycle</a></li><li class="chapter-item expanded "><a href="ch01-02-AsynchronousEvents.html"><strong aria-hidden="true">1.2.</strong> Asynchronous Events</a></li><li class="chapter-item expanded "><a href="ch01-03-JavaVirtualMachine.html"><strong aria-hidden="true">1.3.</strong> The Java Virtual Machine</a></li><li class="chapter-item expanded "><a href="ch01-04-FundamentalBuildingBlocks.html"><strong aria-hidden="true">1.4.</strong> Fundamentals</a></li><li class="chapter-item expanded "><a href="ch01-05-OOP.html"><strong aria-hidden="true">1.5.</strong> Object Oriented Programming</a></li><li class="chapter-item expanded "><a href="ch01-06-ModernUserInterface.html"><strong aria-hidden="true">1.6.</strong> Modern User Interface</a></li><li class="chapter-item expanded "><a href="ch01-07-InternetAndBeyond.html"><strong aria-hidden="true">1.7.</strong> Internet and Beyond</a></li><li class="chapter-item expanded "><a href="ch01-08-Quiz.html"><strong aria-hidden="true">1.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-NameAndThings.html"><strong aria-hidden="true">2.</strong> Name and Things</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-BasicJavaApplication.html"><strong aria-hidden="true">2.1.</strong> Basic Java Application</a></li><li class="chapter-item expanded "><a href="ch02-02-VariablesAndTypes.html"><strong aria-hidden="true">2.2.</strong> Variables and Types</a></li><li class="chapter-item expanded "><a href="ch02-03-ObjectsAndSubroutines.html"><strong aria-hidden="true">2.3.</strong> Objects and Subroutines</a></li><li class="chapter-item expanded "><a href="ch02-04-TextInputAndOutput.html"><strong aria-hidden="true">2.4.</strong> Text Input and Output</a></li><li class="chapter-item expanded "><a href="ch02-05-DetailsOfExpressions.html"><strong aria-hidden="true">2.5.</strong> Details of Expressions</a></li><li class="chapter-item expanded "><a href="ch02-06-ProgrammingEnvironments.html"><strong aria-hidden="true">2.6.</strong> Programming and Environments</a></li><li class="chapter-item expanded "><a href="ch02-07-Exercises.html"><strong aria-hidden="true">2.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch02-08-Quiz.html"><strong aria-hidden="true">2.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-Control.html"><strong aria-hidden="true">3.</strong> Control</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-BlocksLoopsBranches.html"><strong aria-hidden="true">3.1.</strong> Blocks, Loops and Branches</a></li><li class="chapter-item expanded "><a href="ch03-02-AlgorithmDevelopment.html"><strong aria-hidden="true">3.2.</strong> Algorithm Development</a></li><li class="chapter-item expanded "><a href="ch03-03-While.html"><strong aria-hidden="true">3.3.</strong> while and do...while</a></li><li class="chapter-item expanded "><a href="ch03-04-For.html"><strong aria-hidden="true">3.4.</strong> The for statement</a></li><li class="chapter-item expanded "><a href="ch03-05-If.html"><strong aria-hidden="true">3.5.</strong> The If Statement</a></li><li class="chapter-item expanded "><a href="ch03-06-Switch.html"><strong aria-hidden="true">3.6.</strong> The Switch Statement</a></li><li class="chapter-item expanded "><a href="ch03-07-ExceptionsTryCatch.html"><strong aria-hidden="true">3.7.</strong> Exceptions and try...catch</a></li><li class="chapter-item expanded "><a href="ch03-08-Arrays.html"><strong aria-hidden="true">3.8.</strong> Arrays: An Introduction</a></li><li class="chapter-item expanded "><a href="ch03-09-GUI.html"><strong aria-hidden="true">3.9.</strong> GUI: An Introduction</a></li><li class="chapter-item expanded "><a href="ch03-10-Exercises.html"><strong aria-hidden="true">3.10.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch03-11-Quiz.html"><strong aria-hidden="true">3.11.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-Subroutines.html"><strong aria-hidden="true">4.</strong> Subroutines</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-BlackBoxes.html"><strong aria-hidden="true">4.1.</strong> Black Boxes</a></li><li class="chapter-item expanded "><a href="ch04-02-StaticSubroutines.html"><strong aria-hidden="true">4.2.</strong> Static Subroutines and Variables</a></li><li class="chapter-item expanded "><a href="ch04-03-Parameters.html"><strong aria-hidden="true">4.3.</strong> Parameters</a></li><li class="chapter-item expanded "><a href="ch04-04-ReturnValues.html"><strong aria-hidden="true">4.4.</strong> Return Values</a></li><li class="chapter-item expanded "><a href="ch04-05-Lambda.html"><strong aria-hidden="true">4.5.</strong> Lambda Expressions</a></li><li class="chapter-item expanded "><a href="ch04-06-APIPackagesModulesJavadoc.html"><strong aria-hidden="true">4.6.</strong> API, Packages, Modules and Javadoc</a></li><li class="chapter-item expanded "><a href="ch04-07-MoreOnProgramDesign.html"><strong aria-hidden="true">4.7.</strong> More on Program Design</a></li><li class="chapter-item expanded "><a href="ch04-08-TruthAboutDeclarations.html"><strong aria-hidden="true">4.8.</strong> Truth about Declarations</a></li><li class="chapter-item expanded "><a href="ch04-09-Exercises.html"><strong aria-hidden="true">4.9.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch04-10-Quiz.html"><strong aria-hidden="true">4.10.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-ObjectsClasses.html"><strong aria-hidden="true">5.</strong> Objects and Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-ObjectsAndInstanceMethods.html"><strong aria-hidden="true">5.1.</strong> Objects and Instance Methods</a></li><li class="chapter-item expanded "><a href="ch05-02-ConstructorObjectInit.html"><strong aria-hidden="true">5.2.</strong> Constructor and Object Initialization</a></li><li class="chapter-item expanded "><a href="ch05-03-ProgrammingWithObjects.html"><strong aria-hidden="true">5.3.</strong> Programming with Objects</a></li><li class="chapter-item expanded "><a href="ch05-04-AnExample.html"><strong aria-hidden="true">5.4.</strong> An Example</a></li><li class="chapter-item expanded "><a href="ch05-05-InheritanceAndPolymorphism.html"><strong aria-hidden="true">5.5.</strong> Inheritance and Polymorphism</a></li><li class="chapter-item expanded "><a href="ch05-06-thisandsuper.html"><strong aria-hidden="true">5.6.</strong> this and super</a></li><li class="chapter-item expanded "><a href="ch05-07-Interfaces.html"><strong aria-hidden="true">5.7.</strong> Interfaces</a></li><li class="chapter-item expanded "><a href="ch05-08-NestedClasses.html"><strong aria-hidden="true">5.8.</strong> Nested Classes</a></li><li class="chapter-item expanded "><a href="ch05-09-Exercises.html"><strong aria-hidden="true">5.9.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch05-10-Quiz.html"><strong aria-hidden="true">5.10.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-GUIProgramming.html"><strong aria-hidden="true">6.</strong> Introduction to GUI Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-BasicJavaFXApp.html"><strong aria-hidden="true">6.1.</strong> A Basic JavaFX Application</a></li><li class="chapter-item expanded "><a href="ch06-02-BasicClasses.html"><strong aria-hidden="true">6.2.</strong> Basic Classes</a></li><li class="chapter-item expanded "><a href="ch06-03-BasicEvents.html"><strong aria-hidden="true">6.3.</strong> Basic Events</a></li><li class="chapter-item expanded "><a href="ch06-04-BasicControls.html"><strong aria-hidden="true">6.4.</strong> Basic Controls</a></li><li class="chapter-item expanded "><a href="ch06-05-BasicLayout.html"><strong aria-hidden="true">6.5.</strong> Basic Layout</a></li><li class="chapter-item expanded "><a href="ch06-06-CompetePrograms.html"><strong aria-hidden="true">6.6.</strong> Complete Programs</a></li><li class="chapter-item expanded "><a href="ch06-07-Exercises.html"><strong aria-hidden="true">6.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch06-08-Quiz.html"><strong aria-hidden="true">6.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-ArraysArraylistsRecords.html"><strong aria-hidden="true">7.</strong> Arrays, ArrayLists and Records</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-ArrayDetails.html"><strong aria-hidden="true">7.1.</strong> Array Details</a></li><li class="chapter-item expanded "><a href="ch07-02-ArrayProcessing.html"><strong aria-hidden="true">7.2.</strong> Array Processing</a></li><li class="chapter-item expanded "><a href="ch07-03-ArrayLists.html"><strong aria-hidden="true">7.3.</strong> ArrayLists</a></li><li class="chapter-item expanded "><a href="ch07-04-Records.html"><strong aria-hidden="true">7.4.</strong> Records</a></li><li class="chapter-item expanded "><a href="ch07-05-SearchingAndSorting.html"><strong aria-hidden="true">7.5.</strong> Searching and Sorting</a></li><li class="chapter-item expanded "><a href="ch07-06-2DArrays.html"><strong aria-hidden="true">7.6.</strong> 2D Arrays</a></li><li class="chapter-item expanded "><a href="ch07-07-Exercises.html"><strong aria-hidden="true">7.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch07-08-Quiz.html"><strong aria-hidden="true">7.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-CorrectnessRobustnessEfficiency.html"><strong aria-hidden="true">8.</strong> Correctness, Robustness, Efficiency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-IntroductionCorrectnessandRobustness.html"><strong aria-hidden="true">8.1.</strong> Introduction to Correctness and Robustness</a></li><li class="chapter-item expanded "><a href="ch08-02-WritingCorrectPrograms.html"><strong aria-hidden="true">8.2.</strong> Writing Correct Programs</a></li><li class="chapter-item expanded "><a href="ch08-03-ExceptionsAndtrycatch.html"><strong aria-hidden="true">8.3.</strong> Exceptions and try..catch</a></li><li class="chapter-item expanded "><a href="ch08-04-AssertionsAnnotations.html"><strong aria-hidden="true">8.4.</strong> Assertions and Annotations</a></li><li class="chapter-item expanded "><a href="ch08-05-AnalysisofAlgorithms.html"><strong aria-hidden="true">8.5.</strong> Analysis of Algorithms</a></li><li class="chapter-item expanded "><a href="ch08-06-Exercises.html"><strong aria-hidden="true">8.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch08-07-Quiz.html"><strong aria-hidden="true">8.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-LinkedDataStructuresRecursion.html"><strong aria-hidden="true">9.</strong> Linked Data Structures and Recursion</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-Recursion.html"><strong aria-hidden="true">9.1.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="ch09-02-LinkedDataStructures.html"><strong aria-hidden="true">9.2.</strong> Linked Data Structures</a></li><li class="chapter-item expanded "><a href="ch09-03-StacksQueuesADTs.html"><strong aria-hidden="true">9.3.</strong> Stacks, Queues and ADTs</a></li><li class="chapter-item expanded "><a href="ch09-04-BinaryTrees.html"><strong aria-hidden="true">9.4.</strong> Binary Trees</a></li><li class="chapter-item expanded "><a href="ch09-05-SimpleRecursiveDescentParser.html"><strong aria-hidden="true">9.5.</strong> A Simple Recursive Descent Parser</a></li><li class="chapter-item expanded "><a href="ch09-06-Exercises.html"><strong aria-hidden="true">9.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch09-07-Quiz.html"><strong aria-hidden="true">9.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-GenericProgrammingandCollectionClasses.html"><strong aria-hidden="true">10.</strong> Generic Programmingand Collection Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-GenericProgramming.html"><strong aria-hidden="true">10.1.</strong> Generic Programming</a></li><li class="chapter-item expanded "><a href="ch10-02-ListsandSets.html"><strong aria-hidden="true">10.2.</strong> Lists and Sets</a></li><li class="chapter-item expanded "><a href="ch10-03-Maps.html"><strong aria-hidden="true">10.3.</strong> Maps</a></li><li class="chapter-item expanded "><a href="ch10-04-JCF.html"><strong aria-hidden="true">10.4.</strong> Programming with the JCF</a></li><li class="chapter-item expanded "><a href="ch10-05-WritingGenericClassesandMethods.html"><strong aria-hidden="true">10.5.</strong> Writing Generic Classes and Methods</a></li><li class="chapter-item expanded "><a href="ch10-06-StreamAPI.html"><strong aria-hidden="true">10.6.</strong> Stream APIs</a></li><li class="chapter-item expanded "><a href="ch10-07-Exercises.html"><strong aria-hidden="true">10.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch10-08-Quiz.html"><strong aria-hidden="true">10.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-IOStreamsFilesNetworking.html"><strong aria-hidden="true">11.</strong> I/O Streams, Files, and Networking</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-IOStreamsReadersAndWriters.html"><strong aria-hidden="true">11.1.</strong> I/O Streams, Readers, and Writers</a></li><li class="chapter-item expanded "><a href="ch11-02-Files.html"><strong aria-hidden="true">11.2.</strong> Files</a></li><li class="chapter-item expanded "><a href="ch11-03-ProgrammingWithFiles.html"><strong aria-hidden="true">11.3.</strong> Programming With Files</a></li><li class="chapter-item expanded "><a href="ch11-04-Networking.html"><strong aria-hidden="true">11.4.</strong> Networking</a></li><li class="chapter-item expanded "><a href="ch11-05-XML.html"><strong aria-hidden="true">11.5.</strong> A Brief Introduction to XML</a></li><li class="chapter-item expanded "><a href="ch11-06-Exercises.html"><strong aria-hidden="true">11.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch11-07-Quiz.html"><strong aria-hidden="true">11.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-ThreadsandMultiprocessing.html"><strong aria-hidden="true">12.</strong> Threads and Multiprocessing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-IntroductiontoThreads.html"><strong aria-hidden="true">12.1.</strong> Introduction to Threads</a></li><li class="chapter-item expanded "><a href="ch12-02-ProgrammingwithThreads.html"><strong aria-hidden="true">12.2.</strong> Programming with Threads</a></li><li class="chapter-item expanded "><a class="active" href="ch12-03-ThreadsandParallelProcessing.html"><strong aria-hidden="true">12.3.</strong> Threads and Parallel Processing</a></li><li class="chapter-item expanded "><a href="ch12-04-ThreadsandNetworking.html"><strong aria-hidden="true">12.4.</strong> Threads and Networking</a></li><li class="chapter-item expanded "><a href="ch12-05-NetworkProgrammingExample.html"><strong aria-hidden="true">12.5.</strong> Network Programming Example</a></li><li class="chapter-item expanded "><a href="ch12-06-Exercises.html"><strong aria-hidden="true">12.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch12-07-Quiz.html"><strong aria-hidden="true">12.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-GUIProgrammingContinued.html"><strong aria-hidden="true">13.</strong> GUI Programming Continued</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-PropertiesandBindings.html"><strong aria-hidden="true">13.1.</strong> Properties and Bindings</a></li><li class="chapter-item expanded "><a href="ch13-02-FancierGraphics.html"><strong aria-hidden="true">13.2.</strong> Fancier Graphics</a></li><li class="chapter-item expanded "><a href="ch13-03-ComplexComponentsandMVC.html"><strong aria-hidden="true">13.3.</strong> Complex Components and MVC</a></li><li class="chapter-item expanded "><a href="ch13-04-MostlyWindowsandDialogs.html"><strong aria-hidden="true">13.4.</strong> Mostly Windows and Dialogs</a></li><li class="chapter-item expanded "><a href="ch13-05-FinishingTouches.html"><strong aria-hidden="true">13.5.</strong> Finishing Touches</a></li><li class="chapter-item expanded "><a href="ch13-06-Exercises.html"><strong aria-hidden="true">13.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch13-07-Quiz.html"><strong aria-hidden="true">13.7.</strong> Quiz</a></li></ol><li class="chapter-item expanded "><a href="appendix-00.html"> Appendix</a></li><li class="chapter-item expanded "><a href="glossary-00.html"> Glossary</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="Java">Java</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Introduction to Programming Using Java</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Xayarsh/Java-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Threads and Parallel Processing"><a class="header" href="#Threads and Parallel Processing">Threads and Parallel Processing</a></h2>
                        <p>
                            The example in <a href="ch12-02-ProgrammingwithThreads.html">Subsection&nbsp;12.2.4</a> in
                            the previous section used parallel processing to execute pieces of a large task.  On a computer that
                            has several processors, this allows the computation to be
                            completed more quickly.  However, the way that the program divided up the
                            computation into subtasks was not optimal.  Nor was the way that the threads were managed.
                            In this section, we will look at two more versions of that program.  The first
                            improves the way the problem is decomposed into subtasks.  The second improves
                            the way threads are used.  Along the way, I'll introduce a couple of built-in classes
                            that Java provides to support parallel processing.  Later in the section, I will cover
                            <span class="code">wait()</span> and <span class="code">notify()</span>, lower-level methods that can be used to
                            control parallel processes more directly.</p>


                        <h3 id="Problem Decomposition"><a class="header" href="#Problem Decomposition">Problem Decomposition</a></h3>

                        <p>The sample program <span class="sourceref"><a href="./source/chapter12/MultiprocessingDemo1.java">MultiprocessingDemo1.java</a></span> divides the task of
                            computing an image into several subtasks and assigns each subtask to a thread. While this
                            works OK, there is a problem: Some of the subtasks might take substantially longer than
                            others. The program divides the image up into equal parts, but the fact is that some
                            parts of the image require more computation than others.  In fact, if you run the program
                            with three threads, you'll notice that the middle piece takes a little longer to compute than the
                            top or bottom piece.  In general, when dividing a problem into subproblems, it is very hard
                            to predict just how much time it will take to solve each subproblem.  Let's say that
                            one particular subproblem happens to take a lot longer than all the others.  The thread
                            that computes that subproblem will continue to run for a relatively long time after all
                            the other threads have completed. During that time, only <b>one</b> of the
                            computer's processors will be working; the rest will be idle.</p>


                        <p>As a simple example, suppose that your computer has two processors.  You divide the
                            problem into two subproblems and create a thread to run each subproblem  Your hope is
                            that by using both processors, you can get your answer in half the time that it would
                            take when using one processor.  But if one subproblem takes four times longer than
                            the other to solve, then for most of the time, only one processor will be working.
                            In this case, you will only have cut the time needed to get your answer by&nbsp;20%.</p>


                        <p>Even if you manage to divide your problem into subproblems that require equal
                            amounts of computation, you still can't depend on all the subproblems requiring
                            equal amounts of time to solve.  For example, some of the processors
                            on your computer might be busy running other programs.  Or perhaps some of the processors
                            are simply slower than others.  (This is not so likely when running your computation on
                            a single computer, but when distributing computation across several networked
                            computers, as we will do later in this chapter, differences in processor speed
                            can be a major issue.)</p>


                        <p>The common technique for dealing with all this is to divide the problem into
                            a fairly large number of subproblems&mdash;many more subproblems than there are
                            processors.  This means that each processor will have to solve several subproblems.
                            Each time a processor completes one subtask, it is assigned another subtask
                            to work on, until all the subtasks have been assigned.   Of course, there will
                            still be variation in the time that the various subtasks require.  One processor
                            might complete several subproblems while another works on one particularly difficult
                            case.  And a slow or busy processor might complete only one or two subproblems
                            while another processor finishes five or six.  Each processor can work at its
                            own pace. As long as the subproblems are fairly small, most of the processors can
                            be kept busy until near the end of the computation.  This is known as <span class="newword">load
balancing</span>:  the computational load is balanced among the available processors
                            in order to keep them all as busy as possible.  Of course, some processors
                            will still finish before others, but not by longer than the time it takes to
                            complete the longest subtask.</p>


                        <p>While the subproblems should be small, they should not be <b>too</b> small.  There
                            is some computational overhead involved in creating the subproblems and assigning them
                            to processors.  If the subproblems are very small, this overhead can add significantly
                            to the total amount of work that has to be done.  In my example program, the task is
                            to compute a color for each pixel in an image.  For dividing that task up into subtasks,
                            one possibility would be to have each subtask compute just one pixel.  But the subtasks
                            produced in that way are probably too small.  So, instead, each subtask in my program
                            computes the colors for one row of pixels.  Since there are several hundred
                            rows of pixels in the image, the number of subtasks will be fairly large, while each
                            subtask will also be fairly large.  The result is fairly good load balancing, with
                            a reasonable amount of overhead.</p>


                        <p>Note, by the way, that the problem that we are working on is a very easy one
                            for parallel programming.  When we divide the problem of calculating an image into
                            subproblems, all the subproblems are completely independent.  It is possible to
                            work on any number of them simultaneously, and they can be done in any order.
                            Things get a lot more complicated when some subtasks produce results that
                            are required by other subtasks.  In that case, the subtasks are not independent,
                            and the order in which the subtasks are performed is important.  Furthermore,
                            there has to be some way for results from one subtask to be shared with other
                            tasks.  When the subtasks are executed by different threads, this raises all
                            the issues involved in controlling access of threads to shared resources.  So,
                            in general, decomposing a problem for parallel processing is much more difficult
                            than it might appear from our relatively simple example.  But for the most part,
                            that's a topic for a course in parallel computing, not an introductory
                            programming course.</p>


                        <h3 id="Thread Pools and Task Queues"><a class="header" href="#Thread Pools and Task Queues">Thread Pools and Task Queues</a></h3>

                        <p>Once we have decided how to decompose a task into subtasks, there is the question of
                            how to assign those subtasks to threads.  Typically, in an object-oriented approach,
                            each subtask will be represented
                            by an object.  Since a task represents some computation, it's natural for the
                            object that represents it to have an instance method that does the computation.
                            To execute the task, it is only necessary to call its computation method.  In my
                            program, the computation method is called <span class="code">run()</span> and the task object
                            implements the standard <span class="classname">Runnable</span> interface that was discussed in
                            <a href="ch12-01-IntroductiontoThreads.html">Subsection&nbsp;12.1.1</a>.  This interface is a natural way to represent computational tasks.
                            It's possible to create a new thread for each <span class="classname">Runnable</span>.
                            However, that doesn't really make sense when there are
                            many tasks, since there is a significant amount of overhead involved in
                            creating each new thread.  A better alternative is to create just a few threads and let
                            each thread execute a number of tasks.</p>


                        <p>The optimal number of threads to use is not entirely clear, and it can depend on
                            exactly what problem you are trying to solve.  The goal is to keep all of the computer's
                            processors busy.  In the image-computing example, it works well to create one thread
                            for each available processor, but that won't be true for all problems.  In particular,
                            if a thread can block for a non-trivial amount of time while waiting for some event or
                            for access to some resource, you want to have extra threads around for the processor to
                            run while other threads are blocked.  We'll encounter exactly that situation when
                            we turn to using threads with networking in <a href="ch12-04-ThreadsandNetworking.html">Section&nbsp;12.4</a>.</p>


                        <p>When several threads are available for performing tasks, those threads are called
                            a <span class="newword">thread pool</span>.  Thread pools are used to avoid creating a new
                            thread to perform each task.  Instead, when a task needs to be performed, it can
                            be assigned to any idle thread in the "pool."</p>


                        <p>Once all the threads in the thread pool are busy, any additional tasks will have
                            to wait until one of the threads becomes idle.  This is a natural application for
                            a queue:  Associated with the thread pool is a queue of waiting tasks.  As tasks
                            become available, they are added to the queue.  Every time that a thread finishes
                            a task, it goes to the queue to get another task to work on.</p>


                        <p>Note that there is only one task queue for the thread pool.
                            All the threads in the pool use the same queue, so the queue is a shared resource.
                            As always with shared resources, race conditions are possible and synchronization
                            is essential.  Without synchronization, for example, it is possible that two threads trying
                            to get items from the queue at the same time will end up retrieving the same item.
                            (See if you can spot the race conditions in the <span class="code">dequeue()</span> method in
                            <a href="ch09-03-StacksQueuesADTs.html">Subsection&nbsp;9.3.2</a>.)</p>


                        <p>Java has a built-in class to solve this problem:
                            <span class="classname">ConcurrentLinkedQueue</span>.  This class and others that can
                            be useful in parallel programming are defined in the package <span class="code">java.util.concurrent</span>.
                            It is a parameterized class; to create a queue that can hold objects
                            of type <span class="classname">Runnable</span>, you can say</p>


                        <pre><code class="java">ConcurrentLinkedQueue&lt;Runnable&gt; queue = new ConcurrentLinkedQueue&lt;&gt;();</code></pre>


                        <p>This class represents a queue, implemented as a linked list, in which operations
                            on the queue are properly synchronized.  The operations on a <span class="classname">ConcurrentLinkedQueue</span>
                            are not exactly the queue operations that we are used to.  The method for adding a new
                            item, <span class="code">x</span>, to the end of <span class="code">queue</span> is <span class="codedef">queue.add(x)</span>.  The method for
                            removing an item from the front of <span class="code">queue</span> is <span class="codedef">queue.poll()</span>.  The
                            <span class="code">queue.poll()</span> method returns <span class="code">null</span> if the queue is empty; thus, <span class="code">poll()</span>
                            can be used to test whether the queue is empty and to retrieve an item if it is not.  It makes sense
                            to do things in this way because testing whether the queue is non-empty before taking
                            an item from the queue involves a race condition: Without synchronization, it is possible for another thread
                            to remove the last item from the queue between the time when you check that the queue is
                            non-empty and the time when you try to take the item from the queue.  By the time you try
                            to get the item, there's nothing there!  On the other hand, <span class="code">queue.poll()</span>
                            is an "atomic" operation (<a href="ch12-01-IntroductiontoThreads.html">Subsection&nbsp;12.1.5</a>).</p>





                        <p>To use <span class="classname">ConcurrentLinkedQueue</span> in our image-computing example,
                            we can use the queue along with a thread pool.  To begin the computation of the image,
                            we create all the tasks that make up the image and add them to the queue.
                            Then, we can create and start the worker threads that will execute the tasks. Each thread will
                            run in a loop in which it gets one task from the queue, by calling the queue's <span class="code">poll()</span>
                            method, and carries out that task.  Since
                            the task is an object of type <span class="classname">Runnable</span>, it is only necessary
                            for the thread to call the task's <span class="code">run()</span> method.  When the <span class="code">poll()</span>
                            method returns <span class="code">null</span>, the queue is empty and the thread can terminate because
                            all the tasks have been assigned to threads.</p>


                        <p>The sample program <span class="sourceref"><a href="./source/chapter12/MultiprocessingDemo2.java">MultiprocessingDemo2.java</a></span> implements this idea.
                            It uses a queue, <span class="code">taskQueue</span>, of type <span class="classname">ConcurrentLinkedQueue&lt;Runnable&gt;</span>
                            to hold the tasks.  In addition, in order to allow the user to abort the computation before it
                            finishes, it uses the <span class="code">volatile</span> <span class="ptype">boolean</span> variable <span class="code">running</span>
                            to signal the thread when the user aborts the computation.  The thread should terminate
                            when this variable is set to <span class="code">false</span>, even if there are still tasks
                            remaining in the queue.  The threads are defined by a nested
                            class named <span class="classname">WorkerThread</span>.  It is quite short and simple to write:</p>



                        <pre><code class="java">private class WorkerThread extends Thread {
    public void run() {
        try {
            while (running) {
                Runnable task = taskQueue.poll(); // Get a task from the queue.
                if (task == null)
                    break; // (because the queue is empty)
                task.run();  // Execute the task;
            }
        }
        finally {
            threadFinished(); // Records fact that this thread has terminated.
                              // Done in finally to make sure it gets called.
        }
    }
}</code></pre>


                        <p>The program uses a nested class named <span class="code">MandelbrotTask</span> to represent the task
                            of computing one row of pixels in the image.  This class implements the <span class="classname">Runnable</span>
                            interface.  Its <span class="code">run()</span> method does the actual work, that is, compute the color
                            of each pixel, and apply the colors to the image.  Here is what the program does to start the
                            computation (with a few details omitted):</p>


                        <pre><code class="java">taskQueue = new ConcurrentLinkedQueue&lt;Runnable&gt;(); // Create the queue.
for (int row = 0; row &lt; height; row++) {  // height is number of rows in image
    MandelbrotTask task;
    task = ... ;  // Create a task to compute one row of the image.
    taskQueue.add(task); // Add the task to the queue.
}

int threadCount = ... ; // Number of threads in the pool (selected by user).
workers = new WorkerThread[threadCount];
running = true;  // Set the signal before starting the threads!
threadsRemaining = workers;  // Records how many threads are still running.
for (int i = 0; i &lt; threadCount; i++) {
    workers[i] = new WorkerThread();
    try {
        workers[i].setPriority( Thread.currentThread().getPriority() - 1 );
    }
    catch (Exception e) {
    }
    workers[i].start();
}</code></pre>


                        <p>Note that it is important that the tasks be added to the queue <b>before</b>
                            the threads are started.  The threads see an empty queue as a signal to terminate.
                            If the queue is empty when the threads are started, they might see an empty queue
                            and terminate immediately after being started, without performing any tasks!</p>


                        <p>You should try out <span class="code">MultiprocessingDemo2</span>.
                            It computes the same image as <span class="code">MultiprocessingDemo1</span>, but the rows of pixels are
                            not computed in the same order as in that program (if there is more than one thread).
                            If you look carefully,
                            you might see that the rows of pixels are not added to the image in strict order from
                            top to bottom.  This is because it is possible for one thread to finish row number
                            <span class="code">i+1</span> while another thread is still working on row <span class="code">i</span>, or even
                            earlier rows.  (The effect might be more apparent if you use more threads than
                            you have processors.  Try it with 20 threads.)</p>


                        <h3 id="Producer/Consumer and Blocking Queues"><a class="header" href="#Producer/Consumer and Blocking Queues">Producer/Consumer and Blocking Queues</a></h3>


                        <p>
                            <span class="code">MultiprocessingDemo2</span> creates an entirely new thread pool every
                            time it draws an image.  This seems wasteful.  Shouldn't it be possible to create
                            one set of threads at the beginning of the program and use them whenever an
                            image needs to be computed?  After all, the idea of a thread pool is that the
                            threads should sit around and wait for tasks to come along and should execute
                            them when they do.  The problem is that, so far, we have no way to make a
                            thread <i>wait</i> for a task to come along.  To do that, we will use something
                            called a <span class="newword">blocking queue</span>.</p>


                        <p>A blocking queue is an implementation of one of the classic patterns in
                            parallel processing: the <span class="newword">producer/consumer</span> pattern.
                            This pattern arises when there are one or more "producers" who produce things
                            and one or more "consumers" who consume those things.  All the producers and
                            consumers should be able to work simultaneously (hence, parallel processing).
                            If there are no things ready to be processed, a consumer will have to wait
                            until one is produced.  In many applications, producers also have to wait
                            sometimes:  If things can only be consumed at a rate of, say, one per minute,
                            it doesn't make sense for the producers to produce them indefinitely at a
                            rate of two per minute.  That would just lead to an unlimited build-up of
                            things waiting to be processed.  Therefore, it's often useful to put a limit
                            on the number of things that can be waiting for processing.  When that limit
                            is reached, producers should wait before producing more things.</p>


                        <p>We need a way to get the things from the producers to the consumers.  A queue
                            is an obvious answer:  Producers place items into the queue as they
                            are produced.  Consumers remove items from the other end of the queue.</p>


                        <p align="center">
                            <img src="./images/producer-consumer.png" width="499" height="206" alt="producers and consumers connected by a queue"></p>


                        <p>We are talking parallel processing, so we need a synchronized queue, but
                            we need more than that.  When the queue is empty, we need a way to have
                            consumers <i>wait</i> until an item appears in the queue.  If the queue
                            becomes full, we need a way to have producers <i>wait</i> until a space
                            opens up in the queue.  In our application, the producers and consumers are
                            threads.  A thread that is suspended, waiting for something to happen, is
                            said to be blocked, and the type of queue that we need is called
                            a blocking queue.  In a blocking queue, the operation of dequeueing an
                            item from the queue can block if the queue is empty.  That is, if a thread
                            tries to dequeue an item from an empty queue, the thread will be
                            suspended until an item becomes available; at that time, it will wake up,
                            retrieve the item, and proceed.  Similarly, if the queue has a limited
                            capacity, a producer that tries to enqueue an item can block if there
                            is no space in the queue.</p>


                        <p>Java has two classes that implement blocking queues: <span class="classname">LinkedBlockingQueue</span>
                            and <span class="classname">ArrayBlockingQueue</span>.  These are parameterized types
                            to allow you to specify the type of item that the queue can hold.
                            Both classes are defined in the package
                            <span class="code">java.util.concurrent</span> and both implement an interface called
                            <span class="classname">BlockingQueue</span>.  If <span class="code">bqueue</span> is a blocking
                            queue belonging to one of these classes, then the following operations are
                            defined:</p>


                        <ul>

                            <li>
                                <span class="codedef">bqueue.take()</span> -- Removes an item from the queue and
                                returns it.  If the queue is empty when this method is called, the thread
                                that called it will block until an item becomes available.  This method
                                throws an <span class="classname">InterruptedException</span> if the thread is
                                interrupted while it is blocked.</li>

                            <li>
                                <span class="codedef">bqueue.put(item)</span> -- Adds the <span class="code">item</span> to the queue.
                                If the queue has a limited capacity and is full, the thread that called it
                                will block until a space opens up in the queue. This method
                                throws an <span class="classname">InterruptedException</span> if the thread is
                                interrupted while it is blocked.</li>

                            <li>
                                <span class="codedef">bqueue.add(item)</span> -- Adds the <span class="code">item</span> to the queue,
                                if space is available.  If the queue has a limited capacity and is full,
                                an <span class="classname">IllegalStateException</span> is thrown.  This method
                                does not block.</li>

                            <li>
                                <span class="codedef">bqueue.clear()</span> -- Removes all items from the queue
                                and discards them.</li>

                        </ul>


                        <p>Java's blocking queues define many additional methods (for example,
                            <span class="code">bqueue.poll(500)</span> is similar to <span class="code">bqueue.take()</span>,
                            except that it will not block for longer than 500 milliseconds), but the
                            four listed here are sufficient for our purposes.  Note that I have
                            listed two methods for adding items to the queue:  <span class="code">bqueue.put(item)</span>
                            blocks if there is not space available in the queue and is most appropriate for use
                            with blocking queues that have a limited capacity; <span class="code">bqueue.add(item)</span>
                            does not block and is most appropriate for use with blocking queues that have an
                            unlimited capacity.</p>


                        <p>An <span class="classname">ArrayBlockingQueue</span> has a maximum capacity that
                            is specified when it is constructed.  For example, to create a blocking
                            queue that can hold up to 25  objects of type <span class="classname">ItemType</span>,
                            you could say:</p>


                        <pre><code class="java">ArrayBlockingQueue&lt;ItemType&gt; bqueue = new ArrayBlockingQueue&lt;&gt;(25);</code></pre>


                        <p>With this declaration, <span class="code">bqueue.put(item)</span> will block if <span class="code">bqueue</span>
                            already contains 25 items, while <span class="code">bqueue.add(item)</span> will throw an exception
                            in that case.  Recall that this ensures that items are not produced indefinitely
                            at a rate faster than they can be consumed.  A <span class="classname">LinkedBlockingQueue</span>
                            is meant for creating blocking queues with unlimited capacity.  For example,</p>


                        <pre><code class="java">LinkedBlockingQueue&lt;ItemType&gt; bqueue = new LinkedBlockingQueue&lt;&gt;();</code></pre>


                        <p>creates a queue with no upper limit on the number of items that it can contain.
                            In this case, <span class="code">bqueue.put(item)</span> will never block and <span class="code">bqueue.add(item)</span>
                            will never throw an <span class="code">IllegalStateException</span>.  You would use a
                            <span class="classname">LinkedBlockingQueue</span> when you want to avoid blocking of producers,
                            and you have some other way of ensuring that the queue will not grow to arbitrary
                            size.  For both types of blocking queue, <span class="code">bqueue.take()</span> will block
                            if the queue is empty.</p>





                        <p>The sample program <span class="sourceref"><a href="./source/chapter12/MultiprocessingDemo3.java">MultiprocessingDemo3.java</a></span> uses a
                            <span class="classname">LinkedBlockingQueue</span>  in place of the
                            <span class="classname">ConcurrentLinkedQueue</span> in the previous version,
                            <span class="sourceref"><a href="./source/chapter12/MultiprocessingDemo2.java">MultiprocessingDemo2.java</a></span>.  In this example, the queue
                            holds tasks, that is, items of type <span class="classname">Runnable</span>, and
                            the queue is declared as an instance variable named <span class="code">taskQueue</span>:
                        </p>


                        <pre><code class="java">LinkedBlockingQueue&lt;Runnable&gt; taskQueue;</code></pre>


                        <p>When the user clicks the "Start" button and it's time to compute
                            an image, all of the tasks that make up the computation are put into this
                            queue.  This is done by calling <span class="code">taskQueue.add(task)</span> for
                            each task.  It's important that this can be done without blocking,
                            since the tasks are created in the event-handling thread, and we don't
                            want to block that.  The queue in this program cannot grow indefinitely because the program
                            only works on one image at a time, and there are only a few hundred tasks
                            per image.</p>


                        <p>Just as in the previous version of the program, worker threads belonging
                            to a thread pool will remove tasks from the queue and carry them out.  However,
                            in this case, the threads are created once at the beginning of the program&mdash;actually,
                            the first time the "Start" button is pressed&mdash;and the same threads are
                            reused for any number of images.  When there are no tasks to execute, the
                            task queue is empty and the worker threads will block until tasks become available.
                            Each worker thread runs in an infinite loop, processing tasks forever, but it
                            will spend a lot of its time blocked, waiting for a task to be added to the
                            queue.  Here is the inner class that defines the worker threads:
                        </p>


                        <pre><code class="java">/**
 * This class defines the worker threads that make up the thread pool.
 * A WorkerThread runs in a loop in which it retrieves a task from the
 * taskQueue and calls the run() method in that task.  Note that if
 * the queue is empty, the thread blocks until a task becomes available
 * in the queue.  The constructor starts the thread, so there is no
 * need for the main program to do so.  The thread will run at a priority
 * that is one less than the priority of the thread that calls the
 * constructor.
 *
 * A WorkerThread is designed to run in an infinite loop.  It will
 * end only when the Java virtual machine exits. (This assumes that
 * the tasks that are executed don't throw exceptions, which is true
 * in this program.)  The constructor sets the thread to run as
 * a daemon thread; the Java virtual machine will exit automatically when
 * the only threads are daemon threads, so the existence of the thread
 * pool will not stop the JVM from exiting.
 */
private class WorkerThread extends Thread {
    WorkerThread() {
        try {
            setPriority( Thread.currentThread().getPriority() - 1);
        }
        catch (Exception e) {
        }
        try {
            setDaemon(true);
        }
        catch (Exception e) {
        }
        start(); // Thread starts as soon as it is constructed.
    }
    public void run() {
        while (true) {
            try {
                Runnable task = taskQueue.take(); // wait for task if necessary
                task.run();
            }
            catch (InterruptedException e) {
            }
        }
    }
}</code></pre>


                        <p>We should look more closely at how the thread pool works.  The worker threads
                            are created and started before there is any task to perform.  Each thread
                            immediately calls <span class="code">taskQueue.take()</span>.  Since the task queue is empty,
                            all the worker threads will block as soon as they are started.  To start the
                            computation of an image, the event-handling thread will create tasks and
                            add them to the queue.  As soon as this happens, worker threads will wake
                            up and start processing tasks, and they will continue doing so until the
                            queue is emptied.  (Note that on a multi-processor computer, some worker threads
                            can start processing even while the event thread is still adding tasks to the queue.)
                            When the queue is empty, the worker threads will go back to sleep until processing
                            starts on the next image.</p>





                        <p>An interesting point in this program is that we want to be
                            able to abort the computation before it finishes, but we don't want
                            the worker threads to terminate when that happens.  When the user
                            clicks the "Abort" button, the program calls <span class="code">taskQueue.clear()</span>,
                            which prevents any more tasks from being assigned to worker threads.
                            However, some tasks are most likely already being executed when the
                            task queue is cleared. Those tasks will complete <b>after</b> the
                            computation in which they are subtasks has supposedly been aborted.
                            When those subtasks complete, we don't want their output to be
                            applied to the image.</p>


                        <p>My solution is to assign a job number to each computation job.  The job number
                            of the current job is stored in an instance variable named <span class="code">jobNum</span>,
                            and each task object has an instance variable that tells which task that job is
                            part of.  When a job ends&mdash;either because the job finishes on its own
                            or because the user aborts it&mdash;the value of <span class="code">jobNum</span> is
                            incremented.  When a task completes, the job number stored in the
                            task object is compared to <span class="code">jobNum</span>.  If they are equal, then the
                            task is part of the current job, and its output is applied to the image.
                            If they are not equal, then the task was part of a previous job, and its output
                            is discarded.</p>


                        <p>It's important that access to <span class="code">jobNum</span> be properly synchronized.
                            Otherwise, one thread might check the job number just as another thread is
                            incrementing it, and output meant for an old job might sneak through
                            after that job has been aborted.  In the program, all the methods that
                            access or change <span class="code">jobNum</span> are synchronized.  You can
                            read the <span class="sourceref"><a href="./source/chapter12/MultiprocessingDemo3.java">source&nbsp;code</a></span>
                            to see how it works.</p>


                        <p>One more point about <span class="code">MultiprocessingDemo3</span>.... I have not provided
                            any way to terminate the worker threads in this program.  They will continue to
                            run until the Java Virtual Machine exits.  To allow thread termination before that,
                            we could use a <span class="code">volatile</span> signaling variable, <span class="code">running</span>,
                            and set its value to <span class="code">false</span> when we want the worker threads to terminate.
                            The <span class="code">run()</span> methods for the threads would be replaced by</p>


                        <pre><code class="java">public void run() {
    while ( <span class="newcode">running</span> ) {
       try {
          Runnable task = taskQueue.take();
          task.run();
       }
       catch (InterruptedException e) {
       }
    }
}</code></pre>


                        <p>However, if a thread is blocked in <span class="code">taskQueue.take()</span>, it
                            will not see the new value of <span class="code">running</span> until it becomes unblocked.
                            To ensure that that happens, it is necessary to call <span class="code">worker.interrupt()</span>
                            for each worker thread <span class="code">worker</span>, just after setting
                            <span class="code">runner</span> to <span class="code">false</span>.</p>


                        <p>If a worker thread is executing a task when <span class="code">running</span> is set to
                            <span class="code">false</span>, the thread will not terminate until that task has completed.
                            If the tasks are reasonably short, this is not a problem.  If tasks can take longer
                            to execute than you are willing to wait for the threads to terminate, then
                            each task must also check the value of <span class="code">running</span> periodically and
                            exit when that value becomes <span class="code">false</span>.</p>


                        <h3 id="The ExecutorService Approach"><a class="header" href="#The ExecutorService Approach">The ExecutorService Approach</a></h3>

                        <p>Since thread pools are common in parallel programming, it is not
                            surprising that Java has higher level tools for creating and managing
                            thread pools.  The interface <span class="classname">ExecutorService</span>,
                            in package <span class="code">java.util.concurrent</span>, defines services that
                            can execute tasks that are submitted to it.  Class <span class="classname">Executors</span>
                            contains <span class="code">static</span> methods that can be used to create
                            <span class="classname">ExecutorServices</span> of various types.  In
                            particular, <span class="code">Executors.newFixedThreadPool(n)</span>, where <span class="code">n</span>
                            is an <span class="ptype">int</span>, creates a thread pool with <span class="code">n</span> threads.
                            To get a thread pool with one thread per available processor, you can say</p>


                        <pre><code class="java">int processors = Runtime.getRuntime().availableProcessors();
ExecutorService executor = Executors.newFixedThreadPool(processors);</code></pre>


                        <p>The method <span class="code">executor.execute(task)</span> can be used to
                            submit a <span class="classname">Runnable</span> object, <span class="code">task</span>,
                            for execution.  The method returns immediately after placing
                            <span class="code">task</span> into a queue of waiting tasks.  Threads in the
                            thread pool remove tasks from the queue and execute them.</p>


                        <p>The method <span class="code">executor.shutdown()</span> tells the thread pool
                            to shut down after all waiting tasks have been executed.  The method
                            returns immediately, without waiting for the threads to finish.
                            After this method has been called, it is not legal to add new tasks.
                            It is <b>not</b> an error to call <span class="code">shutdown()</span> more than once.
                            The threads in the thread pool are not
                            daemon threads; if the service is not shut down, the existence of the threads
                            will stop the Java Virtual Machine from shutting down after other
                            threads have exited.  Before exiting, the threads
                            in the pool will complete any tasks they have already removed from
                            the queue.</p>


                        <p>The method <span class="code">executor.shutdownNow()</span> is similar to
                            <span class="code">executor.shutdown()</span> but it discards any waiting
                            tasks that are still in the queue, and tries to stop any tasks
                            that are currently being executed.</p>


                        <p>The sample program <span class="sourceref"><a href="./source/chapter12/MultiprocessingDemo4.java">MultiprocessingDemo4.java</a></span> is a
                            variation on <span class="code">MultiprocessingDemo3</span> that uses an
                            <span class="classname">ExecutorService</span> instead of using threads
                            and a blocking queue directly.  (Since I have not found an easy
                            way to get an <span class="code">ExecutorService</span> to drop
                            waiting tasks without shutting down, <span class="code">MultiprocessingDemo4</span>
                            creates a new <span class="code">ExecutorService</span> each time it computes
                            a new image.)</p>





                        <p>Tasks for an <span class="classname">ExecutorService</span> can also be
                            represented by objects of type <span class="atype">Callable&lt;T&gt;</span>,
                            which is a parameterized functional interface that defines the
                            method <span class="code">call()</span> with no parameters and a return type
                            of&nbsp;<span class="classname">T</span>.  A&nbsp;<span class="classname">Callable</span>
                            represents a task that outputs a value.</p>


                        <p>A <span class="classname">Callable</span>, <span class="code">c</span>,
                            can be submitted to an <span class="classname">ExecutorService</span>
                            by calling <span class="code">executor.submit(c)</span>. The  <span class="code">Callable</span>
                            will then be executed at some future time.  The problem is,
                            how to get the result of the computation when it completes?
                            This problem is solved by another interface,
                            <span class="atype">Future&lt;T&gt;</span>, which represents a value of
                            type <span class="classname">T</span> that might not be available until
                            some future time.  The method <span class="code">executor.submit(c)</span>
                            returns a <span class="classname">Future</span> that represents the
                            result of the future computation.</p>


                        <p>A <span class="classname">Future</span>, <span class="code">v</span>, defines
                            several methods, including <span class="code">v.isDone()</span>, which is a
                            <span class="ptype">boolean</span>-valued function that can be called
                            to check whether the result is available; and
                            <span class="code">v.get()</span>, which will retrieve the value of the future.  The method
                            <span class="code">v.get()</span> will block until the value is available.
                            It can also generate exceptions and needs to be called in
                            a <span class="code">try..catch</span> statement.</p>


                        <p>As an example, <span class="sourceref"><a href="./source/chapter12/ThreadTest4.java">ThreadTest4.java</a></span> uses
                            <span class="classname">Callables</span>, <span class="classname">Futures</span>,
                            and an <span class="classname">ExecutorService</span> to count the number
                            of primes in a certain range of integers.  (This is the same
                            rather useless computation that was done by <span class="sourceref"><a href="./source/chapter12/ThreadTest2.java">ThreadTest2.java</a></span>
                            in <a href="ch12-01-IntroductiontoThreads.html">Subsection&nbsp;12.1.3</a>.)  In this program, a subtask
                            counts the primes in a subrange of integers. The subtasks
                            are represented by objects of type <span class="atype">Callable&lt;Integer&gt;</span>,
                            defined by this nested class:</p>


                        <pre><code class="java">/**
 * An object belonging to this class will count primes in a specified range
 * of integers.  The range is from min to max, inclusive, where min and max
 * are given as parameters to the constructor.  The counting is done in
 * the call() method, which returns the number of primes that were found.
 */
private static class CountPrimesTask implements Callable&lt;Integer&gt; {
    int min, max;
    public CountPrimesTask(int min, int max) {
        this.min = min;
        this.max = max;
    }
    public Integer call() {
        int count = countPrimes(min,max);  // does the counting
        return count;
    }
}</code></pre>


                        <p>All the subtasks are submitted to a thread pool implemented as an
                            <span class="classname">ExecutorService</span>, and the <span class="classname">Futures</span>
                            that are returned are saved in an array list.  In outline:</p>


                        <pre><code class="java">int processors = Runtime.getRuntime().availableProcessors();
ExecutorService executor = Executors.newFixedThreadPool(processors);

ArrayList&lt;Future&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;();

for (int i = 0; i &lt; numberOfTasks; i++) {

    CountPrimesTask oneTask = . . . ;
    Future&lt;Integer&gt; oneResult = executor.submit( oneTask );
    results.add(oneResult);  // Save the Future representing the (future) result.

}</code></pre>


                        <p>The integers that are output by all the subtasks need to be added up to
                            give a final result.  The outputs of the subtasks are obtained
                            using the <span class="code">get()</span> methods of the <span class="code">Futures</span>
                            in the list.  Since <span class="code">get()</span> blocks until the result
                            is available, the process completes only when all subtasks have
                            finished:</p>


                        <pre><code class="java">int total = 0;
for ( Future&lt;Integer&gt; res : results) {
    try {
        total += res.get();  // Waits for task to complete!
    }
    catch (Exception e) { // Should not occur in this program.
    }
}</code></pre>



                        <h3 id="Wait and Notify"><a class="header" href="#Wait and Notify">Wait and Notify</a></h3>

                        <p>Suppose that we wanted to implement our own blocking queue.
                            To do that, we must be able to make a thread
                            block just until some event occurs.   The thread is <i>waiting</i>
                            for the event to occur.  Somehow, it must be <i>notified</i>
                            when that happens.  There are two threads involved since the
                            event that will wake one thread is caused by an action taken
                            by another thread, such as adding an item to the queue.</p>


                        <p>Note that this is not just an issue for blocking queues.
                            Whenever one thread produces some sort of result that is needed by
                            another thread, that imposes some restriction on the order in which the threads
                            can do their computations.  If the second thread gets to the point where it
                            needs the result from the first thread, it might have to stop and wait for
                            the result to be produced.  Since the second thread can't continue, it might
                            as well go to sleep.  But then there has to be some way to notify the second thread
                            when the result is ready, so that it can wake up and continue its computation.</p>


                        <p>Java, of course, has a way to do this kind of "waiting" and "notifying":  It has
                            <span class="code">wait()</span> and <span class="code">notify()</span> methods that are defined as
                            instance methods in class <span class="classname">Object</span> and so can be used
                            with any object.  These methods can be used internally in blocking queues.
                            They are fairly low-level, tricky, and error-prone, and you should use
                            higher-level control strategies such as blocking queues when possible.
                            However, it's nice to know about <span class="code">wait()</span> and <span class="code">notify()</span>
                            in case you ever need to use them directly.
                            (I don't know whether they are actually used in Java's standard blocking queue classes,
                            since Java has other ways of solving the wait/notify problem.)
                        </p>


                        <p>The reason why <span class="code">wait()</span> and
                            <span class="code">notify()</span> should be associated with objects is not obvious, so
                            don't worry about it at this point.  It does, at least, make it possible
                            to direct different notifications to different recipients, depending on
                            which object's <span class="code">notify()</span> method is called.</p>


                        <p>The general idea is that when a thread calls a <span class="code">wait()</span> method
                            in some object, that thread goes to sleep until the <span class="code">notify()</span> method
                            in the <b>same</b> object is called.  It will have to be called, obviously, by
                            another thread, since the thread that called <span class="code">wait()</span> is sleeping.
                            A typical pattern is that Thread&nbsp;A calls <span class="code">wait()</span> when it
                            needs a result from Thread&nbsp;B, but that result is not yet available.  When Thread&nbsp;B
                            has the result ready, it calls <span class="code">notify()</span>, which will wake
                            Thread&nbsp;A up, if it is waiting, so that it can use the result.  It is not an error to call
                            <span class="code">notify()</span> when no one is waiting; it just has no effect.  To implement this,
                            Thread&nbsp;A will execute code similar to the following, where <span class="code">obj</span> is
                            some object:</p>


                        <pre><code class="java">if ( resultIsAvailable() == false )
   obj.wait();  // wait for notification that the result is available
useTheResult();</code></pre>


                        <p>while Thread&nbsp;B does something like:</p>


                        <pre><code class="java">generateTheResult();
obj.notify();  // send out a notification that the result is available</code></pre>


                        <p>Now, there is a really nasty race condition in this code.  The two threads
                            might execute their code in the following order:</p>


                        <pre><code class="java">1.  Thread A checks resultIsAvailable() and finds that the result is not ready,
        so it decides to execute the obj.wait() statement, but before it does,
2.  Thread B finishes generating the result and calls obj.notify()
3.  Thread A calls obj.wait() to wait for notification that the result is ready.</code></pre>


                        <p>In Step 3, Thread A is waiting for a notification that will never come,
                            because <span class="code">notify()</span> has already been called in Step&nbsp;2.  This is a kind of
                            deadlock that can leave Thread&nbsp;A waiting forever.  Obviously, we need
                            some kind of synchronization.  The solution is to enclose both Thread&nbsp;A's
                            code and Thread&nbsp;B's code in <span class="code">synchronized</span> statements, and
                            it is very natural to synchronize on the same object, <span class="code">obj</span>,
                            that is used for the calls to <span class="code">wait()</span> and <span class="code">notify()</span>.
                            In fact, since synchronization is almost always needed when
                            <span class="code">wait()</span> and <span class="code">notify()</span> are used, Java makes
                            it an absolute requirement.  In Java, a thread can legally call
                            <span class="code">obj.wait()</span> or <span class="code">obj.notify()</span>
                            <b>only</b> if that thread holds the synchronization lock
                            associated with the object <span class="code">obj</span>.  If it does not hold that
                            lock, then an exception is thrown.  (The exception is of type
                            <span class="classname">IllegalMonitorStateException</span>, which does not
                            require mandatory handling and which is typically not caught.)
                            One further complication is that the <span class="code">wait()</span> method can throw
                            an <span class="classname">InterruptedException</span> and so should be called in
                            a <span class="code">try</span> statement that handles the exception.</p>


                        <p>To make things more definite, let's consider how we can get a result that
                            is computed by one thread to another thread that needs the result.  This
                            is a simplified producer/consumer problem in which only one item is produced
                            and consumed.  Assume that there is a shared variable named <span class="code">sharedResult</span> that is
                            used to transfer the result from the producer to the consumer.  When the
                            result is ready, the producer sets the variable to a non-null value.
                            The consumer can check whether the result is ready by testing whether
                            the value of <span class="code">sharedResult</span> is null.  We will use a variable named
                            <span class="code">lock</span> for synchronization.  The code for the producer thread
                            could have the form:</p>


                        <pre><code class="java">makeResult = generateTheResult();  // Not synchronized!
synchronized(lock) {
   sharedResult = makeResult;
   lock.notify();
}</code></pre>


                        <p>while the consumer would execute code such as:</p>


                        <pre><code class="java">synchronized(lock) {
   while ( sharedResult == null ) {
      try {
         lock.wait();
      }
      catch (InterruptedException e) {
      }
   }
   useResult = sharedResult;
}
useTheResult(useResult);  // Not synchronized!</code></pre>


                        <p>The calls to <span class="code">generateTheResult()</span> and <span class="code">useTheResult()</span>
                            are not synchronized, which allows them to run in parallel with other threads that
                            might also synchronize on <span class="code">lock</span>.  Since <span class="code">sharedResult</span>
                            is a shared variable, all references to <span class="code">sharedResult</span> should be synchronized,
                            so the references to <span class="code">sharedResult</span> must be inside the <span class="code">synchronized</span> statements.
                            The goal is to do as little as possible (but not less) in synchronized code segments.</p>


                        <p>If you are uncommonly alert, you might notice something funny:  <span class="code">lock.wait()</span>
                            does not finish until <span class="code">lock.notify()</span> is executed, but since both of these
                            methods are called in <span class="code">synchronized</span> statements that synchronize on the same
                            object, shouldn't it be impossible for both methods to be running at the same time?
                            In fact, <span class="code">lock.wait()</span> is a special case:  When a thread calls
                            <span class="code">lock.wait()</span>, it gives up the lock that it holds on the synchronization object.
                            This gives another thread a chance to execute the <span class="code">synchronized(lock)</span> block
                            that contains the <span class="code">lock.notify()</span> statement.  After the second thread
                            exits from this block, the lock is returned to the consumer thread so that it can continue.</p>


                        <p>In the full producer/consumer pattern, multiple results are produced by one or
                            more producer threads and are consumed by one or more consumer threads.  Instead of
                            having just one <span class="code">sharedResult</span> object, we keep a list of objects that have
                            been produced but not yet consumed.  Let's see how this might work in a very
                            simple class that implements the three operations on a <span class="classname">LinkedBlockingQueue&lt;Runnable&gt;</span>
                            that are used in <span class="sourceref"><a href="./source/chapter12/MultiprocessingDemo3.java">MultiprocessingDemo3</a></span>:</p>



                        <pre><code class="java">import java.util.LinkedList;

public class MyLinkedBlockingQueue {

    private LinkedList&lt;Runnable&gt; taskList = new LinkedList&lt;Runnable&gt;();

    public void clear() {
        synchronized(taskList) {
            taskList.clear();
        }
    }

    public void add(Runnable task) {
        synchronized(taskList) {
            taskList.addLast(task);
            taskList.notify();
        }
    }

    public Runnable take() throws InterruptedException {
        synchronized(taskList) {
            while (taskList.isEmpty())
                taskList.wait();
            return taskList.removeFirst();
        }
    }

}</code></pre>


                        <p>An object of this class can be used as a direct replacement for the
                            <span class="code">taskQueue</span> in <span class="code">MultiprocessingDemo3</span>.</p>


                        <p>In this class, I have chosen to synchronize on the <span class="code">taskList</span> object,
                            but any object could be used.  In fact, I could simply use <span class="code">synchronized</span>
                            methods, which is equivalent to synchronizing on <span class="code">this</span>.  (Note that
                            you might see a call to <span class="code">wait()</span> or <span class="code">notify()</span> in a
                            <span class="code">synchronized</span> instance method, with no reference to the object that is being used.
                            Remember that <span class="code">wait()</span> and <span class="code">notify()</span> in that context
                            really mean <span class="code">this.wait()</span> and <span class="code">this.notify()</span>.)</p>


                        <p>By the way, it is essential that the call to <span class="code">taskList.clear()</span> be
                            synchronized on the same object, even though it doesn't call <span class="code">wait()</span>
                            or <span class="code">notify()</span>.  Otherwise, there is a race condition that can
                            occur: The list might be cleared just after the <span class="code">take()</span> method checks
                            that <span class="code">taskList</span> is non-empty and before it removes an item from the
                            list.  In that case, the list is empty again by the time <span class="code">taskList.removeFirst()</span>
                            is called, resulting in an error.</p>


                        <p>It is possible for several threads to
                            be waiting for notification.  A call to <span class="code">obj.notify()</span> will wake only one
                            of the threads that is waiting on <span class="code">obj</span>.  If you want to wake all threads
                            that are waiting on <span class="code">obj</span>, you can call <span class="code">obj.notifyAll()</span>.
                            <span class="code">obj.notify()</span> works OK in the above example because only consumer threads
                            can be blocked.  We only need to wake one consumer thread when a task is added
                            to the queue, and it doesn't matter which consumer gets the task.  But consider
                            a blocking queue with limited capacity, where producers and consumers can both
                            block.  When an item is added to the queue, we want to make sure that a consumer
                            thread is notified, not just another producer. One solution is
                            to call <span class="code">notifyAll()</span> instead of <span class="code">notify()</span>,
                            which will notify all threads including any waiting consumer.</p>


                        <p>I should also mention a possible confusion about the name of the method <span class="code">obj.notify()</span>.
                            This method does <b>not</b> notify <span class="code">obj</span> of anything!  It notifies a
                            thread that has called <span class="code">obj.wait()</span> (if there is such a thread).  Similarly,
                            in <span class="code">obj.wait()</span>, it's <b>not</b> <span class="code">obj</span> that is waiting for something;
                            it's the thread that calls the method.</p>


                        <p>And
                            a final note on <span class="code">wait</span>:  There is another version of <span class="code">wait()</span>
                            that takes a number of milliseconds as a parameter.  A thread that calls <span class="code">obj.wait(milliseconds)</span>
                            will wait only up to the specified number of milliseconds for a notification.  If a notification
                            doesn't occur during that period, the thread will wake up and continue without the notification.
                            In practice, this feature is most often used to let a waiting thread wake periodically while it
                            is waiting in order to perform some periodic task, such as causing a message "Waiting for
                            computation to finish" to blink.</p>



                        <p>Let's look at an example that uses <span class="code">wait()</span> and <span class="code">notify()</span>
                            to allow one thread to control another.  The sample program
                            <span class="sourceref"><a href="./source/chapter12/TowersOfHanoiGUI.java">TowersOfHanoiGUI.java</a></span> solves the Towers Of Hanoi
                            puzzle (<a href="ch09-01-Recursion.html">Subsection&nbsp;9.1.2</a>), with control buttons that allow the
                            user to control the execution of the algorithm.  The user can click a "Next Step"
                            button to execute just one step in the solution,
                            which moves a single disk from one pile to another.  Clicking "Run" lets the algorithm
                            run automatically on its own; the text on the button changes from "Run" to "Pause",
                            and clicking "Pause" stops the automatic
                            execution. There is also a "Start Over" button that aborts the current solution
                            and puts the puzzle back into its initial configuration. Here is a picture of
                            the program in the middle of a solution, including the buttons:</p>


                        <p align="center">
                            <img src="./images/towers-of-hanoi-gui.png" width="438" height="181" alt="Towers of Hanoi"></p>


                        <p>In this program, there are two threads: a thread that runs a recursive algorithm
                            to solve the puzzle, and the event-handling thread that reacts to user actions.
                            When the user clicks one of the buttons, a method is called in the event-handling
                            thread. But it's actually the thread that is running the recursion that has to
                            respond by, for example, doing one step of the solution or starting over.
                            The event-handling thread has to send some sort of signal to the solution thread.
                            This is done by setting the value of a variable that is shared by both threads.
                            The variable is named <span class="code">status</span>, and its possible values are the
                            constants <span class="code">GO</span>, <span class="code">PAUSE</span>, <span class="code">STEP</span>, and
                            <span class="code">RESTART</span>.</p>


                        <p>When the event-handling thread changes the value
                            of this variable, the solution thread should see the new value and respond.
                            When <span class="code">status</span> equals <span class="code">PAUSE</span>, the solution thread is paused, waiting for
                            the user to click "Run" or "Next Step".  This is the initial state, when the program
                            starts.  If the user clicks "Next Step", the event-handling
                            thread sets the value of <span class="code">status</span> to "STEP"; the solution thread should see the new value and
                            respond by executing one step of the solution and then resetting <span class="code">status</span>
                            to <span class="code">PAUSE</span>.  If the user clicks "Run", <span class="code">status</span> is set to
                            <span class="code">GO</span>, which should cause the solution thread to run automatically.
                            When the user clicks "Pause" while the solution is running,
                            <span class="code">status</span> is reset to <span class="code">PAUSE</span>, and the solution thread should return
                            to its paused state.  If the user clicks "Start Over", the event-handling
                            thread sets <span class="code">status</span> to <span class="code">RESTART</span>, and the solution thread
                            should respond by ending the current recursive solution.</p>


                        <p>The main point for us is that when the solution thread is paused, it is
                            <i>sleeping</i>.  It won't see a new value for <span class="code">status</span> unless it
                            wakes up!  To make that possible, the program uses <span class="code">wait()</span> in
                            the solution thread to put that thread to sleep, and it uses
                            <span class="code">notify()</span> in the event-handling thread to wake up the
                            solution thread whenever it changes the value of <span class="code">status</span>.
                            Here are the methods that respond to
                            clicks on the buttons.  When the user clicks a button, the corresponding method
                            changes the value of <span class="code">status</span> and calls <span class="code">notify()</span>
                            to wake up the solution thread:</p>


                        <pre><code class="java">synchronized private void doStopGo() {
    if (status == GO) {  // Animation is running.  Pause it.
        status = PAUSE;
        nextStepButton.setDisable(false);
        runPauseButton.setText("Run");
    }
    else {  // Animation is paused.  Start it running.
        status = GO;
        nextStepButton.setDisable(true);  // Disabled when animation is running
        runPauseButton.setText("Pause");
    }
    notify();  // Wake up the thread so it can see the new status value!
}

synchronized private void doNextStep() {
    status = STEP;
    notify();
}

synchronized private void doRestart() {
    status = RESTART;
    notify();
}</code></pre>


                        <p>These methods are synchronized to allow the calls to <span class="code">notify()</span>.
                            Remember that the <span class="code">notify()</span> method in an object can only
                            be called by a thread that holds that object's synchronization lock.
                            In this case, the synchronization object is <span class="code">this</span>.
                            Synchronization is also necessary because of race conditions that
                            arise due to the fact that the value of <span class="code">status</span> can also be changed
                            by the solution thread.</p>


                        <p>The solution thread calls a method named <span class="code">checkStatus()</span>
                            to check the value of <span class="code">status</span>.  This method calls
                            <span class="code">wait()</span> if the status is <span class="code">PAUSE</span>, which
                            puts the solution thread to sleep until the event-handling
                            thread calls <span class="code">notify()</span>.  Note that if the
                            status is <span class="code">RESTART</span>, <span class="code">checkStatus()</span> throws
                            an <span class="classname">IllegalStateException</span>:</p>


                        <pre><code class="java">synchronized private void checkStatus() {
    while (status == PAUSE) {
        try {
            wait();
        }
        catch (InterruptedException e) {
        }
    }
    // At this point, status is RUN, STEP, or RESTART.
    if (status == RESTART)
        throw new IllegalStateException("Restart");
    // At this point, status is RUN or STEP, and the solution should proceed.
}</code></pre>



                        <p>The <span class="code">run()</span> method for the solution thread
                            sets up the initial state of the puzzle and then calls a
                            <span class="code">solve()</span> method to solve the puzzle.  It runs
                            in an infinite loop so that it can solve the puzzle multiple
                            times.  To implement the wait/notify control strategy,
                            <span class="code">run()</span> calls <span class="code">checkStatus()</span> before starting
                            the solution, and <span class="code">solve()</span> calls <span class="code">checkStatus()</span>
                            after each move.  If <span class="code">checkStatus()</span> throws an
                            <span class="classname">IllegalStateException</span>, the call to <span class="code">solve()</span>
                            is terminated early.  (We used the method of throwing an exception to terminate
                            a recursive algorithm before, in <a href="ch12-02-ProgrammingwithThreads.html">Subsection&nbsp;12.2.2</a>.)</p>


                        <p>You can check the full <span class="sourceref"><a href="./source/chapter12/TowersOfHanoiGUI.java">source code</a></span>
                            to see how this all fits into the complete program.  If you want to learn how
                            to use <span class="code">wait()</span> and <span class="code">notify()</span> directly, understanding
                            this example is a good place to start!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch12-02-ProgrammingwithThreads.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch12-04-ThreadsandNetworking.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch12-02-ProgrammingwithThreads.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch12-04-ThreadsandNetworking.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </body>
</html>
