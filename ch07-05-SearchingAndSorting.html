<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Searching and Sorting - Introduction to Programming Using Java</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

<link rel="stylesheet" href="code-class.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html" >Introduction to Programming Using Java</a></li><li class="chapter-item expanded affix "><a href="preface.html">Preface</a></li><li class="chapter-item expanded "><a href="ch01-00-Overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-FetchExecuteCycle.html"><strong aria-hidden="true">1.1.</strong> Fetch and Execute Cycle</a></li><li class="chapter-item expanded "><a href="ch01-02-AsynchronousEvents.html"><strong aria-hidden="true">1.2.</strong> Asynchronous Events</a></li><li class="chapter-item expanded "><a href="ch01-03-JavaVirtualMachine.html"><strong aria-hidden="true">1.3.</strong> The Java Virtual Machine</a></li><li class="chapter-item expanded "><a href="ch01-04-FundamentalBuildingBlocks.html"><strong aria-hidden="true">1.4.</strong> Fundamentals</a></li><li class="chapter-item expanded "><a href="ch01-05-OOP.html"><strong aria-hidden="true">1.5.</strong> Object Oriented Programming</a></li><li class="chapter-item expanded "><a href="ch01-06-ModernUserInterface.html"><strong aria-hidden="true">1.6.</strong> Modern User Interface</a></li><li class="chapter-item expanded "><a href="ch01-07-InternetAndBeyond.html"><strong aria-hidden="true">1.7.</strong> Internet and Beyond</a></li><li class="chapter-item expanded "><a href="ch01-08-Quiz.html"><strong aria-hidden="true">1.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-NameAndThings.html"><strong aria-hidden="true">2.</strong> Name and Things</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-BasicJavaApplication.html"><strong aria-hidden="true">2.1.</strong> Basic Java Application</a></li><li class="chapter-item expanded "><a href="ch02-02-VariablesAndTypes.html"><strong aria-hidden="true">2.2.</strong> Variables and Types</a></li><li class="chapter-item expanded "><a href="ch02-03-ObjectsAndSubroutines.html"><strong aria-hidden="true">2.3.</strong> Objects and Subroutines</a></li><li class="chapter-item expanded "><a href="ch02-04-TextInputAndOutput.html"><strong aria-hidden="true">2.4.</strong> Text Input and Output</a></li><li class="chapter-item expanded "><a href="ch02-05-DetailsOfExpressions.html"><strong aria-hidden="true">2.5.</strong> Details of Expressions</a></li><li class="chapter-item expanded "><a href="ch02-06-ProgrammingEnvironments.html"><strong aria-hidden="true">2.6.</strong> Programming and Environments</a></li><li class="chapter-item expanded "><a href="ch02-07-Exercises.html"><strong aria-hidden="true">2.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch02-08-Quiz.html"><strong aria-hidden="true">2.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-Control.html"><strong aria-hidden="true">3.</strong> Control</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-BlocksLoopsBranches.html"><strong aria-hidden="true">3.1.</strong> Blocks, Loops and Branches</a></li><li class="chapter-item expanded "><a href="ch03-02-AlgorithmDevelopment.html"><strong aria-hidden="true">3.2.</strong> Algorithm Development</a></li><li class="chapter-item expanded "><a href="ch03-03-While.html"><strong aria-hidden="true">3.3.</strong> while and do...while</a></li><li class="chapter-item expanded "><a href="ch03-04-For.html"><strong aria-hidden="true">3.4.</strong> The for statement</a></li><li class="chapter-item expanded "><a href="ch03-05-If.html"><strong aria-hidden="true">3.5.</strong> The If Statement</a></li><li class="chapter-item expanded "><a href="ch03-06-Switch.html"><strong aria-hidden="true">3.6.</strong> The Switch Statement</a></li><li class="chapter-item expanded "><a href="ch03-07-ExceptionsTryCatch.html"><strong aria-hidden="true">3.7.</strong> Exceptions and try...catch</a></li><li class="chapter-item expanded "><a href="ch03-08-Arrays.html"><strong aria-hidden="true">3.8.</strong> Arrays: An Introduction</a></li><li class="chapter-item expanded "><a href="ch03-09-GUI.html"><strong aria-hidden="true">3.9.</strong> GUI: An Introduction</a></li><li class="chapter-item expanded "><a href="ch03-10-Exercises.html"><strong aria-hidden="true">3.10.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch03-11-Quiz.html"><strong aria-hidden="true">3.11.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-Subroutines.html"><strong aria-hidden="true">4.</strong> Subroutines</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-BlackBoxes.html"><strong aria-hidden="true">4.1.</strong> Black Boxes</a></li><li class="chapter-item expanded "><a href="ch04-02-StaticSubroutines.html"><strong aria-hidden="true">4.2.</strong> Static Subroutines and Variables</a></li><li class="chapter-item expanded "><a href="ch04-03-Parameters.html"><strong aria-hidden="true">4.3.</strong> Parameters</a></li><li class="chapter-item expanded "><a href="ch04-04-ReturnValues.html"><strong aria-hidden="true">4.4.</strong> Return Values</a></li><li class="chapter-item expanded "><a href="ch04-05-Lambda.html"><strong aria-hidden="true">4.5.</strong> Lambda Expressions</a></li><li class="chapter-item expanded "><a href="ch04-06-APIPackagesModulesJavadoc.html"><strong aria-hidden="true">4.6.</strong> API, Packages, Modules and Javadoc</a></li><li class="chapter-item expanded "><a href="ch04-07-MoreOnProgramDesign.html"><strong aria-hidden="true">4.7.</strong> More on Program Design</a></li><li class="chapter-item expanded "><a href="ch04-08-TruthAboutDeclarations.html"><strong aria-hidden="true">4.8.</strong> Truth about Declarations</a></li><li class="chapter-item expanded "><a href="ch04-09-Exercises.html"><strong aria-hidden="true">4.9.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch04-10-Quiz.html"><strong aria-hidden="true">4.10.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-ObjectsClasses.html"><strong aria-hidden="true">5.</strong> Objects and Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-ObjectsAndInstanceMethods.html"><strong aria-hidden="true">5.1.</strong> Objects and Instance Methods</a></li><li class="chapter-item expanded "><a href="ch05-02-ConstructorObjectInit.html"><strong aria-hidden="true">5.2.</strong> Constructor and Object Initialization</a></li><li class="chapter-item expanded "><a href="ch05-03-ProgrammingWithObjects.html"><strong aria-hidden="true">5.3.</strong> Programming with Objects</a></li><li class="chapter-item expanded "><a href="ch05-04-AnExample.html"><strong aria-hidden="true">5.4.</strong> An Example</a></li><li class="chapter-item expanded "><a href="ch05-05-InheritanceAndPolymorphism.html"><strong aria-hidden="true">5.5.</strong> Inheritance and Polymorphism</a></li><li class="chapter-item expanded "><a href="ch05-06-thisandsuper.html"><strong aria-hidden="true">5.6.</strong> this and super</a></li><li class="chapter-item expanded "><a href="ch05-07-Interfaces.html"><strong aria-hidden="true">5.7.</strong> Interfaces</a></li><li class="chapter-item expanded "><a href="ch05-08-NestedClasses.html"><strong aria-hidden="true">5.8.</strong> Nested Classes</a></li><li class="chapter-item expanded "><a href="ch05-09-Exercises.html"><strong aria-hidden="true">5.9.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch05-10-Quiz.html"><strong aria-hidden="true">5.10.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-GUIProgramming.html"><strong aria-hidden="true">6.</strong> Introduction to GUI Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-BasicJavaFXApp.html"><strong aria-hidden="true">6.1.</strong> A Basic JavaFX Application</a></li><li class="chapter-item expanded "><a href="ch06-02-BasicClasses.html"><strong aria-hidden="true">6.2.</strong> Basic Classes</a></li><li class="chapter-item expanded "><a href="ch06-03-BasicEvents.html"><strong aria-hidden="true">6.3.</strong> Basic Events</a></li><li class="chapter-item expanded "><a href="ch06-04-BasicControls.html"><strong aria-hidden="true">6.4.</strong> Basic Controls</a></li><li class="chapter-item expanded "><a href="ch06-05-BasicLayout.html"><strong aria-hidden="true">6.5.</strong> Basic Layout</a></li><li class="chapter-item expanded "><a href="ch06-06-CompetePrograms.html"><strong aria-hidden="true">6.6.</strong> Complete Programs</a></li><li class="chapter-item expanded "><a href="ch06-07-Exercises.html"><strong aria-hidden="true">6.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch06-08-Quiz.html"><strong aria-hidden="true">6.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-ArraysArraylistsRecords.html"><strong aria-hidden="true">7.</strong> Arrays, ArrayLists and Records</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-ArrayDetails.html"><strong aria-hidden="true">7.1.</strong> Array Details</a></li><li class="chapter-item expanded "><a href="ch07-02-ArrayProcessing.html"><strong aria-hidden="true">7.2.</strong> Array Processing</a></li><li class="chapter-item expanded "><a href="ch07-03-ArrayLists.html"><strong aria-hidden="true">7.3.</strong> ArrayLists</a></li><li class="chapter-item expanded "><a href="ch07-04-Records.html"><strong aria-hidden="true">7.4.</strong> Records</a></li><li class="chapter-item expanded "><a class="active" href="ch07-05-SearchingAndSorting.html"><strong aria-hidden="true">7.5.</strong> Searching and Sorting</a></li><li class="chapter-item expanded "><a href="ch07-06-2DArrays.html"><strong aria-hidden="true">7.6.</strong> 2D Arrays</a></li><li class="chapter-item expanded "><a href="ch07-07-Exercises.html"><strong aria-hidden="true">7.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch07-08-Quiz.html"><strong aria-hidden="true">7.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-CorrectnessRobustnessEfficiency.html"><strong aria-hidden="true">8.</strong> Correctness, Robustness, Efficiency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-IntroductionCorrectnessandRobustness.html"><strong aria-hidden="true">8.1.</strong> Introduction to Correctness and Robustness</a></li><li class="chapter-item expanded "><a href="ch08-02-WritingCorrectPrograms.html"><strong aria-hidden="true">8.2.</strong> Writing Correct Programs</a></li><li class="chapter-item expanded "><a href="ch08-03-ExceptionsAndtrycatch.html"><strong aria-hidden="true">8.3.</strong> Exceptions and try..catch</a></li><li class="chapter-item expanded "><a href="ch08-04-AssertionsAnnotations.html"><strong aria-hidden="true">8.4.</strong> Assertions and Annotations</a></li><li class="chapter-item expanded "><a href="ch08-05-AnalysisofAlgorithms.html"><strong aria-hidden="true">8.5.</strong> Analysis of Algorithms</a></li><li class="chapter-item expanded "><a href="ch08-06-Exercises.html"><strong aria-hidden="true">8.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch08-07-Quiz.html"><strong aria-hidden="true">8.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-LinkedDataStructuresRecursion.html"><strong aria-hidden="true">9.</strong> Linked Data Structures and Recursion</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-Recursion.html"><strong aria-hidden="true">9.1.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="ch09-02-LinkedDataStructures.html"><strong aria-hidden="true">9.2.</strong> Linked Data Structures</a></li><li class="chapter-item expanded "><a href="ch09-03-StacksQueuesADTs.html"><strong aria-hidden="true">9.3.</strong> Stacks, Queues and ADTs</a></li><li class="chapter-item expanded "><a href="ch09-04-BinaryTrees.html"><strong aria-hidden="true">9.4.</strong> Binary Trees</a></li><li class="chapter-item expanded "><a href="ch09-05-SimpleRecursiveDescentParser.html"><strong aria-hidden="true">9.5.</strong> A Simple Recursive Descent Parser</a></li><li class="chapter-item expanded "><a href="ch09-06-Exercises.html"><strong aria-hidden="true">9.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch09-07-Quiz.html"><strong aria-hidden="true">9.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-GenericProgrammingandCollectionClasses.html"><strong aria-hidden="true">10.</strong> Generic Programmingand Collection Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-GenericProgramming.html"><strong aria-hidden="true">10.1.</strong> Generic Programming</a></li><li class="chapter-item expanded "><a href="ch10-02-ListsandSets.html"><strong aria-hidden="true">10.2.</strong> Lists and Sets</a></li><li class="chapter-item expanded "><a href="ch10-03-Maps.html"><strong aria-hidden="true">10.3.</strong> Maps</a></li><li class="chapter-item expanded "><a href="ch10-04-JCF.html"><strong aria-hidden="true">10.4.</strong> Programming with the JCF</a></li><li class="chapter-item expanded "><a href="ch10-05-WritingGenericClassesandMethods.html"><strong aria-hidden="true">10.5.</strong> Writing Generic Classes and Methods</a></li><li class="chapter-item expanded "><a href="ch10-06-StreamAPI.html"><strong aria-hidden="true">10.6.</strong> Stream APIs</a></li><li class="chapter-item expanded "><a href="ch10-07-Exercises.html"><strong aria-hidden="true">10.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch10-08-Quiz.html"><strong aria-hidden="true">10.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-IOStreamsFilesNetworking.html"><strong aria-hidden="true">11.</strong> I/O Streams, Files, and Networking</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-IOStreamsReadersAndWriters.html"><strong aria-hidden="true">11.1.</strong> I/O Streams, Readers, and Writers</a></li><li class="chapter-item expanded "><a href="ch11-02-Files.html"><strong aria-hidden="true">11.2.</strong> Files</a></li><li class="chapter-item expanded "><a href="ch11-03-ProgrammingWithFiles.html"><strong aria-hidden="true">11.3.</strong> Programming With Files</a></li><li class="chapter-item expanded "><a href="ch11-04-Networking.html"><strong aria-hidden="true">11.4.</strong> Networking</a></li><li class="chapter-item expanded "><a href="ch11-05-XML.html"><strong aria-hidden="true">11.5.</strong> A Brief Introduction to XML</a></li><li class="chapter-item expanded "><a href="ch11-06-Exercises.html"><strong aria-hidden="true">11.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch11-07-Quiz.html"><strong aria-hidden="true">11.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-ThreadsandMultiprocessing.html"><strong aria-hidden="true">12.</strong> Threads and Multiprocessing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-IntroductiontoThreads.html"><strong aria-hidden="true">12.1.</strong> Introduction to Threads</a></li><li class="chapter-item expanded "><a href="ch12-02-ProgrammingwithThreads.html"><strong aria-hidden="true">12.2.</strong> Programming with Threads</a></li><li class="chapter-item expanded "><a href="ch12-03-ThreadsandParallelProcessing.html"><strong aria-hidden="true">12.3.</strong> Threads and Parallel Processing</a></li><li class="chapter-item expanded "><a href="ch12-04-ThreadsandNetworking.html"><strong aria-hidden="true">12.4.</strong> Threads and Networking</a></li><li class="chapter-item expanded "><a href="ch12-05-NetworkProgrammingExample.html"><strong aria-hidden="true">12.5.</strong> Network Programming Example</a></li><li class="chapter-item expanded "><a href="ch12-06-Exercises.html"><strong aria-hidden="true">12.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch12-07-Quiz.html"><strong aria-hidden="true">12.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-GUIProgrammingContinued.html"><strong aria-hidden="true">13.</strong> GUI Programming Continued</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-PropertiesandBindings.html"><strong aria-hidden="true">13.1.</strong> Properties and Bindings</a></li><li class="chapter-item expanded "><a href="ch13-02-FancierGraphics.html"><strong aria-hidden="true">13.2.</strong> Fancier Graphics</a></li><li class="chapter-item expanded "><a href="ch13-03-ComplexComponentsandMVC.html"><strong aria-hidden="true">13.3.</strong> Complex Components and MVC</a></li><li class="chapter-item expanded "><a href="ch13-04-MostlyWindowsandDialogs.html"><strong aria-hidden="true">13.4.</strong> Mostly Windows and Dialogs</a></li><li class="chapter-item expanded "><a href="ch13-05-FinishingTouches.html"><strong aria-hidden="true">13.5.</strong> Finishing Touches</a></li><li class="chapter-item expanded "><a href="ch13-06-Exercises.html"><strong aria-hidden="true">13.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch13-07-Quiz.html"><strong aria-hidden="true">13.7.</strong> Quiz</a></li></ol><li class="chapter-item expanded "><a href="appendix-00.html"> Appendix</a></li><li class="chapter-item expanded "><a href="glossary-00.html"> Glossary</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="Java">Java</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Introduction to Programming Using Java</h1>

                    <div class="right-buttons">

                        <a href="https://github.com/Xayarsh/Java-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Searching and Sorting"><a class="header" href="#Searching and Sorting">Searching and Sorting</a></h2>
                        <p>
                            Two array processing techniques that are
                            particularly common are <span class="newword">searching</span> and <span class="newword">sorting</span>.
                            Searching here refers to finding an item in the array
                            that meets some specified criterion. Sorting refers to rearranging all the
                            items in the array into increasing or decreasing order (where the meaning of
                            increasing and decreasing can depend on the context).  We have seen in
                            <a href="ch07-02-ArrayProcessing.html">Subsection&nbsp;7.2.2</a> that Java has some built-in methods for searching
                            and sorting arrays.  However, a computer science student should be familiar
                            with the algorithms that are used in those methods.  In this section,
                            you will learn some algorithms for searching and sorting.</p>


                        <p>Sorting and searching are often discussed, in a theoretical sort of way,
                            using an array of numbers as an example. In practical situations, though, more
                            interesting types of data are usually involved. For example, the array might be
                            a mailing list, and each element of the array might be an object containing a
                            name and address. Given the name of a person, you might want to look up that
                            person's address. This is an example of searching, since you want to find the
                            object in the array that contains the given name. It would also be useful to be
                            able to sort the array according to various criteria. One example of sorting
                            would be ordering the elements of the array so that the names are in
                            alphabetical order. Another example would be to order the elements of the array
                            according to zip code before printing a set of mailing labels.</p>


                        <p>This example can be generalized to a more abstract situation in which we
                            have an array that contains objects, and we want to search or sort the array
                            based on the value of one of the instance variables in the objects.  In that case, we might use
                            the terminology of "records" and "fields" that originated in work with
                            databases, as discussed in the <a href="ch07-04-Records.html">previous section</a>.
                            In the mailing list example, we might have an array of records where
                            each record contains a first name, last name, street address, state,
                            city, and zip code as fields. For the purpose of searching or sorting, one of the fields
                            is designated to be the <span class="newword">key</span> field. Searching then
                            means finding a record in the array that has a specified value in its key
                            field. Sorting means moving the records around in the array so that the key
                            fields of the record are in increasing (or decreasing) order.</p>


                        <p>In this section, most of my examples follow the tradition of using arrays of
                            numbers. But I'll also give a few examples using objects, to remind
                            you of the more practical applications.</p>

                        

                        <h3 id="Searching"><a class="header" href="#Searching">Searching</a></h3>
                        

                        <p>There is an obvious algorithm for searching for a particular item in an
                            array: Look at each item in the array in turn, and check whether that item is
                            the one you are looking for. If so, the search is finished. If you look at
                            every item without finding the one you want, then you can be sure that the item
                            is not in the array. It's easy to write a subroutine to implement this
                            algorithm. Let's say the array that you want to search is an array of
                            <span class="ptype">ints</span>. Here is a method that will search the array for a specified
                            integer. If the integer is found, the method returns the index of the location
                            in the array where it is found. If the integer is not in the array, the method
                            returns the value <span class="code">-1</span> as a signal that the integer could not be
                            found:</p>


                        <pre><code class="java">/**
 * Searches the array A for the integer N.  If N is not in the array,
 * then -1 is returned.  If N is in the array, then the return value is
 * the first integer i that satisfies A[i] == N.
 */
static int find(int[] A, int N) {

   for (int index = 0; index &lt; A.length; index++) {
      if ( A[index] == N )
         return index;  // N has been found at this index!
   }

   // If we get this far, then N has not been found
   // anywhere in the array.  Return a value of -1.

   return -1;

}</code></pre>


                        <p>This method of searching an array by looking at each item in turn is called
                            <span class="newword">linear search</span>. If nothing is known about the order
                            of the items in the array, then there is really no better alternative
                            algorithm. But if the elements in the array are known to be in increasing or
                            decreasing order, then a much faster search algorithm can be used. An array in
                            which the elements are in order is said to be <span class="newword">sorted</span>.
                            Of course, it takes some work to sort an array, but if
                            the array is to be searched many times, then the work done in sorting it can
                            really pay off.</p>


                        <p>
                            <span class="newword">Binary search</span> is a method for searching for a
                            given item in a <b>sorted</b> array. Although the implementation is not
                            trivial, the basic idea is simple: If you are searching for an item in a sorted
                            list, then it is possible to eliminate half of the items in the list by
                            inspecting a single item. For example, suppose that you are looking for the
                            number 42 in a sorted array of 1000 integers. Let's assume that the array is
                            sorted into increasing order. Suppose you check item number 500 in the array,
                            and find that the item is 93. Since 42 is less than 93, and since the elements
                            in the array are in increasing order, we can conclude that if 42 occurs in the
                            array at all, then it must occur somewhere before location 500. All the
                            locations numbered 500 or above contain values that are greater than or equal
                            to 93. These locations can be eliminated as possible locations of the number
                            42.</p>


                        <p>Once we know that 42 can only be in the first half of the array,
                            the obvious next step is to check location 250. If the number at that
                            location is, say, -21, then you can eliminate locations before 250 and limit
                            further search to locations between 251 and 499. The next test will limit the
                            search to about 125 locations, and the one after that to about 62. After just
                            10 steps, there is only one location left. This is a whole lot better than
                            looking through every element in the array. If there were a million items, it
                            would still take only 20 steps for binary search to search the array!
                            (Mathematically, the number of steps is approximately equal to
                            the logarithm, in the base 2, of the number of items in the array.)</p>


                        <p>In order to make binary search into a Java subroutine that searches an array,
                            <span class="code">A</span>, for an item, <span class="code">N</span>, we just have to keep track of the range of locations
                            that could possibly contain <span class="code">N</span>. At each step, as we eliminate
                            possibilities, we reduce the size of this range. The basic operation is to look
                            at the item in the middle of the range. If this item is greater than
                            <span class="code">N</span>, then the second half of the range can be eliminated. If it is less
                            than <span class="code">N</span>, then the first half of the range can be eliminated. If the
                            number in the middle just happens to be <span class="code">N</span> exactly, then the search is
                            finished. If the size of the range decreases to zero, then the number
                            <span class="code">N</span> does not occur in the array. Here is a subroutine that implements
                            this idea:</p>


                        <pre><code class="java">/**
 * Searches the array A for the integer N.
 * Precondition:  A must be sorted into increasing order.
 * Postcondition: If N is in the array, then the return value, i,
 *    satisfies A[i] == N.  If N is not in the array, then the
 *    return value is -1.
 */
static int binarySearch(int[] A, int N) {

    int lowestPossibleLoc = 0;
    int highestPossibleLoc = A.length - 1;

    while (highestPossibleLoc &gt;= lowestPossibleLoc) {
       int middle = (lowestPossibleLoc + highestPossibleLoc) / 2;
       if (A[middle] == N) {
                 // N has been found at this index!
          return middle;
       }
       else if (A[middle] &gt; N) {
                 // eliminate locations &gt;= middle
          highestPossibleLoc = middle - 1;
       }
       else {
                 // eliminate locations &lt;= middle
          lowestPossibleLoc = middle + 1;
       }
    }

    // At this point, highestPossibleLoc &lt; lowestPossibleLoc,
    // which means that N is known to be not in the array.  Return
    // a -1 to indicate that N could not be found in the array.

    return -1;

}</code></pre>
                        

                        <h3 id="Association Lists"><a class="header" href="#Association Lists">Association Lists</a></h3>
                       
                        <p>One particularly common application of searching is with <span class="newword">association lists</span>.
                            The standard example of an association list
                            is a dictionary. A dictionary associates definitions with words. Given a word,
                            you can use the dictionary to look up its definition. We can think of the
                            dictionary as being a list of <span class="newword">pairs</span> of the form
                            <span class="code">(w,d)</span>, where <span class="code">w</span> is a word and <span class="code">d</span> is its definition. A
                            general association list is a list of pairs <span class="code">(k,v)</span>, where <span class="code">k</span> is
                            some "key" value, and <span class="code">v</span> is a value associated to that key. In general,
                            we want to assume that no two pairs in the list have the same key. There are two basic
                            operations on association lists:  Given a key, <span class="code">k</span>, find the value
                            <span class="code">v</span> associated with <span class="code">k</span>, if any.  And given a key, <span class="code">k</span>,
                            and a value <span class="code">v</span>, add the pair <span class="code">(k,v)</span> to the association list
                            (replacing the pair, if any, that had the same key value).  The two operations
                            are usually called <span class="newword">get</span> and <span class="newword">put</span>.</p>


                        <p>Association lists are very widely used in computer science. For example, a
                            compiler has to keep track of the location in memory associated with each
                            variable. It can do this with an association list in which each key is a
                            variable name and the associated value is the address of that variable in
                            memory. Another example would be a mailing list, if we think of it as
                            associating an address to each name on the list. As a related example, consider
                            a phone directory that associates a phone number to each name.  We'll look
                            at a highly simplified version of this example.  (This is <b>not</b> meant to be
                            a realistic way to implement a phone directory!)</p>


                        <p>The items in the phone directory's association list could be objects belonging to the class:</p>


                        <pre><code class="java">class PhoneEntry {
   String name;
   String phoneNum;
}</code></pre>


                        <p>The data for a phone directory consists of an array of type
                            <span class="atype">PhoneEntry[]</span> and an integer variable to keep track of how many entries
                            are actually stored in the directory.  The technique of dynamic arrays
                            (<a href="ch07-02-ArrayProcessing.html">Subsection&nbsp;7.2.4</a>) can be used in order to avoid putting an arbitrary limit on
                            the number of entries that the phone directory can hold.
                            A <span class="classname">PhoneDirectory</span> class should include instance methods
                            that implement the "get" and "put" operations.  Here is one possible simple
                            definition of the class:</p>


                        <pre><code class="java">import java.util.Arrays;

/**
 * A PhoneDirectory holds a list of names with a phone number for
 * each name.  It is possible to find the number associated with
 * a given name, and to specify the phone number for a given name.
 */
public class PhoneDirectory {

   /**
    * An object of type PhoneEntry holds one name/number pair.
    */
   private static class PhoneEntry {
      String name;     // The name.
      String number;   // The associated phone number.
   }

   private PhoneEntry[] data;  // Array that holds the name/number pairs.
   private int dataCount;      // The number of pairs stored in the array.

   /**
    * Constructor creates an initially empty directory.
    */
   public PhoneDirectory() {
      data = new PhoneEntry[1];
      dataCount = 0;
   }

   /**
    * Looks for a name/number pair with a given name.  If found, the index
    * of the pair in the data array is returned.  If no pair contains the
    * given name, then the return value is -1.  This private method is
    * used internally in getNumber() and putNumber().
    */
   private int find( String name ) {
      for (int i = 0; i &lt; dataCount; i++) {
         if (data[i].name.equals(name))
            return i;  // The name has been found in position i.
      }
      return -1;  // The name does not exist in the array.
   }

   /**
    * Finds the phone number, if any, for a given name.
    * @return The phone number associated with the name; if the name does
    *    not occur in the phone directory, then the return value is null.
    */
   public String getNumber( String name ) {
      int position = find(name);
      if (position == -1)
         return null;   // There is no phone entry for the given name.
      else
         return data[position].number;
   }

   /**
    * Associates a given name with a given phone number.  If the name
    * already exists in the phone directory, then the new number replaces
    * the old one.  Otherwise, a new name/number pair is added.  The
    * name and number should both be non-null.  An IllegalArgumentException
    * is thrown if this is not the case.
    */
   public void putNumber( String name, String number ) {
      if (name == null || number == null)
         throw new IllegalArgumentException("name and number cannot be null");
      int i = find(name);
      if (i &gt;= 0) {
             // The name already exists, in position i in the array.
             // Just replace the old number at that position with the new.
         data[i].number = number;
      }
      else {
            // Add a new name/number pair to the array.  If the array is
            // already full, first create a new, larger array.
         if (dataCount == data.length) {
            data = Arrays.copyOf( data, 2*data.length );
         }
         PhoneEntry newEntry = new PhoneEntry();  // Create a new pair.
         newEntry.name = name;
         newEntry.number = number;
         data[dataCount] = newEntry;   // Add the new pair to the array.
         dataCount++;
      }
   }

} // end class PhoneDirectory</code></pre>


                        <p>The class defines a private instance method, <span class="code">find()</span>, that
                            uses linear search to find the position of a given name in the
                            array of name/number pairs.  The <span class="code">find()</span> method is used both in the
                            <span class="code">getNumber()</span> method and in the <span class="code">putNumber()</span> method.
                            Note in particular that <span class="code">putNumber(name,number)</span> has to check whether the
                            name is in the phone directory. If so, it just changes the number in the
                            existing entry; if not, it has to create a new phone entry and add it to the
                            array.</p>


                        <p>This class could also have be written using an ArrayList (<a href="ch07-03-ArrayLists.html">Section&nbsp;7.3</a>)
                            instead of a dynamic array.  And the nested <span class="classname">PhoneEntry</span> class is a
                            natural candidate to be a record class (<a href="ch07-04-Records.html">Section&nbsp;7.4</a>).  For a version that
                            uses these ideas, see <span class="sourceref"><a href="./source/chapter7/PhoneDirectory2.java">PhoneDirectory2.java</a></span>.</p>


                        <p>This phone directory implementation could be improved by using
                            binary search instead of simple linear search in the <span class="code">find()</span>
                            method. However, we could only do that if the list of <span class="classname">PhoneEntries</span>
                            were sorted into alphabetical order according to name. In fact, it's really not all that
                            hard to keep the list of entries in sorted order, as you'll see in the
                            next subsection.</p>


                        <p>I will mention that association lists are also called "maps," and Java has
                            a standard parameterized type named <span class="classname">Map</span> that implements
                            association lists for keys and values of any type.  The implementation is
                            more efficient than anything you can do with basic arrays. You will encounter this
                            class in <a href="ch10-03-Maps.html">Section&nbsp;10.3</a>.</p>

                        
                        <h3 id="Insertion Sort"><a class="header" href="#Insertion Sort">Insertion Sort</a></h3>

                        <p>We've seen that there are good reasons for sorting arrays. There are many
                            algorithms available for doing so. One of the easiest to understand is the
                            <span class="newword">insertion sort</span> algorithm. This technique is also
                            applicable to the problem of <b>keeping</b> a list in sorted order as you add
                            new items to the list. Let's consider that case first:</p>


                        <p>Suppose you have a sorted list and you want to add an item to that list. If
                            you want to make sure that the modified list is still sorted, then the item
                            must be inserted into the right location, with all the smaller items coming
                            before it and all the bigger items after it. This will mean moving each of the
                            bigger items up one space to make room for the new item.</p>


                        <pre><code class="java">/*
 * Precondition:  itemsInArray is the number of items that are
 *    stored in A.  These items must be in increasing order
 *    (A[0] &lt;= A[1] &lt;= ... &lt;= A[itemsInArray-1]).
 *    The array size is at least one greater than itemsInArray.
 * Postcondition:  The number of items has increased by one,
 *    newItem has been added to the array, and all the items
 *    in the array are still in increasing order.
 * Note:  To complete the process of inserting an item in the
 *    array, the variable that counts the number of items
 *    in the array must be incremented, after calling this
 *    subroutine.
 */
static void insert(int[] A, int itemsInArray, int newItem) {

   int loc = itemsInArray - 1;  // Start at the end of the array.

   /* Move items bigger than newItem up one space;
      Stop when a smaller item is encountered or when the
      beginning of the array (loc == 0) is reached. */

   while (loc &gt;= 0 &amp;&amp; A[loc] &gt; newItem) {
      A[loc + 1] = A[loc];  // Bump item from A[loc] up to loc+1.
      loc = loc - 1;        // Go on to next location.
   }

   A[loc + 1] = newItem;  // Put newItem in last vacated space.

}</code></pre>


                        <p>Conceptually, this could be extended to a sorting method if we were to take
                            all the items out of an unsorted array, and then insert them back into the
                            array one-by-one, keeping the list in sorted order as we do so. Each insertion
                            can be done using the <span class="code">insert</span> routine given above. In the actual
                            algorithm, we don't really take all the items from the array; we just remember
                            what part of the array has been sorted:</p>


                        <pre><code class="java">static void insertionSort(int[] A) {
      // Sort the array A into increasing order.

   int itemsSorted; // Number of items that have been sorted so far.

   for (itemsSorted = 1; itemsSorted &lt; A.length; itemsSorted++) {
         // Assume that items A[0], A[1], ... A[itemsSorted-1]
         // have already been sorted.  Insert A[itemsSorted]
         // into the sorted part of the list.

      int temp = A[itemsSorted];  // The item to be inserted.
      int loc = itemsSorted - 1;  // Start at end of list.

      while (loc &gt;= 0 &amp;&amp; A[loc] &gt; temp) {
         A[loc + 1] = A[loc]; // Bump item from A[loc] up to loc+1.
         loc = loc - 1;       // Go on to next location.
      }

      A[loc + 1] = temp; // Put temp in last vacated space.
   }
}</code></pre>


                        <p>Here is an illustration of one stage in insertion sort. It shows
                            what happens during one execution of the <span class="code">for</span> loop in the above method,
                            when <span class="code">itemsSorted</span> is&nbsp;5:</p>


                        <p align="center">
                            <img src="./images/insertion-sort.png" width="506" height="324" alt="(Illustration of Insertion Sort)"></p>

                        <h3 id="Selection Sort"><a class="header" href="#Selection Sort">Selection Sort</a></h3>

                        <p>Another typical sorting method uses the idea of finding the biggest item in
                            the list and moving it to the end&mdash;which is where it belongs if the list is
                            to be in increasing order. Once the biggest item is in its correct location,
                            you can then apply the same idea to the remaining items. That is, find the
                            next-biggest item, and move it into the next-to-last space, and so forth. This
                            algorithm is called <span class="newword">selection sort</span>. It's easy to
                            write:</p>


                        <pre><code class="java">static void selectionSort(int[] A) {
      // Sort A into increasing order, using selection sort

   for (int lastPlace = A.length-1; lastPlace &gt; 0; lastPlace--) {
         // Find the largest item among A[0], A[1], ...,
         // A[lastPlace], and move it into position lastPlace
         // by swapping it with the number that is currently
         // in position lastPlace.

      int maxLoc = 0;  // Location of largest item seen so far.

      for (int j = 1; j &lt;= lastPlace; j++) {
         if (A[j] &gt; A[maxLoc]) {
               // Since A[j] is bigger than the maximum we've seen
               // so far, j is the new location of the maximum value
               // we've seen so far.
            maxLoc = j;
         }
      }

      int temp = A[maxLoc];  // Swap largest item with A[lastPlace].
      A[maxLoc] = A[lastPlace];
      A[lastPlace] = temp;

   }  // end of for loop

}</code></pre>

                        
                        <p>A variation of selection sort is used in the <span class="classname">Hand</span> class that was
                            introduced in <a href="ch05-04-AnExample.html">Subsection&nbsp;5.4.1</a>. (By the way, you are
                            finally in a position to fully understand the source code for
                            the <span class="classname">Hand</span> class from that section; note that
                            it uses an <span class="classname">ArrayList</span>.
                            The source file is <span class="sourceref"><a href="./source/chapter5/Hand.java">Hand.java</a></span>.)</p>


                        <p>In the <span class="classname">Hand</span> class, a hand of playing cards is represented by an
                            <span class="atype">ArrayList&lt;Card&gt;</span>.
                            The objects stored in the list are of type <span class="classname">Card</span>. A
                            <span class="classname">Card</span> object contains instance methods <span class="code">getSuit()</span> and
                            <span class="code">getValue()</span> that can be used to determine the suit and value of the
                            card. In my sorting method, I actually create a new list and move the cards
                            one-by-one from the old list to the new list. The cards are selected from
                            the old list in increasing order. In the end, the new list becomes the hand
                            and the old list is discarded. This is not the most efficient procedure,
                            but hands of cards are so small that the inefficiency is negligible. Here is
                            the code for sorting cards by suit:</p>


                        <pre><code class="java">/**
 * Sorts the cards in the hand so that cards of the same suit are
 * grouped together, and within a suit the cards are sorted by value.
 * Note that aces are considered to have the lowest value, 1.
 */
public void sortBySuit() {
   ArrayList&lt;Card&gt; newHand = new ArrayList&lt;Card&gt;();
   while (hand.size() &gt; 0) {
      int pos = 0;  // Position of minimal card.
      Card c = hand.get(0);  // Minimal card.
      for (int i = 1; i &lt; hand.size(); i++) {
         Card c1 = hand.get(i);
         if ( c1.getSuit() &lt; c.getSuit() ||
              (c1.getSuit() == c.getSuit() &amp;&amp; c1.getValue() &lt; c.getValue()) ) {
            pos = i;  // Update the minimal card and location.
            c = c1;
         }
      }
      hand.remove(pos);  // Remove card from original hand.
      newHand.add(c);    // Add card to the new hand.
   }
   hand = newHand;
}</code></pre>



                        <p>This example illustrates the fact that comparing items in a list is not
                            usually as simple as using the operator "<span class="code">&lt;</span>".  In this case,
                            we consider one card to be less than another if the suit of the first card
                            is less than the suit of the second, and also if the suits are the same and
                            the value of the second card is less than the value of the first.  The second
                            part of this test ensures that cards with the same suit will end up sorted
                            by value.</p>


                        <p>Sorting a list of <span class="classname">Strings</span> raises a similar problem:
                            the "<span class="code">&lt;</span>" operator is not defined for strings.  However, the
                            <span class="classname">String</span> class does define a <span class="code">compareTo</span> method.
                            If <span class="code">str1</span> and <span class="code">str2</span> are of type <span class="classname">String</span>,
                            then</p>


                        <pre><code class="java">str1.compareTo(str2)</code></pre>


                        <p>returns an <span class="ptype">int</span> that is 0 when <span class="code">str1</span> is equal to
                            <span class="code">str2</span>, is less than 0 when <span class="code">str1</span> precedes <span class="code">str2</span>,
                            and is greater than 0 when <span class="code">str1</span> follows <span class="code">str2</span>. For example,
                            you can test whether <span class="code">str1</span> precedes or is equal to <span class="code">str2</span> by
                            testing</p>


                        <pre><code class="java">if ( str1.compareTo(str2) &lt;= 0 )</code></pre>


                        <p>The definition of "precedes" and "follows" for strings uses what is called
                            <span class="newword">lexicographic ordering</span>, which is based on the Unicode
                            values of the characters in the strings.  Lexicographic ordering is not
                            the same as alphabetical ordering, even for strings that consist entirely
                            of letters (because in lexicographic ordering, all the upper case letters
                            come before all the lower case letters).  However, for words consisting
                            strictly of the 26 lower case letters in the English alphabet, lexicographic
                            and alphabetic ordering are the same.  (The same holds true if the strings consist
                            entirely of  uppercase letters.)  The method <span class="code">str1.compareToIgnoreCase(str2)</span>
                            compares the two strings after converting any characters that they contain
                            to lower case.</p>





                        <p>Insertion sort and selection sort are suitable for sorting fairly small
                            arrays (up to a few hundred elements, say). There are more complicated sorting
                            algorithms that are much faster than insertion sort and selection sort for
                            large arrays, to the same degree that binary search is faster than linear search.
                            The standard method <span class="code">Arrays.sort</span> uses these fast sorting algorithms.
                            I'll discuss one such algorithm in <a href="ch09-00-LinkedDataStructuresRecursion.html">Chapter&nbsp;9</a>.</p>
                        

                        <h3 id="Unsorting"><a class="header" href="#Unsorting">Unsorting</a></h3>
                 

                        <p>I can't resist ending this section on sorting with a related problem that is
                            much less common, but is a bit more fun. That is the problem of putting the
                            elements of an array into a random order. The typical case of this problem is
                            shuffling a deck of cards. A good algorithm for shuffling is similar to
                            selection sort, except that instead of moving the biggest item to the end of
                            the list, an item is selected at random and moved to the end of the list. Here
                            is a subroutine to shuffle an array of <span class="code">ints</span>:</p>


                        <pre><code class="java">/**
 * Postcondition:  The items in A have been rearranged into a random order.
 */
static void shuffle(int[] A) {
   for (int lastPlace = A.length-1; lastPlace &gt; 0; lastPlace--) {
         // Choose a random location from among 0,1,...,lastPlace.
      int randLoc = (int)(Math.random()*(lastPlace+1));
         // Swap items in locations randLoc and lastPlace.
      int temp = A[randLoc];
      A[randLoc] = A[lastPlace];
      A[lastPlace] = temp;
   }
}</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch07-04-Records.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch07-06-2DArrays.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch07-04-Records.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch07-06-2DArrays.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </body>
</html>
