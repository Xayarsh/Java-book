<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Basic Controls - Introduction to Programming Using Java</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

<link rel="stylesheet" href="code-class.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html" >Introduction to Programming Using Java</a></li><li class="chapter-item expanded affix "><a href="preface.html">Preface</a></li><li class="chapter-item expanded "><a href="ch01-00-Overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-FetchExecuteCycle.html"><strong aria-hidden="true">1.1.</strong> Fetch and Execute Cycle</a></li><li class="chapter-item expanded "><a href="ch01-02-AsynchronousEvents.html"><strong aria-hidden="true">1.2.</strong> Asynchronous Events</a></li><li class="chapter-item expanded "><a href="ch01-03-JavaVirtualMachine.html"><strong aria-hidden="true">1.3.</strong> The Java Virtual Machine</a></li><li class="chapter-item expanded "><a href="ch01-04-FundamentalBuildingBlocks.html"><strong aria-hidden="true">1.4.</strong> Fundamentals</a></li><li class="chapter-item expanded "><a href="ch01-05-OOP.html"><strong aria-hidden="true">1.5.</strong> Object Oriented Programming</a></li><li class="chapter-item expanded "><a href="ch01-06-ModernUserInterface.html"><strong aria-hidden="true">1.6.</strong> Modern User Interface</a></li><li class="chapter-item expanded "><a href="ch01-07-InternetAndBeyond.html"><strong aria-hidden="true">1.7.</strong> Internet and Beyond</a></li><li class="chapter-item expanded "><a href="ch01-08-Quiz.html"><strong aria-hidden="true">1.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-NameAndThings.html"><strong aria-hidden="true">2.</strong> Name and Things</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-BasicJavaApplication.html"><strong aria-hidden="true">2.1.</strong> Basic Java Application</a></li><li class="chapter-item expanded "><a href="ch02-02-VariablesAndTypes.html"><strong aria-hidden="true">2.2.</strong> Variables and Types</a></li><li class="chapter-item expanded "><a href="ch02-03-ObjectsAndSubroutines.html"><strong aria-hidden="true">2.3.</strong> Objects and Subroutines</a></li><li class="chapter-item expanded "><a href="ch02-04-TextInputAndOutput.html"><strong aria-hidden="true">2.4.</strong> Text Input and Output</a></li><li class="chapter-item expanded "><a href="ch02-05-DetailsOfExpressions.html"><strong aria-hidden="true">2.5.</strong> Details of Expressions</a></li><li class="chapter-item expanded "><a href="ch02-06-ProgrammingEnvironments.html"><strong aria-hidden="true">2.6.</strong> Programming and Environments</a></li><li class="chapter-item expanded "><a href="ch02-07-Exercises.html"><strong aria-hidden="true">2.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch02-08-Quiz.html"><strong aria-hidden="true">2.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-Control.html"><strong aria-hidden="true">3.</strong> Control</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-BlocksLoopsBranches.html"><strong aria-hidden="true">3.1.</strong> Blocks, Loops and Branches</a></li><li class="chapter-item expanded "><a href="ch03-02-AlgorithmDevelopment.html"><strong aria-hidden="true">3.2.</strong> Algorithm Development</a></li><li class="chapter-item expanded "><a href="ch03-03-While.html"><strong aria-hidden="true">3.3.</strong> while and do...while</a></li><li class="chapter-item expanded "><a href="ch03-04-For.html"><strong aria-hidden="true">3.4.</strong> The for statement</a></li><li class="chapter-item expanded "><a href="ch03-05-If.html"><strong aria-hidden="true">3.5.</strong> The If Statement</a></li><li class="chapter-item expanded "><a href="ch03-06-Switch.html"><strong aria-hidden="true">3.6.</strong> The Switch Statement</a></li><li class="chapter-item expanded "><a href="ch03-07-ExceptionsTryCatch.html"><strong aria-hidden="true">3.7.</strong> Exceptions and try...catch</a></li><li class="chapter-item expanded "><a href="ch03-08-Arrays.html"><strong aria-hidden="true">3.8.</strong> Arrays: An Introduction</a></li><li class="chapter-item expanded "><a href="ch03-09-GUI.html"><strong aria-hidden="true">3.9.</strong> GUI: An Introduction</a></li><li class="chapter-item expanded "><a href="ch03-10-Exercises.html"><strong aria-hidden="true">3.10.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch03-11-Quiz.html"><strong aria-hidden="true">3.11.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-Subroutines.html"><strong aria-hidden="true">4.</strong> Subroutines</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-BlackBoxes.html"><strong aria-hidden="true">4.1.</strong> Black Boxes</a></li><li class="chapter-item expanded "><a href="ch04-02-StaticSubroutines.html"><strong aria-hidden="true">4.2.</strong> Static Subroutines and Variables</a></li><li class="chapter-item expanded "><a href="ch04-03-Parameters.html"><strong aria-hidden="true">4.3.</strong> Parameters</a></li><li class="chapter-item expanded "><a href="ch04-04-ReturnValues.html"><strong aria-hidden="true">4.4.</strong> Return Values</a></li><li class="chapter-item expanded "><a href="ch04-05-Lambda.html"><strong aria-hidden="true">4.5.</strong> Lambda Expressions</a></li><li class="chapter-item expanded "><a href="ch04-06-APIPackagesModulesJavadoc.html"><strong aria-hidden="true">4.6.</strong> API, Packages, Modules and Javadoc</a></li><li class="chapter-item expanded "><a href="ch04-07-MoreOnProgramDesign.html"><strong aria-hidden="true">4.7.</strong> More on Program Design</a></li><li class="chapter-item expanded "><a href="ch04-08-TruthAboutDeclarations.html"><strong aria-hidden="true">4.8.</strong> Truth about Declarations</a></li><li class="chapter-item expanded "><a href="ch04-09-Exercises.html"><strong aria-hidden="true">4.9.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch04-10-Quiz.html"><strong aria-hidden="true">4.10.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-ObjectsClasses.html"><strong aria-hidden="true">5.</strong> Objects and Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-ObjectsAndInstanceMethods.html"><strong aria-hidden="true">5.1.</strong> Objects and Instance Methods</a></li><li class="chapter-item expanded "><a href="ch05-02-ConstructorObjectInit.html"><strong aria-hidden="true">5.2.</strong> Constructor and Object Initialization</a></li><li class="chapter-item expanded "><a href="ch05-03-ProgrammingWithObjects.html"><strong aria-hidden="true">5.3.</strong> Programming with Objects</a></li><li class="chapter-item expanded "><a href="ch05-04-AnExample.html"><strong aria-hidden="true">5.4.</strong> An Example</a></li><li class="chapter-item expanded "><a href="ch05-05-InheritanceAndPolymorphism.html"><strong aria-hidden="true">5.5.</strong> Inheritance and Polymorphism</a></li><li class="chapter-item expanded "><a href="ch05-06-thisandsuper.html"><strong aria-hidden="true">5.6.</strong> this and super</a></li><li class="chapter-item expanded "><a href="ch05-07-Interfaces.html"><strong aria-hidden="true">5.7.</strong> Interfaces</a></li><li class="chapter-item expanded "><a href="ch05-08-NestedClasses.html"><strong aria-hidden="true">5.8.</strong> Nested Classes</a></li><li class="chapter-item expanded "><a href="ch05-09-Exercises.html"><strong aria-hidden="true">5.9.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch05-10-Quiz.html"><strong aria-hidden="true">5.10.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-GUIProgramming.html"><strong aria-hidden="true">6.</strong> Introduction to GUI Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-BasicJavaFXApp.html"><strong aria-hidden="true">6.1.</strong> A Basic JavaFX Application</a></li><li class="chapter-item expanded "><a href="ch06-02-BasicClasses.html"><strong aria-hidden="true">6.2.</strong> Basic Classes</a></li><li class="chapter-item expanded "><a href="ch06-03-BasicEvents.html"><strong aria-hidden="true">6.3.</strong> Basic Events</a></li><li class="chapter-item expanded "><a class="active"  href="ch06-04-BasicControls.html"><strong aria-hidden="true">6.4.</strong> Basic Controls</a></li><li class="chapter-item expanded "><a href="ch06-05-BasicLayout.html"><strong aria-hidden="true">6.5.</strong> Basic Layout</a></li><li class="chapter-item expanded "><a href="ch06-06-CompetePrograms.html"><strong aria-hidden="true">6.6.</strong> Complete Programs</a></li><li class="chapter-item expanded "><a href="ch06-07-Exercises.html"><strong aria-hidden="true">6.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch06-08-Quiz.html"><strong aria-hidden="true">6.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-ArraysArraylistsRecords.html"><strong aria-hidden="true">7.</strong> Arrays, ArrayLists and Records</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-ArrayDetails.html"><strong aria-hidden="true">7.1.</strong> Array Details</a></li><li class="chapter-item expanded "><a href="ch07-02-ArrayProcessing.html"><strong aria-hidden="true">7.2.</strong> Array Processing</a></li><li class="chapter-item expanded "><a href="ch07-03-ArrayLists.html"><strong aria-hidden="true">7.3.</strong> ArrayLists</a></li><li class="chapter-item expanded "><a href="ch07-04-Records.html"><strong aria-hidden="true">7.4.</strong> Records</a></li><li class="chapter-item expanded "><a href="ch07-05-SearchingAndSorting.html"><strong aria-hidden="true">7.5.</strong> Searching and Sorting</a></li><li class="chapter-item expanded "><a href="ch07-06-2DArrays.html"><strong aria-hidden="true">7.6.</strong> 2D Arrays</a></li><li class="chapter-item expanded "><a href="ch07-07-Exercises.html"><strong aria-hidden="true">7.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch07-08-Quiz.html"><strong aria-hidden="true">7.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-CorrectnessRobustnessEfficiency.html"><strong aria-hidden="true">8.</strong> Correctness, Robustness, Efficiency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-IntroductionCorrectnessandRobustness.html"><strong aria-hidden="true">8.1.</strong> Introduction to Correctness and Robustness</a></li><li class="chapter-item expanded "><a href="ch08-02-WritingCorrectPrograms.html"><strong aria-hidden="true">8.2.</strong> Writing Correct Programs</a></li><li class="chapter-item expanded "><a href="ch08-03-ExceptionsAndtrycatch.html"><strong aria-hidden="true">8.3.</strong> Exceptions and try..catch</a></li><li class="chapter-item expanded "><a href="ch08-04-AssertionsAnnotations.html"><strong aria-hidden="true">8.4.</strong> Assertions and Annotations</a></li><li class="chapter-item expanded "><a href="ch08-05-AnalysisofAlgorithms.html"><strong aria-hidden="true">8.5.</strong> Analysis of Algorithms</a></li><li class="chapter-item expanded "><a href="ch08-06-Exercises.html"><strong aria-hidden="true">8.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch08-07-Quiz.html"><strong aria-hidden="true">8.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-LinkedDataStructuresRecursion.html"><strong aria-hidden="true">9.</strong> Linked Data Structures and Recursion</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-Recursion.html"><strong aria-hidden="true">9.1.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="ch09-02-LinkedDataStructures.html"><strong aria-hidden="true">9.2.</strong> Linked Data Structures</a></li><li class="chapter-item expanded "><a href="ch09-03-StacksQueuesADTs.html"><strong aria-hidden="true">9.3.</strong> Stacks, Queues and ADTs</a></li><li class="chapter-item expanded "><a href="ch09-04-BinaryTrees.html"><strong aria-hidden="true">9.4.</strong> Binary Trees</a></li><li class="chapter-item expanded "><a href="ch09-05-SimpleRecursiveDescentParser.html"><strong aria-hidden="true">9.5.</strong> A Simple Recursive Descent Parser</a></li><li class="chapter-item expanded "><a href="ch09-06-Exercises.html"><strong aria-hidden="true">9.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch09-07-Quiz.html"><strong aria-hidden="true">9.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-GenericProgrammingandCollectionClasses.html"><strong aria-hidden="true">10.</strong> Generic Programmingand Collection Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-GenericProgramming.html"><strong aria-hidden="true">10.1.</strong> Generic Programming</a></li><li class="chapter-item expanded "><a href="ch10-02-ListsandSets.html"><strong aria-hidden="true">10.2.</strong> Lists and Sets</a></li><li class="chapter-item expanded "><a href="ch10-03-Maps.html"><strong aria-hidden="true">10.3.</strong> Maps</a></li><li class="chapter-item expanded "><a href="ch10-04-JCF.html"><strong aria-hidden="true">10.4.</strong> Programming with the JCF</a></li><li class="chapter-item expanded "><a href="ch10-05-WritingGenericClassesandMethods.html"><strong aria-hidden="true">10.5.</strong> Writing Generic Classes and Methods</a></li><li class="chapter-item expanded "><a href="ch10-06-StreamAPI.html"><strong aria-hidden="true">10.6.</strong> Stream APIs</a></li><li class="chapter-item expanded "><a href="ch10-07-Exercises.html"><strong aria-hidden="true">10.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch10-08-Quiz.html"><strong aria-hidden="true">10.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-IOStreamsFilesNetworking.html"><strong aria-hidden="true">11.</strong> I/O Streams, Files, and Networking</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-IOStreamsReadersAndWriters.html"><strong aria-hidden="true">11.1.</strong> I/O Streams, Readers, and Writers</a></li><li class="chapter-item expanded "><a href="ch11-02-Files.html"><strong aria-hidden="true">11.2.</strong> Files</a></li><li class="chapter-item expanded "><a href="ch11-03-ProgrammingWithFiles.html"><strong aria-hidden="true">11.3.</strong> Programming With Files</a></li><li class="chapter-item expanded "><a href="ch11-04-Networking.html"><strong aria-hidden="true">11.4.</strong> Networking</a></li><li class="chapter-item expanded "><a href="ch11-05-XML.html"><strong aria-hidden="true">11.5.</strong> A Brief Introduction to XML</a></li><li class="chapter-item expanded "><a href="ch11-06-Exercises.html"><strong aria-hidden="true">11.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch11-07-Quiz.html"><strong aria-hidden="true">11.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-ThreadsandMultiprocessing.html"><strong aria-hidden="true">12.</strong> Threads and Multiprocessing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-IntroductiontoThreads.html"><strong aria-hidden="true">12.1.</strong> Introduction to Threads</a></li><li class="chapter-item expanded "><a href="ch12-02-ProgrammingwithThreads.html"><strong aria-hidden="true">12.2.</strong> Programming with Threads</a></li><li class="chapter-item expanded "><a href="ch12-03-ThreadsandParallelProcessing.html"><strong aria-hidden="true">12.3.</strong> Threads and Parallel Processing</a></li><li class="chapter-item expanded "><a href="ch12-04-ThreadsandNetworking.html"><strong aria-hidden="true">12.4.</strong> Threads and Networking</a></li><li class="chapter-item expanded "><a href="ch12-05-NetworkProgrammingExample.html"><strong aria-hidden="true">12.5.</strong> Network Programming Example</a></li><li class="chapter-item expanded "><a href="ch12-06-Exercises.html"><strong aria-hidden="true">12.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch12-07-Quiz.html"><strong aria-hidden="true">12.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-GUIProgrammingContinued.html"><strong aria-hidden="true">13.</strong> GUI Programming Continued</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-PropertiesandBindings.html"><strong aria-hidden="true">13.1.</strong> Properties and Bindings</a></li><li class="chapter-item expanded "><a href="ch13-02-FancierGraphics.html"><strong aria-hidden="true">13.2.</strong> Fancier Graphics</a></li><li class="chapter-item expanded "><a href="ch13-03-ComplexComponentsandMVC.html"><strong aria-hidden="true">13.3.</strong> Complex Components and MVC</a></li><li class="chapter-item expanded "><a href="ch13-04-MostlyWindowsandDialogs.html"><strong aria-hidden="true">13.4.</strong> Mostly Windows and Dialogs</a></li><li class="chapter-item expanded "><a href="ch13-05-FinishingTouches.html"><strong aria-hidden="true">13.5.</strong> Finishing Touches</a></li><li class="chapter-item expanded "><a href="ch13-06-Exercises.html"><strong aria-hidden="true">13.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch13-07-Quiz.html"><strong aria-hidden="true">13.7.</strong> Quiz</a></li></ol><li class="chapter-item expanded "><a href="appendix-00.html"> Appendix</a></li><li class="chapter-item expanded "><a href="glossary-00.html"> Glossary</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="Java">Java</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Introduction to Programming Using Java</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Xayarsh/Java-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Basic Controls"><a class="header" href="#Basic Controls">Basic Controls</a></h2>
                        <p>
                            In preceding sections, you've seen how to use a
                            graphics context to draw on the screen and how to handle mouse events and
                            keyboard events. In one sense, that's all there is to GUI programming. If
                            you're willing to program all the drawing and handle all the mouse and keyboard
                            events, you have nothing more to learn. However, you would either be doing a
                            lot more work than you need to do, or you would be limiting yourself to very
                            simple user interfaces. A typical user interface uses standard GUI components
                            such as buttons, scroll bars, text-input boxes, and menus. These components
                            have already been written for you, so you don't have to duplicate the work
                            involved in developing them. They know how to draw themselves, and they can
                            handle the details of processing the mouse and keyboard events that concern
                            them.</p>


                        <p>Consider one of the simplest user interface components, a push button. The
                            button has a border, and it displays some text. This text can be changed.
                            Sometimes the button is disabled, so that clicking on it doesn't have any
                            effect. When it is disabled, its appearance changes. When the user clicks on
                            the  button, it changes appearance when the mouse button is
                            pressed and changes back when the mouse button is released. In fact, it's more
                            complicated than that. If the user moves the mouse outside the push button
                            before releasing the mouse button, the button changes to its regular
                            appearance, and releasing the mouse at that time will not trigger the button.
                            To implement this, it is necessary to respond to mouse exit or
                            mouse drag events. Furthermore, on many platforms, a button can receive the
                            input focus. The button changes appearance when it has the focus. If the button
                            has the focus and the user presses the space bar, the button is triggered. This
                            means that the button must respond to keyboard and focus events as well.</p>


                        <p>Fortunately, you don't have to program <b>any</b> of this, provided you
                            use an object belonging to the standard class <span class="code">javafx.scene.control.Button</span>. A
                            <span class="classname">Button</span> object draws itself and processes mouse, keyboard, and focus
                            events on its own. You only hear from the <span class="classname">Button</span> when the user
                            triggers it by clicking on it or pressing the space bar while the button has
                            the input focus. When this happens, the <span class="classname">Button</span> object creates an
                            event object belonging to the class <span class="code">javafx.event.ActionEvent</span>. The
                            event object is sent to any registered listener to tell it that the button
                            has been pushed. Your program gets only the information it needs&mdash;the fact
                            that a button was pushed.</p>

                        <p>Many standard components that are defined as part of the JavaFX graphical user interface
                            API are defined by subclasses of the class <span class="classname">Control</span>, from
                            package <span class="code">javafx.scene.control</span>.  Controls (with just a couple of exceptions)
                            can be manipulated by the user to generate input and events for the program.
                            A number of useful methods are defined for controls. I begin by mentioning
                            three methods that can be used with any <span class="classname">Control</span>
                            <span class="code">control</span>:</p>


                        <ul>

                            <li>
                                <span class="codedef">control.setDisable(true)</span> can be called to
                                disable the control.  The control can be re-enabled with <span class="codedef">control.setDisable(false)</span>.
                                When a control is disabled, its appearance
                                might change, and it cannot be the target of mouse or key events.
                                This function can actually be called with any scene graph node, not just controls;
                                when you disable a node, any nodes contained inside that node are also disabled.
                                There is a boolean-valued function, <span class="codedef">control.isDisabled()</span>
                                that you can call to discover whether the control is disabled, either because
                                it was explicitly disabled or because it is inside a container node
                                that was explicitly disabled.</li>

                            <li>
                                <span class="codedef">control.setTooltip(new Tooltip(string))</span> sets the
                                specified string as a "tool tip" for the control. The tool tip is displayed
                                if the mouse cursor is inside the control and the mouse is not moved for a few
                                seconds. The tool tip should give some information about the meaning of the
                                control or how to use it.</li>

                            <li>
                                <span class="codedef">control.setStyle(cssString)</span> sets the CSS style
                                of the control.  CSS was discussed in <a href="ch06-02-BasicClasses.html">Subsection&nbsp;6.2.5</a>.</li>

                        </ul>



                        <p>Note that using a control, or any scene graph node,
                            is a multi-step process. The component object must be created
                            with a constructor. It must be added to a container. In many cases, a listener
                            must be registered to respond to events from the component. And in some cases,
                            a reference to the component must be saved in an instance variable so that the
                            component can be manipulated by the program after it has been created.
                            In this section, we will look at a few of the basic standard control components that are
                            available in JavaFX.  They are all defined by classes in the package
                            <span class="classname">javafx.scene.control</span>.  In the <a href="ch06-04-BasicControls.html">next section</a>
                            we will consider the problem of laying out components in containers.</p>


                        <h3 id="ImageView"><a class="header" href="#ImageView">ImageView</a></h3>

                        <p>But before we turn to controls, I want to mention one other node type:
                            <span class="classname">ImageView</span> from package <span class="code">javafx.scene.image</span>.
                            Recall from <a href="ch06-02-BasicClasses.html">Subsection&nbsp;6.2.3</a> that an <span class="classname">Image</span>
                            object represents a picture, and that images can be loaded from resource files.
                            An <span class="classname">Image</span> can be drawn on a <span class="classname">Canvas</span>,
                            but an <span class="classname">Image</span> is not a <span class="classname">Node</span>.
                            That is, it can't be part of a scene graph.</p>


                        <p>An <span class="classname">ImageView</span> is a scene graph node that is a
                            simple wrapper for an image.  Its purpose is simply to display the
                            image.  It makes it possible to add the image to a scene graph without
                            having to draw the image on a canvas.  The image can be specified as a parameter to the
                            <span class="classname">ImageView</span> constructor.  For example, suppose
                            that "icons/tux.png" is the path to an image resource file.
                            Then an <span class="classname">ImageView</span> can be created to display
                            the image like this:</p>


                        <pre><code class="java">Image tux = new Image("icons/tux.png");
ImageView tuxIcon = new ImageView( tux );</code></pre>


                        <p>In this case, I am thinking of the image as an "icon," that is, a small
                            image that is typically used on a button, label, or menu item to
                            add a graphical element to the usual plain text.  In fact, we'll see that
                            you can do exactly that in JavaFX.</p>

                        <h3 id="Label and Button"><a class="header" href="#Label and Button">Label and Button</a></h3>

                        <p>The first four controls that we will look at have something in common:
                            They all display a string of text to the user, which the user can view
                            but not edit.  Furthermore they can all display a graphical element in
                            addition to or instead of the text.  The graphic can be any <span class="classname">Node</span>
                            but is usually a small icon, implemented as an object of type <span class="classname">ImageView</span>.
                            In fact, all four types of controls inherit their behavior from a common
                            superclass named <span class="classname">Labeled</span>.  In <a href="ch06-06-CompetePrograms.html">Subsection&nbsp;6.6.2</a>,
                            we look at menu items, which also inherit from <span class="classname">Labeled</span>.
                            That class defines a number of instance methods that can be used with
                            labels, buttons, and other labeled controls. Those methods include:</p>


                        <ul>

                            <li>
                                <span class="codedef">setText(string)</span> for
                                setting the text that is displayed on the control.  The text
                                can be multi-line.  The new line character, "\n", in the <span class="code">string</span>
                                represents a line break.</li>

                            <li>
                                <span class="codedef">setGraphic(node)</span> for setting the control's graphical element.
                            </li>

                            <li>
                                <span class="codedef">setFont(font)</span> for setting the font that is used for the text.
                            </li>

                            <li>
                                <span class="codedef">setTextFill(color)</span> for setting the paint that is used for drawing the text.
                            </li>

                            <li>
                                <span class="codedef">setGraphicTextGap(size)</span> for setting the amount of space that is put
                                between the text and the graphic.  The parameter is of type <span class="ptype">double</span>.
                            </li>

                            <li>
                                <span class="codedef">setContentDisplay(displayCode)</span> for setting where the graphic
                                should be placed with respect to the text.  The parameter is a constant
                                from an enum, <span class="classname">ContentDisplay</span>, such as
                                <span class="code">ContentDisplay.LEFT</span>, <span class="code">ContentDisplay.RIGHT</span>, <span class="code">ContentDisplay.TOP</span>
                                or <span class="code">ContentDisplay.BOTTOM</span>.
                            </li>

                        </ul>


                        <p>All of these setter methods have corresponding getters, such as <span class="code">getText()</span>
                            and <span class="code">getFont()</span>.  I have not listed a setter method for the background
                            color.  It is possible to set a background color, but it's cumbersome.  (Setting
                            the background color of a control, <span class="code">c</span>, to white looks like this:</p>


                        <pre><code class="java">c.setBackground(new Background(new BackgroundFill(Color.WHITE,null,null)));</code></pre>


                        <p>where <span class="classname">Background</span> and <span class="classname">BackgroundFill</span>
                            are in package <span class="code">javafx.scene.layout</span>.)  It is more easily done by
                            setting the CSS style of the control with the <span class="code">setStyle()</span> method.
                            CSS is also useful for setting the border and for setting padding (the amount of
                            empty space left around the content).</p>


                        <p>A <span class="classname">Label</span> is certainly the simplest type of control.
                            It adds almost nothing to the <span class="classname">Labeled</span> class.  Its
                            purpose is simply to display some unedited text and/or a graphic to the user.
                            The label class has two constructors.  The first has one parameter of type
                            <span class="classname">String</span> specifying the text for the label.  The
                            second adds a parameter of type <span class="classname">Node</span> specifying
                            a graphic for the label.  For example, assuming that <span class="code">tuxIcon</span>
                            is the <span class="classname">ImageView</span> object from the previous subsection,</p>


                        <pre><code class="java">Label message = new Label("Hello World");
Label linuxAd = new Label("Choose Linux First!", tuxIcon);</code></pre>


                        <p>The default background of a label is completely transparent, and the label
                            has no border or padding by default.  Often I would like to add at least
                            some padding.  Here is an example of setting all three properties using CSS:</p>


                        <pre><code class="java">message.setStyle("-fx-border-color: blue; -fx-border-width: 2px; " +
                           "-fx-background-color: white; -fx-padding: 6px");</code></pre>

                        <p> You've already seen buttons used in <a href="ch06-01-BasicJavaFXApp.html">Section&nbsp;6.1</a>.
                            A <span class="classname">Button</span>, like a <span class="classname">Label</span>, displays
                            some text and/or a graphic to the user, and the <span class="classname">Button</span>
                            class, like the <span class="classname">Label</span> class, has two constructors:</p>


                        <pre><code class="java">Button stopButton = new Button("Stop");
Button linuxButton = new Button("Get Linux", tuxIcon);</code></pre>


                        <p>When the user clicks a button, an event of type <span class="classname">ActionEvent</span>
                            is generated.  You can register an event handler for the action with the button's
                            <span class="code">setOnAction</span> method.  For example,</p>


                        <pre><code class="java">stopButton.setOnAction( e -&gt; animator.stop() );</code></pre>


                        <p>In addition to the methods inherited from <span class="classname">Labeled</span>, a button
                            has the instance methods <span class="code">setDisable(boolean)</span> and <span class="code">setToolTip(string)</span>
                            that were mentioned at the beginning of this section.
                            The <span class="code">setDisable()</span> and <span class="code">setText()</span> methods are
                            particularly useful for giving the user information about what is going on in
                            the program. A disabled button is better than a button that gives an obnoxious
                            error message such as "Sorry, you can't click on me now!"  For example, suppose
                            that we want to use two buttons to start and stop an <span class="classname">AnimationTimer</span>,
                            <span class="code">animator</span>.  When the animation is running, the start button should be
                            disabled, and when the animation is paused, the stop button should be disabled.
                            The code for this might look like:</p>


                        <pre><code class="java">Button startButton = new Button("Run Animation");
Button stopButton = new Button("Stop Animation");
stopButton.setDisable(true); // Stop button is initially disabled.
startButton.setOnAction( e -&gt; {
    animator.start();
    startButton.setDisable(true);
    stopButton.setDisable(false);
} );
stopButton.setOnAction( e -&gt; {
    animator.stop();
    startButton.setDisable(false);
    stopButton.setDisable(true);
} );</code></pre>


                        <p>This ensures that the user can't try to start the animation when it is already
                            started or stop it when it is already stopped.</p>


                        <p>Often, there is a button that triggers some default action in a program.
                            For example, the user might enter data into some text input boxes and then click
                            a "Compute" button to process the data.  It would be nice if the user could just
                            press Return when done typing, instead of having to click the button.
                            In JavaFX, you can make a <span class="classname">Button</span>, <span class="code">button</span>,
                            into the default button for the window that contains it by calling</p>


                        <pre><code class="java">button.setDefaultButton(true);</code></pre>


                        <p>When a window has a default button, then pressing the Return (or Enter) key on the
                            keyboard is equivalent to clicking the default button, unless the key event
                            generated by the Return key is consumed by another component.  This
                            can be very convenient for the user.</p>

                        <h3 id="CheckBox and RadioButton"><a class="header" href="#CheckBox and RadioButton">CheckBox and RadioButton</a></h3>

                        <p>A <span class="classname">CheckBox</span> is a component that has two states: selected or
                            unselected. (Being "selected" means that the checkbox is checked.)
                            The user can change the state of a check box by clicking on it. The
                            state of a checkbox is represented by a <span class="ptype">boolean</span> value that is
                            <span class="code">true</span> if the box is selected and is <span class="code">false</span> if the box is
                            unselected. A checkbox has a label, which is specified when the box is
                            constructed:</p>


                        <pre><code class="java">CheckBox showTime = new CheckBox("Show Current Time");</code></pre>


                        <p>
                            <span class="classname">CheckBox</span> is a subclass of <span class="classname">Labeled</span>,
                            so a checkbox can also have a graphic, and all the instance methods from
                            the <span class="classname">Labeled</span> class can also be used with checkboxes.
                            (There is no constructor that specifies a graphic for the checkbox; any
                            graphic has to be set by calling <span class="code">setGraphic</span>(node).)</p>


                        <p>Usually, it's the user who sets the state of a <span class="classname">CheckBox</span> by
                            clicking on it, but you can also set the state programmatically. The current state of a checkbox is set
                            using its <span class="code">setSelected(boolean)</span> method. For example, if you want the
                            checkbox <span class="code">showTime</span> to be checked, you would say
                            "<span class="code">showTime.setSelected(true)"</span>. To uncheck the box, say
                            "<span class="code">showTime.setSelected(false)"</span>. You can determine the current state of
                            a checkbox by calling its <span class="code">isSelected()</span> method, which returns a <span class="ptype">boolean</span>
                            value.</p>


                        <p>In many cases, you don't need to worry about events from checkboxes. Your
                            program can just check the state whenever it needs to know it by calling the
                            <span class="code">isSelected()</span> method. However, a checkbox does generate an event when
                            its state is changed by the user, and you can detect this event and respond to it if you want
                            something to happen at the moment the state changes. When the state of a
                            checkbox is changed by the user, it generates an event of type
                            <span class="classname">ActionEvent</span>. If you want something to happen when the user changes the
                            state, you must register a handler with the
                            checkbox by calling its <span class="code">setOnAction()</span> method. (Note that if you change the state by calling the
                            <span class="code">setSelected()</span> method, no <span class="classname">ActionEvent</span> is generated. However,
                            there is another method in the <span class="classname">CheckBox</span> class, <span class="code">fire()</span>,
                            which simulates a user click on the checkbox and does generate an
                            <span class="classname">ActionEvent</span>.)</p>


                        <p>It is actually possible for a checkbox to be in a third state, called
                            "indeterminate," although that possibility is turned off by default.
                            See the API documentation for details.</p>





                        <p>Closely related to checkboxes are <span class="newword">radio buttons</span>.
                            Like a checkbox, a radio button can be either selected or not.  However,
                            radio buttons are expected to occur in groups, where at most one radio button in a given
                            group can be selected at any given time.  Radio button groups let the user
                            select one choice among several alternatives.  In JavaFX, a radio button is represented
                            by an object of type <span class="classname">RadioButton</span>. When used in isolation, a
                            <span class="classname">RadioButton</span> acts just like a <span class="classname">CheckBox</span>,
                            and it has the same constructor, methods, and events, including methods inherited from <span class="classname">Labeled</span>.
                            Ordinarily, however, a <span class="classname">RadioButton</span> is used in a
                            group. A group of radio buttons is represented by an object belonging to the
                            class <span class="classname">ToggleGroup</span>. A <span class="classname">ToggleGroup</span> is <b>not</b> a component
                            and does not itself have a visible representation on the screen. A
                            <span class="classname">ToggleGroup</span> works behind the scenes to organize a group of radio
                            buttons, to ensure that at most one button in the group can be selected at any given
                            time.</p>


                        <p>To use a group of radio buttons, you must create a <span class="classname">RadioButton</span>
                            object for each button in the group, and you must create one object of type
                            <span class="classname">ToggleGroup</span> to organize the individual buttons into a group. Each
                            <span class="classname">RadioButton</span> must be added individually to the scene graph, so that it
                            will appear on the screen. (A <span class="classname">ToggleGroup</span> plays no role in the
                            placement of the buttons on the screen.) Each <span class="classname">RadioButton</span> must also
                            be added to the <span class="classname">ToggleGroup</span>.  You do that by calling
                            the radio button's <span class="code">setToggleGroup(group)</span> instance method.
                            If you want one of the buttons to be selected initially, you
                            can call <span class="code">setSelected(true)</span> for that button. If you don't do this, then
                            none of the buttons will be selected until the user clicks on one of them.</p>


                        <p>As an example, here is how you could set up a group of radio buttons that can
                            be used to select a color:</p>


                        <pre><code class="java">RadioButton redRadio, blueRadio, greenRadio, yellowRadio;
         // Variables to represent the radio buttons.
         // These might be instance variables, so that
         // they can be used throughout the program.

ToggleGroup colorGroup = new ToggleGroup();

redRadio = new RadioButton("Red");   // Create a button.
redRadio.setToggleGroup(colorGroup); // Add it to the ToggleGroup.

blueRadio = new RadioButton("Blue");
blueRadio.setToggleGroup(colorGroup);

greenRadio = new RadioButton("Green");
greenRadio.setToggleGroup(colorGroup);

yellowRadio = new RadioButton("Yellow");
yellowRadio.setToggleGroup(colorGroup);

redRadio.setSelected(true);  // Make an initial selection.</code></pre>


                        <p>As an alternative to calling <span class="code">redRadio.setSelected(true)</span>,
                            you can use the <span class="code">selectToggle()</span> instance method
                            in the <span class="classname">ToggleGroup</span> class to select the radio
                            button:</p>


                        <pre><code class="java">colorGroup.selectToggle( redRadio );</code></pre>


                        <p>Just as for checkboxes, it is not always necessary to register listeners for radio buttons.
                            You can test the state of an individual <span class="classname">RadioButton</span>
                            by calling its <span class="code">isSelected()</span> method, or you can call the toggle group's
                            <span class="code">getSelectedToggle()</span> method.  The return type of this method is
                            <span class="classname">Toggle</span>, which is an interface implemented by <span class="classname">RadioButton</span>.
                            For example:</p>


                        <pre><code class="java">Toggle selection = colorGroup.getSelectedToggle();
if (selection == redRadio) {
    color = Color.RED;
}
else if (selection == greenRadio){
   .
   .
   .</code></pre>


                        <p>Here's what these radio buttons look like, lined up vertically
                            in a container:</p>


                        <p align="center">
                            <img src="./images/colorRadioButtons.png" width="90" height="126" alt="radio buttons"></p>

                        <h3 id="TextField and TextArea"><a class="header" href="#TextField and TextArea">TextField and TextArea</a></h3>

                        <p>The <span class="classname">TextField</span> and <span class="classname">TextArea</span> classes
                            represent components that contain text that can be edited by the user.
                            A <span class="classname">TextField</span> holds a single line of text, while a
                            <span class="classname">TextArea</span> can hold multiple lines.   It is also possible to set a
                            <span class="classname">TextField</span> or <span class="classname">TextArea</span>
                            to be read-only so that the user can read the text that it contains but
                            cannot edit the text. Both classes are subclasses of an abstract class,
                            <span class="classname">TextInputControl</span>, which defines their common properties.</p>


                        <p>
                            <span class="classname">TextField</span> and <span class="classname">TextArea</span> have many
                            methods in common.  The instance method <span class="code">setText(text)</span>, which takes a parameter
                            of type <span class="classname">String</span>, can be used to change the text that is
                            displayed in an input component.  The contents of the component can be retrieved by calling its
                            <span class="code">getText()</span> instance method, which returns a value of type <span class="classname">String</span>.
                            You can add a <span class="classname">String</span> of text onto the end of the text that is already
                            in the component by calling the instance method <span class="code">appendText(text)</span>.  The text
                            in the <span class="code">setText()</span> and <span class="code">appendText()</span> methods
                            can include "\n" characters to represent line breaks; in a
                            <span class="classname">TextField</span> they will be ignored.  The instance method
                            <span class="code">setFont(font)</span> can be used to change the font that is used in the text component.</p>


                        <p>If you want to stop the user from modifying the text, you can
                            call <span class="code">setEditable(false)</span>.  Call the same method with parameter
                            <span class="code">true</span> to make the input component user-editable again.</p>


                        <p>The user can only type into a text component when it has
                            the input focus.  The user can give the input focus to a text component by clicking
                            it with the mouse, but sometimes it is useful to give the input focus to a
                            text field programmatically.  You can do this by calling its
                            <span class="code">requestFocus()</span> method.</p>


                        <p>A substring of the text in a text component can be "selected."  The selected text is
                            highlighted and can be cut or copied from the text component.  (The user can right-click in
                            the component to bring up a pop-up menu of editing commands.)
                            <span class="classname">TextInputComponent</span> has several instance methods for working
                            with the text selection, but I only mention one of them:  <span class="code">selectAll()</span>,
                            which selects the entire string of text in the text component.
                        </p>


                        <p>For example, when I discover an error
                            in the user's input in a <span class="classname">TextField</span>, <span class="code">input</span>, I&nbsp;usually call both
                            <span class="code">input.requestFocus()</span> and <span class="code">input.selectAll()</span>.  This helps the user see where the error occurred
                            and lets the user start typing the correction immediately.  If the user starts typing, the old text in the input
                            box, which is highlighted, will automatically be deleted.</p>





                        <p>Both the <span class="classname">TextField</span> class and the <span class="classname">TextArea</span> class
                            have two constructors.  One of the constructors has no parameter and makes an
                            initially empty text input box.  The second constructor takes a parameter of type <span class="classname">String</span>,
                            specifying the initial content of the box.</p>


                        <p>A <span class="classname">TextField</span> has a preferred number of columns, which by default is 12.
                            This determines the preferred width of the text field, that is, the size that is used if the
                            size is not reset by the program or when the text field is laid out by a container.  The preferred
                            number of columns for a <span class="classname">TextField</span>, <span class="code">input</span>, can be changed by calling
                            <span class="code">input.setPrefColumnCount(n)</span>, where <span class="code">n</span> is a positive integer.</p>


                        <p>Similarly, a <span class="classname">TextArea</span> has both a preferred number of columns and a
                            preferred number of rows, which by default are 40 and 10.  The value can be changed using
                            the <span class="classname">TextArea</span> instance methods <span class="code">setPrefColumnCount(n)</span>
                            and <span class="code">setPrefRowCount(n)</span>.</p>



                        <p>The <span class="classname">TextArea</span> class adds a few useful methods to those inherited
                            from <span class="classname">TextInputControl</span>, including some methods for getting and
                            setting the amount by which the text has been scrolled.  Most important is
                            <span class="code">setWrapText(wrap)</span>, where <span class="code">wrap</span> is of type <span class="ptype">boolean</span>.
                            This method says what should happen when a line of text is too long to be displayed in the
                            text area.  If <span class="code">wrap</span> is true, then any line that is too long will be
                            "wrapped" onto the next line, with the line break occurring between words if possible;
                            if <span class="code">wrap</span> is false, the line will simply extend outside the text area, and
                            the user will have to scroll the text area
                            horizontally to see the entire line.  The default value of <span class="code">wrap</span> is false.</p>


                        <p>Since it might be necessary to scroll a text area to see all the text that it
                            contains, a <span class="classname">TextArea</span> comes with scroll bars.  The scroll
                            bars are visible only when they are needed because the text cannot fit in the
                            available space.</p>


                        <p>See the sample program
                            <span class="sourceref"><a href="./source/chapter6/TextInputDemo.java">TextInputDemo.java</a></span> for a short example of using a text field
                            and a text area.  Here is the window from that program, after
                            the text has been edited and scrolled down a few lines:</p>


                        <p align="center">
                            <img src="./images/TextInputDemo.png" width="550" height="263" alt="The window from sample program TextInputDemo.png"></p>


                        <p>(I pasted the source code of the program into the text area!)</p>

                        <h3 id="Slider"><a class="header" href="#Slider">Slider</a></h3>

                        <p>A <span class="classname">Slider</span> provides a way for the user to select an integer value
                            from a range of possible values. The user does this by dragging a "knob" along
                            a bar, or by clicking at some point along the bar.
                            A slider can, optionally, be decorated with tick marks and with labels.
                            This picture, from the sample program <span class="sourceref"><a href="./source/chapter6/SliderDemo.java">SliderDemo.java</a></span>, shows
                            three sliders with different decorations and with different ranges of values:</p>


                        <p align="center">
                            <img src="./images/slider-demo.png" width="377" height="191" alt="three sliders with and without labels and tick marks"></p>



                        <p>Here, the second slider is decorated with tick marks, and the third one
                            is decorated with labels. It's possible for a single slider to have both types
                            of decorations.</p>


                        <p>The most commonly used constructor for <span class="classname">Sliders</span> specifies the start
                            and end of the range of values for the slider and its initial value when it
                            first appears on the screen:</p>


                        <pre><code class="java">public Slider(double minimum, double maximum, double value)</code></pre>


                        <p>If the parameters are omitted, the values 0, 100, and 0 are used. By
                            default, a slider is horizontal, but you can make it vertical by calling its
                            method <span class="code">setOrientation(Orientation.VERTICAL)</span>. <span class="classname">Orientation</span>
                            is an enum from package <span class="code">javafx.geometry</span>.</p>


                        <p>The current value of a
                            <span class="classname">Slider</span> can be read at any time with its <span class="code">getValue()</span> method,
                            which returns a value of type <span class="ptype">double</span>. If you want to change the
                            value programmatically, you can do so with the method <span class="code">setValue(val)</span>, which takes a
                            parameter of type <span class="ptype">double</span>.  If the specified value is not between
                            the minimum and maximum slider values, it is adjusted to lie in that range.</p>


                        <p>If you want to respond immediately when the user changes the value of a
                            slider, you can register a listener with the slider. <span class="classname">Sliders</span>, unlike
                            other components we have seen, do not generate <span class="code">ActionEvents</span>. Instead,
                            they have an observable property of type <span class="code">Double</span>
                            that represents the value.  (See <a href="ch06-03-BasicEvents.html">Subsection&nbsp;6.3.7</a>.)
                            You can access the value property of a <span class="classname">Slider</span>, <span class="code">slider</span>,
                            by calling <span class="code">slider.valueProperty()</span>, and you can add a listener to the
                            property that will be called whenever the value changes.  For example, in the
                            sample program, I add listeners to the sliders with commands such as</p>


                        <pre><code class="java">slider1.valueProperty().addListener( e -&gt; sliderValueChanged(slider1) );</code></pre>


                        <p>The listener will be called whenever the value changes, either because the
                            user is dragging the knob on the slider or because the program calls <span class="code">setValue()</span>.
                            If you want to know whether the user generated the event by dragging the slider's knob,
                            call the slider's boolean-valued <span class="code">isValueChanging()</span>
                            method, which returns <span class="code">true</span> if the user is dragging the knob.</p>


                        <p>Using tick marks on a slider is a two-step process: Specify the interval
                            between the tick marks, and tell the slider that the tick marks should be
                            displayed. There are actually two types of tick marks, "major" tick marks and
                            "minor" tick marks. You can have one or the other or both. Major tick marks are
                            a bit longer than minor tick marks. The method <span class="code">setMajorTickSpacing(x)</span>
                            indicates that there should be a major tick mark every <span class="code">x</span> units along
                            the slider. The parameter is of type <span class="ptype">double</span>. (The spacing is in terms of values on
                            the slider, not pixels.) To control the minor tick marks, you can call
                            <span class="code">setMinorTickCount(n)</span>.  The parameter is an <span class="ptype">int</span>
                            that specifies how many minor tick marks are placed between consecutive major
                            tick marks.  The default value is 4.  If you don't want minor tick marks, set
                            the count to zero.  Calling these methods is not enough to make
                            the tick marks appear. You also have to call <span class="code">setShowTickMarks(true)</span>. For
                            example, the second slider in the sample program was created and configured using
                            the commands:</p>


                        <pre><code class="java">slider2 = new Slider();  // Use default values (0,100,0)
slider2.setMajorTickUnit(25); // space between big tick marks
slider2.setMinorTickCount(5); // 5 small tick marks between big tick marks.
slider2.setShowTickMarks(true);
</code></pre>


                        <p>Labels on a slider are handled similarly.  A label will be placed at
                            every major tick mark, but some labels will be omitted if they would
                            overlap.  To see the labels, you need to call
                            <span class="code">setShowTickLabels(true)</span>.  For
                            example, the third slider in the above illustration was created and configured
                            to show labels with the commands:</p>


                        <pre><code class="java">slider3 = new Slider(2000,2100,2022);
slider3.setMajorTickUnit(50); // tick marks are not shown!
slider3.setShowTickLabels(true)</code></pre>


                        <p>The value of a slider is of type <span class="ptype">double</span>.  You might want
                            to restrict the value to be an integer, or to be some multiple of a given
                            value.  What you can do is call <span class="code">slider.setSnapToTicks(true)</span>.
                            After the user finishes dragging the slider's knob, the value will be
                            moved to the value at the nearest major or minor tick mark, even if the
                            tick marks are not visible.  The value will <b>not</b> be restricted
                            while the user is dragging the knob; the value is just adjusted at
                            the end of the drag.  The value set by calling <span class="code">setValue(x)</span>
                            is also <b>not</b> restricted, but there is another method, <span class="code">adjustValue(x)</span>,
                            that will set the value to the value at the tick mark nearest to&nbsp;<span class="code">x</span>.
                            For example, if you want a slider to snap to integral values in the range
                            0 to 10, you could say:</p>


                        <pre><code class="java">Slider sldr = new Slider(0,10,0);
sldr.setMajorTickUnit(1);  // major ticks 1 unit apart
sldr.setMinorTickCount(0); // no minor tick marks
sldr.setSnapToTicks(true);</code></pre>


                        <p>In the sample program, the third slider has been configured to snap to
                            an integer value at the end of a drag operation.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch06-03-BasicEvents.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch06-05-BasicLayout.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch06-03-BasicEvents.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch06-05-BasicLayout.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </body>
</html>
