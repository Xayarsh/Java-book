<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Parameters - Introduction to Programming Using Java</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

<link rel="stylesheet" href="code-class.css">
       
        <link rel="stylesheet" href="code-class.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html" >Introduction to Programming Using Java</a></li><li class="chapter-item expanded affix "><a href="preface.html">Preface</a></li><li class="chapter-item expanded "><a href="ch01-00-Overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-FetchExecuteCycle.html"><strong aria-hidden="true">1.1.</strong> Fetch and Execute Cycle</a></li><li class="chapter-item expanded "><a href="ch01-02-AsynchronousEvents.html"><strong aria-hidden="true">1.2.</strong> Asynchronous Events</a></li><li class="chapter-item expanded "><a href="ch01-03-JavaVirtualMachine.html"><strong aria-hidden="true">1.3.</strong> The Java Virtual Machine</a></li><li class="chapter-item expanded "><a href="ch01-04-FundamentalBuildingBlocks.html"><strong aria-hidden="true">1.4.</strong> Fundamentals</a></li><li class="chapter-item expanded "><a href="ch01-05-OOP.html"><strong aria-hidden="true">1.5.</strong> Object Oriented Programming</a></li><li class="chapter-item expanded "><a href="ch01-06-ModernUserInterface.html"><strong aria-hidden="true">1.6.</strong> Modern User Interface</a></li><li class="chapter-item expanded "><a href="ch01-07-InternetAndBeyond.html"><strong aria-hidden="true">1.7.</strong> Internet and Beyond</a></li><li class="chapter-item expanded "><a href="ch01-08-Quiz.html"><strong aria-hidden="true">1.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-NameAndThings.html"><strong aria-hidden="true">2.</strong> Name and Things</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-BasicJavaApplication.html"><strong aria-hidden="true">2.1.</strong> Basic Java Application</a></li><li class="chapter-item expanded "><a href="ch02-02-VariablesAndTypes.html"><strong aria-hidden="true">2.2.</strong> Variables and Types</a></li><li class="chapter-item expanded "><a href="ch02-03-ObjectsAndSubroutines.html"><strong aria-hidden="true">2.3.</strong> Objects and Subroutines</a></li><li class="chapter-item expanded "><a href="ch02-04-TextInputAndOutput.html"><strong aria-hidden="true">2.4.</strong> Text Input and Output</a></li><li class="chapter-item expanded "><a href="ch02-05-DetailsOfExpressions.html"><strong aria-hidden="true">2.5.</strong> Details of Expressions</a></li><li class="chapter-item expanded "><a href="ch02-06-ProgrammingEnvironments.html"><strong aria-hidden="true">2.6.</strong> Programming and Environments</a></li><li class="chapter-item expanded "><a href="ch02-07-Exercises.html"><strong aria-hidden="true">2.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch02-08-Quiz.html"><strong aria-hidden="true">2.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-Control.html"><strong aria-hidden="true">3.</strong> Control</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-BlocksLoopsBranches.html"><strong aria-hidden="true">3.1.</strong> Blocks, Loops and Branches</a></li><li class="chapter-item expanded "><a href="ch03-02-AlgorithmDevelopment.html"><strong aria-hidden="true">3.2.</strong> Algorithm Development</a></li><li class="chapter-item expanded "><a href="ch03-03-While.html"><strong aria-hidden="true">3.3.</strong> while and do...while</a></li><li class="chapter-item expanded "><a href="ch03-04-For.html"><strong aria-hidden="true">3.4.</strong> The for statement</a></li><li class="chapter-item expanded "><a href="ch03-05-If.html"><strong aria-hidden="true">3.5.</strong> The If Statement</a></li><li class="chapter-item expanded "><a href="ch03-06-Switch.html"><strong aria-hidden="true">3.6.</strong> The Switch Statement</a></li><li class="chapter-item expanded "><a href="ch03-07-ExceptionsTryCatch.html"><strong aria-hidden="true">3.7.</strong> Exceptions and try...catch</a></li><li class="chapter-item expanded "><a href="ch03-08-Arrays.html"><strong aria-hidden="true">3.8.</strong> Arrays: An Introduction</a></li><li class="chapter-item expanded "><a href="ch03-09-GUI.html"><strong aria-hidden="true">3.9.</strong> GUI: An Introduction</a></li><li class="chapter-item expanded "><a href="ch03-10-Exercises.html"><strong aria-hidden="true">3.10.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch03-11-Quiz.html"><strong aria-hidden="true">3.11.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-Subroutines.html"><strong aria-hidden="true">4.</strong> Subroutines</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-BlackBoxes.html"><strong aria-hidden="true">4.1.</strong> Black Boxes</a></li><li class="chapter-item expanded "><a href="ch04-02-StaticSubroutines.html"><strong aria-hidden="true">4.2.</strong> Static Subroutines and Variables</a></li><li class="chapter-item expanded "><a class="active" href="ch04-03-Parameters.html"><strong aria-hidden="true">4.3.</strong> Parameters</a></li><li class="chapter-item expanded "><a href="ch04-04-ReturnValues.html"><strong aria-hidden="true">4.4.</strong> Return Values</a></li><li class="chapter-item expanded "><a href="ch04-05-Lambda.html"><strong aria-hidden="true">4.5.</strong> Lambda Expressions</a></li><li class="chapter-item expanded "><a href="ch04-06-APIPackagesModulesJavadoc.html"><strong aria-hidden="true">4.6.</strong> API, Packages, Modules and Javadoc</a></li><li class="chapter-item expanded "><a href="ch04-07-MoreOnProgramDesign.html"><strong aria-hidden="true">4.7.</strong> More on Program Design</a></li><li class="chapter-item expanded "><a href="ch04-08-TruthAboutDeclarations.html"><strong aria-hidden="true">4.8.</strong> Truth about Declarations</a></li><li class="chapter-item expanded "><a href="ch04-09-Exercises.html"><strong aria-hidden="true">4.9.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch04-10-Quiz.html"><strong aria-hidden="true">4.10.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-ObjectsClasses.html"><strong aria-hidden="true">5.</strong> Objects and Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-ObjectsAndInstanceMethods.html"><strong aria-hidden="true">5.1.</strong> Objects and Instance Methods</a></li><li class="chapter-item expanded "><a href="ch05-02-ConstructorObjectInit.html"><strong aria-hidden="true">5.2.</strong> Constructor and Object Initialization</a></li><li class="chapter-item expanded "><a href="ch05-03-ProgrammingWithObjects.html"><strong aria-hidden="true">5.3.</strong> Programming with Objects</a></li><li class="chapter-item expanded "><a href="ch05-04-AnExample.html"><strong aria-hidden="true">5.4.</strong> An Example</a></li><li class="chapter-item expanded "><a href="ch05-05-InheritanceAndPolymorphism.html"><strong aria-hidden="true">5.5.</strong> Inheritance and Polymorphism</a></li><li class="chapter-item expanded "><a href="ch05-06-thisandsuper.html"><strong aria-hidden="true">5.6.</strong> this and super</a></li><li class="chapter-item expanded "><a href="ch05-07-Interfaces.html"><strong aria-hidden="true">5.7.</strong> Interfaces</a></li><li class="chapter-item expanded "><a href="ch05-08-NestedClasses.html"><strong aria-hidden="true">5.8.</strong> Nested Classes</a></li><li class="chapter-item expanded "><a href="ch05-09-Exercises.html"><strong aria-hidden="true">5.9.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch05-10-Quiz.html"><strong aria-hidden="true">5.10.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-GUIProgramming.html"><strong aria-hidden="true">6.</strong> Introduction to GUI Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-BasicJavaFXApp.html"><strong aria-hidden="true">6.1.</strong> A Basic JavaFX Application</a></li><li class="chapter-item expanded "><a href="ch06-02-BasicClasses.html"><strong aria-hidden="true">6.2.</strong> Basic Classes</a></li><li class="chapter-item expanded "><a href="ch06-03-BasicEvents.html"><strong aria-hidden="true">6.3.</strong> Basic Events</a></li><li class="chapter-item expanded "><a href="ch06-04-BasicControls.html"><strong aria-hidden="true">6.4.</strong> Basic Controls</a></li><li class="chapter-item expanded "><a href="ch06-05-BasicLayout.html"><strong aria-hidden="true">6.5.</strong> Basic Layout</a></li><li class="chapter-item expanded "><a href="ch06-06-CompetePrograms.html"><strong aria-hidden="true">6.6.</strong> Complete Programs</a></li><li class="chapter-item expanded "><a href="ch06-07-Exercises.html"><strong aria-hidden="true">6.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch06-08-Quiz.html"><strong aria-hidden="true">6.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-ArraysArraylistsRecords.html"><strong aria-hidden="true">7.</strong> Arrays, ArrayLists and Records</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-ArrayDetails.html"><strong aria-hidden="true">7.1.</strong> Array Details</a></li><li class="chapter-item expanded "><a href="ch07-02-ArrayProcessing.html"><strong aria-hidden="true">7.2.</strong> Array Processing</a></li><li class="chapter-item expanded "><a href="ch07-03-ArrayLists.html"><strong aria-hidden="true">7.3.</strong> ArrayLists</a></li><li class="chapter-item expanded "><a href="ch07-04-Records.html"><strong aria-hidden="true">7.4.</strong> Records</a></li><li class="chapter-item expanded "><a href="ch07-05-SearchingAndSorting.html"><strong aria-hidden="true">7.5.</strong> Searching and Sorting</a></li><li class="chapter-item expanded "><a href="ch07-06-2DArrays.html"><strong aria-hidden="true">7.6.</strong> 2D Arrays</a></li><li class="chapter-item expanded "><a href="ch07-07-Exercises.html"><strong aria-hidden="true">7.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch07-08-Quiz.html"><strong aria-hidden="true">7.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-CorrectnessRobustnessEfficiency.html"><strong aria-hidden="true">8.</strong> Correctness, Robustness, Efficiency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-IntroductionCorrectnessandRobustness.html"><strong aria-hidden="true">8.1.</strong> Introduction to Correctness and Robustness</a></li><li class="chapter-item expanded "><a href="ch08-02-WritingCorrectPrograms.html"><strong aria-hidden="true">8.2.</strong> Writing Correct Programs</a></li><li class="chapter-item expanded "><a href="ch08-03-ExceptionsAndtrycatch.html"><strong aria-hidden="true">8.3.</strong> Exceptions and try..catch</a></li><li class="chapter-item expanded "><a href="ch08-04-AssertionsAnnotations.html"><strong aria-hidden="true">8.4.</strong> Assertions and Annotations</a></li><li class="chapter-item expanded "><a href="ch08-05-AnalysisofAlgorithms.html"><strong aria-hidden="true">8.5.</strong> Analysis of Algorithms</a></li><li class="chapter-item expanded "><a href="ch08-06-Exercises.html"><strong aria-hidden="true">8.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch08-07-Quiz.html"><strong aria-hidden="true">8.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-LinkedDataStructuresRecursion.html"><strong aria-hidden="true">9.</strong> Linked Data Structures and Recursion</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-Recursion.html"><strong aria-hidden="true">9.1.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="ch09-02-LinkedDataStructures.html"><strong aria-hidden="true">9.2.</strong> Linked Data Structures</a></li><li class="chapter-item expanded "><a href="ch09-03-StacksQueuesADTs.html"><strong aria-hidden="true">9.3.</strong> Stacks, Queues and ADTs</a></li><li class="chapter-item expanded "><a href="ch09-04-BinaryTrees.html"><strong aria-hidden="true">9.4.</strong> Binary Trees</a></li><li class="chapter-item expanded "><a href="ch09-05-SimpleRecursiveDescentParser.html"><strong aria-hidden="true">9.5.</strong> A Simple Recursive Descent Parser</a></li><li class="chapter-item expanded "><a href="ch09-06-Exercises.html"><strong aria-hidden="true">9.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch09-07-Quiz.html"><strong aria-hidden="true">9.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-GenericProgrammingandCollectionClasses.html"><strong aria-hidden="true">10.</strong> Generic Programmingand Collection Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-GenericProgramming.html"><strong aria-hidden="true">10.1.</strong> Generic Programming</a></li><li class="chapter-item expanded "><a href="ch10-02-ListsandSets.html"><strong aria-hidden="true">10.2.</strong> Lists and Sets</a></li><li class="chapter-item expanded "><a href="ch10-03-Maps.html"><strong aria-hidden="true">10.3.</strong> Maps</a></li><li class="chapter-item expanded "><a href="ch10-04-JCF.html"><strong aria-hidden="true">10.4.</strong> Programming with the JCF</a></li><li class="chapter-item expanded "><a href="ch10-05-WritingGenericClassesandMethods.html"><strong aria-hidden="true">10.5.</strong> Writing Generic Classes and Methods</a></li><li class="chapter-item expanded "><a href="ch10-06-StreamAPI.html"><strong aria-hidden="true">10.6.</strong> Stream APIs</a></li><li class="chapter-item expanded "><a href="ch10-07-Exercises.html"><strong aria-hidden="true">10.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch10-08-Quiz.html"><strong aria-hidden="true">10.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-IOStreamsFilesNetworking.html"><strong aria-hidden="true">11.</strong> I/O Streams, Files, and Networking</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-IOStreamsReadersAndWriters.html"><strong aria-hidden="true">11.1.</strong> I/O Streams, Readers, and Writers</a></li><li class="chapter-item expanded "><a href="ch11-02-Files.html"><strong aria-hidden="true">11.2.</strong> Files</a></li><li class="chapter-item expanded "><a href="ch11-03-ProgrammingWithFiles.html"><strong aria-hidden="true">11.3.</strong> Programming With Files</a></li><li class="chapter-item expanded "><a href="ch11-04-Networking.html"><strong aria-hidden="true">11.4.</strong> Networking</a></li><li class="chapter-item expanded "><a href="ch11-05-XML.html"><strong aria-hidden="true">11.5.</strong> A Brief Introduction to XML</a></li><li class="chapter-item expanded "><a href="ch11-06-Exercises.html"><strong aria-hidden="true">11.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch11-07-Quiz.html"><strong aria-hidden="true">11.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-ThreadsandMultiprocessing.html"><strong aria-hidden="true">12.</strong> Threads and Multiprocessing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-IntroductiontoThreads.html"><strong aria-hidden="true">12.1.</strong> Introduction to Threads</a></li><li class="chapter-item expanded "><a href="ch12-02-ProgrammingwithThreads.html"><strong aria-hidden="true">12.2.</strong> Programming with Threads</a></li><li class="chapter-item expanded "><a href="ch12-03-ThreadsandParallelProcessing.html"><strong aria-hidden="true">12.3.</strong> Threads and Parallel Processing</a></li><li class="chapter-item expanded "><a href="ch12-04-ThreadsandNetworking.html"><strong aria-hidden="true">12.4.</strong> Threads and Networking</a></li><li class="chapter-item expanded "><a href="ch12-05-NetworkProgrammingExample.html"><strong aria-hidden="true">12.5.</strong> Network Programming Example</a></li><li class="chapter-item expanded "><a href="ch12-06-Exercises.html"><strong aria-hidden="true">12.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch12-07-Quiz.html"><strong aria-hidden="true">12.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-GUIProgrammingContinued.html"><strong aria-hidden="true">13.</strong> GUI Programming Continued</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-PropertiesandBindings.html"><strong aria-hidden="true">13.1.</strong> Properties and Bindings</a></li><li class="chapter-item expanded "><a href="ch13-02-FancierGraphics.html"><strong aria-hidden="true">13.2.</strong> Fancier Graphics</a></li><li class="chapter-item expanded "><a href="ch13-03-ComplexComponentsandMVC.html"><strong aria-hidden="true">13.3.</strong> Complex Components and MVC</a></li><li class="chapter-item expanded "><a href="ch13-04-MostlyWindowsandDialogs.html"><strong aria-hidden="true">13.4.</strong> Mostly Windows and Dialogs</a></li><li class="chapter-item expanded "><a href="ch13-05-FinishingTouches.html"><strong aria-hidden="true">13.5.</strong> Finishing Touches</a></li><li class="chapter-item expanded "><a href="ch13-06-Exercises.html"><strong aria-hidden="true">13.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch13-07-Quiz.html"><strong aria-hidden="true">13.7.</strong> Quiz</a></li></ol><li class="chapter-item expanded "><a href="appendix-00.html"> Appendix</a></li><li class="chapter-item expanded "><a href="glossary-00.html"> Glossary</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="Java">Java</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Introduction to Programming Using Java</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Xayarsh/Java-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Parameters"><a class="header" href="#Parameters">Parameters</a></h2>
                        <p>
                            If a subroutine is a black box, then a parameter
                            is something that
                            provides a mechanism for passing information from the outside world into the
                            box. Parameters are part of the interface of a subroutine. They allow you to
                            customize the behavior of a subroutine to adapt it to a particular
                            situation.</p>


                        <p>As an analogy, consider a thermostat&mdash;a black box whose task it is to keep
                            your house at a certain temperature. The thermostat has a parameter, namely the
                            dial that is used to set the desired temperature. The thermostat always
                            performs the same task: maintaining a constant temperature. However, the exact
                            task that it performs&mdash;that is, <b>which</b> temperature it
                            maintains&mdash;is customized by the setting on its dial.</p>

                       <h3 id="Using Parameters"><a class="header" href="#Using Parameters">Using Parameters</a></h3>

                        <p>As an example, let's go back to the "3N+1" problem that was discussed in
                            <a href="ch03-02-AlgorithmDevelopment.html">Subsection&nbsp;3.2.2</a>. (Recall that a 3N+1 sequence is
                            computed according to the rule, "if N is odd, multiply it by 3 and add 1; if N is
                            even, divide it by 2; continue until N is equal to 1." For example, starting from
                            N=3 we get the sequence: 3, 10, 5, 16, 8, 4, 2, 1.) Suppose that we want to
                            write a subroutine to print out such sequences. The subroutine will always
                            perform the same task: Print out a 3N+1 sequence. But the exact sequence it
                            prints out depends on the starting value of N. So, the starting value of N
                            would be a parameter to the subroutine. The subroutine can be written like
                            this:</p>


                        <pre><code class="java">/**
 * This subroutine prints a 3N+1 sequence to standard output, using
 * startingValue as the initial value of N.  It also prints the number 
 * of terms in the sequence. The value of the parameter, startingValue, 
 * must  be a positive integer.
 */
static void print3NSequence(int startingValue) {
      
   int N;      // One of the terms in the sequence.
   int count;  // The number of terms.
  
   N = startingValue;  // The first term is whatever value
                       //    is passed to the subroutine as 
                       //    a parameter.
   
   count = 1; // We have one term, the starting value, so far.
   
   System.out.println("The 3N+1 sequence starting from " + N);
   System.out.println();
   System.out.println(N);  // print initial term of sequence
 
   while (N &gt; 1) {
       if (N % 2 == 1)     // is N odd?
          N = 3 * N + 1;
       else
          N = N / 2;
       count++;   // count this term
       System.out.println(N);  // print this term
   }
   
   System.out.println();
   System.out.println("There were " + count + " terms in the sequence.");

}  // end print3NSequence</code></pre>


                        <p>The parameter list of this subroutine, "<span class="code">(int&nbsp;startingValue)</span>",
                            specifies that the subroutine has one parameter, of type <span class="ptype">int</span>.   Within
                            the body of the subroutine, the parameter name can be used in the same way as a
                            variable name.  But notice that there is nothing in the subroutine definition that
                            gives a value to the parameter!
                            The parameter gets its initial value from <b>outside</b> the subroutine.  When the
                            subroutine is called, a value must be provided for the parameter in the subroutine call
                            statement.  This value
                            will be assigned to <span class="code">startingValue</span> before the body of the
                            subroutine is executed.  For example, the subroutine could be called using the
                            subroutine call statement "<span class="code">print3NSequence(17);</span>". When the computer
                            executes this statement, the computer first assigns the value 17 to
                            <span class="code">startingValue</span> and then executes the statements in the subroutine. This
                            prints the 3N+1 sequence starting from 17. If <span class="code">K</span> is a variable of type
                            <span class="ptype">int</span>, then the subroutine can be called by saying "<span class="code">print3NSequence(K);</span>".
                            When the computer executes this subroutine call statement, it takes the value of the variable
                            <span class="code">K</span>, assigns that value to <span class="code">startingValue</span>, and then executes the body
                            of the subroutine.</p>


                        <p>The class that contains <span class="code">print3NSequence</span> can contain a
                            <span class="code">main()</span> routine (or other subroutines) that call
                            <span class="code">print3NSequence</span>. For example, here is a <span class="code">main()</span> program that
                            prints out 3N+1 sequences for various starting values specified by the
                            user:</p>


                        <pre><code class="java">public static void main(String[] args) {
   System.out.println("This program will print out 3N+1 sequences");
   System.out.println("for starting values that you specify.");
   System.out.println();
   int K;  // Input from user; loop ends when K &lt; 0.
   do {
      System.out.println("Enter a starting value.");
      System.out.print("To end the program, enter 0: ");
      K = TextIO.getInt();  // Get starting value from user.
      if (K &gt; 0)   // Print sequence, but only if K is &gt; 0.
         print3NSequence(K);
   } while (K &gt; 0);   // Continue only if K &gt; 0.
} // end main</code></pre>


                        <p>Remember that before you can use this program, the definitions of
                            <span class="code">main</span> and of <span class="code">print3NSequence</span> must both be
                            wrapped inside a class definition.</p>

                        
                       <h3 id="Formal and Actual Parameters"><a class="header" href="#Formal and Actual Parameters">Formal and Actual Parameters</a></h3>

                        <p>Note that the term "parameter" is used to refer to two different, but
                            related, concepts. There are parameters that are used in the definitions of
                            subroutines, such as <span class="code">startingValue</span> in the above example. And there are
                            parameters that are used in subroutine call statements, such as the <span class="code">K</span>
                            in the statement "<span class="code">print3NSequence(K);</span>". Parameters in a subroutine
                            definition are called <span class="newword">formal parameters</span> or
                            <span class="newword">dummy parameters</span>. The parameters that are passed
                            to a subroutine when it is called are called <span class="newword">actual parameters</span>
                            or <span class="newword">arguments</span>.
                            When a subroutine is called, the actual parameters in the
                            subroutine call statement are evaluated and the values are assigned to the
                            formal parameters in the subroutine's definition. Then the body of the
                            subroutine is executed.</p>


                        <p>A formal parameter must be a <b>name</b>, that is, a simple identifier.
                            A formal parameter is very much like a variable, and&mdash;like a variable&mdash;it
                            has a specified type such as <span class="ptype">int</span>, <span class="ptype">boolean</span>,
                            <span class="classname">String</span>, or <span class="atype">double[]</span>.
                            An actual parameter is a <b>value</b>, and so it can
                            be specified by any expression, provided that the expression computes a value
                            of the correct type. The type of the actual parameter must be one that could
                            legally be assigned to the formal parameter with an assignment statement. For
                            example, if the formal parameter is of type <span class="ptype">double</span>, then it would be
                            legal to pass an <span class="ptype">int</span> as the actual parameter since <span class="ptype">ints</span> can
                            legally be assigned to <span class="ptype">doubles</span>.  When you call a subroutine, you must
                            provide one actual parameter for each formal parameter in the subroutine's
                            definition. Consider, for example, a subroutine</p>


                        <pre><code class="java">static void doTask(int N, double x, boolean test) {
    // statements to perform the task go here
}</code></pre>


                        <p>This subroutine might be called with the statement</p>


                        <pre><code class="java">doTask(17, Math.sqrt(z+1), z &gt;= 10);</code></pre>


                        <p>When the computer executes this statement, it has essentially the same
                            effect as the block of statements:</p>


                        <pre><code class="java">{
  int N;       // Allocate memory locations for the formal parameters.
  double x;
  boolean test;
  N = 17;              // Assign 17 to the first formal parameter, N.
  x = Math.sqrt(z+1);  // Compute Math.sqrt(z+1), and assign it to
                       //    the second formal parameter, x.
  test = (z &gt;= 10);    // Evaluate "z &gt;= 10" and assign the resulting
                       //     true/false value to the third formal 
                       //     parameter, test.
   // statements to perform the task go here
}</code></pre>


                        <p>(There are a few technical differences between this and
                            "<span class="code">doTask(17,Math.sqrt(z+1),z&gt;=10);</span>" &mdash;besides the amount of typing&mdash;because
                            of questions about scope of variables and what happens when several
                            variables or parameters have the same name.)</p>


                        <p>Beginning programming students often find parameters to be surprisingly
                            confusing. Calling a subroutine that already exists is not a problem&mdash;the
                            idea of providing information to the subroutine in a parameter is clear enough.
                            Writing the subroutine definition is another matter. A common beginner's mistake is to
                            assign values to the formal parameters at the beginning of the subroutine, or
                            to ask the user to input their values. <b>This represents a fundamental
                                misunderstanding.</b> By the time the computer starts executing the statements in the subroutine, the
                            formal parameters have <b>already</b> been assigned initial values!  The computer automatically
                            assigns values to the formal parameters before it starts executing the code inside the
                            subroutine. The values come from the actual parameters in the subroutine
                            call statement. Remember that a subroutine is not independent. It is called by
                            some other routine, and it is the subroutine call statement's responsibility to provide
                            appropriate values for the parameters.</p>

                        
                       <h3 id="Overloading"><a class="header" href="#Overloading">Overloading</a></h3>

                        <p>In order to call a subroutine legally, you need to know its name, you need
                            to know how many formal parameters it has, and you need to know the type of
                            each parameter. This information is called the subroutine's <span class="newword">signature</span>.
                            The signature of the subroutine <span class="code">doTask</span>, used as an example above, can
                            be expressed as: <span class="code">doTask(int,double,boolean)</span>. Note that the signature does
                            <b>not</b> include the names of the parameters; in fact, if you just
                            want to <b>use</b> the subroutine, you don't even need to know what
                            the formal parameter names are, so the names are not part of the interface.</p>


                        <p>Java is somewhat unusual in that it allows two different subroutines in the
                            same class to have the same name, provided that their signatures are different.
                            When this happens, we say that
                            the name of the subroutine is <span class="newword">overloaded</span> because
                            it has several different meanings. The computer doesn't get the subroutines
                            mixed up. It can tell which one you want to call by the number and types of the
                            actual parameters that you provide in the subroutine call statement. You have
                            already seen overloading used with <span class="classname">System.out</span>. This object includes
                            many different methods named <span class="code">println</span>, for example. These methods all
                            have different signatures, such as:</p>


                        <pre><code class="java">
println(int)                   println(double)
println(char)                  println(boolean)
println()</code></pre>


                        <p>The computer knows which of these subroutines you want to use based on
                            the type of the actual parameter that you provide.  <span class="code">System.out.println(17)</span>
                            calls the subroutine with signature <span class="code">println(int)</span>, while
                            <span class="code">System.out.println('A')</span> calls the subroutine with signature <span class="code">println(char)</span>.
                            Of course all these different subroutines are semantically related, which is
                            why it is acceptable programming style to use the same name for them all. But
                            as far as the computer is concerned, printing out an <span class="ptype">int</span> is very
                            different from printing out a <span class="ptype">char</span>, which is different from printing
                            out a <span class="ptype">boolean</span>, and so forth&mdash;so that each of these operations
                            requires a different subroutine.</p>


                        <p>Note, by the way, that the signature does <b>not</b> include the
                            subroutine's return type. It is illegal to have two subroutines in the same
                            class that have the same signature but that have different return types. For
                            example, it would be a syntax error for a class to contain two subroutines defined
                            as:</p>


                        <pre><code class="java">int    getln() { ... }
double getln() { ... }</code></pre>


                        <p>This is why in the <span class="classname">TextIO</span> class, the subroutines
                            for reading different types are not all named <span class="code">getln()</span>. In a given
                            class, there can only be one routine that has the name <span class="code">getln</span> with
                            no parameters. So, the input routines in <span class="classname">TextIO</span> are distinguished by
                            having different names, such as <span class="code">getlnInt()</span> and
                            <span class="code">getlnDouble()</span>.</p>

                        
                       <h3 id="Subroutine Examples"><a class="header" href="#Subroutine Examples">Subroutine Examples</a></h3>

                        <p>Let's do a few examples of writing small subroutines to perform assigned
                            tasks. Of course, this is only one side of programming with subroutines. The
                            task performed by a subroutine is always a subtask in a larger program. The art
                            of designing those programs&mdash;of deciding how to break them up into subtasks&mdash;is
                            the other side of programming with subroutines. We'll return to the
                            question of program design in <a href="ch04-07-MoreOnProgramDesign.html">Section&nbsp;4.7</a>.</p>


                        <p>As a first example, let's write a subroutine to compute and print out all
                            the divisors of a given positive integer. The integer will be a parameter to
                            the subroutine. Remember that the syntax of any subroutine is:</p>


                        <pre><code class="java">
<span class="bnf">modifiers</span>  <span class="bnf">return-type</span>  <span class="bnf">subroutine-name</span>  ( <span class="bnf">parameter-list</span> ) {
    <span class="bnf">statements</span>
}</code></pre>


                        <p>Writing a subroutine always means filling out this format. In this case,
                            the statement of the problem implies that there is one parameter,
                            of type <span class="ptype">int</span>, that represents the "given integer" whose
                            divisors are to be printed.  And it tells us
                            what the statements in the body of the subroutine should do. Since we are only
                            working with static subroutines for now, we'll need to use <span class="code">static</span> as a
                            modifier. We could add an access modifier (<span class="code">public</span> or
                            <span class="code">private</span>), but in the absence of any instructions, I'll leave it out.
                            Since we are not told to return a value, the return type is <span class="code">void</span>.
                            Since no names are specified, we'll have to make up names for the formal
                            parameter and for the subroutine itself. I'll use <span class="code">N</span> for the parameter
                            and <span class="code">printDivisors</span> for the subroutine name. The subroutine will look
                            like</p>


                        <pre><code class="java">static void printDivisors( int N ) {
    <span class="bnf">statements</span>
}</code></pre>


                        <p>and all we have left to do is to write the statements that make up the body
                            of the routine. This is not difficult. Just remember that you have to write the
                            body assuming that <span class="code">N</span> already has a value! The algorithm is: "For each
                            possible divisor <span class="code">D</span> in the range from <span class="code">1</span> to <span class="code">N</span>, if
                            <span class="code">D</span> evenly divides <span class="code">N</span>, then print <span class="code">D</span>." Written in Java,
                            this becomes:</p>


                        <pre><code class="java">/**
 * Print all the divisors of N.
 * We assume that N is a positive integer.
 */
static void printDivisors( int N ) {
    int D;   // One of the possible divisors of N.
    System.out.println("The divisors of " + N + " are:");
    for ( D = 1; D &lt;= N; D++ ) {
       if ( N % D == 0 )  // Does D evenly divide N?
          System.out.println(D);
    }
}</code></pre>


                        <p>I've added a comment before the subroutine definition
                            indicating the contract of the subroutine&mdash;that is,
                            what it does and what assumptions it makes. The contract includes the
                            assumption that <span class="code">N</span> is a positive integer.   It is up to the caller of the
                            subroutine to make sure that this assumption is satisfied.</p>


                        <p>As a second short example, consider the problem: Write a <span class="code">private </span>subroutine named
                            <span class="code">printRow</span>. It should have a parameter <span class="code">ch</span> of type <span class="ptype">char</span>
                            and a parameter <span class="code">N</span> of type <span class="ptype">int</span>. The subroutine should print
                            out a line of text containing <span class="code">N</span> copies of the character
                            <span class="code">ch</span>.</p>


                        <p>Here, we are told the name of the subroutine and the names of the two
                            parameters, and we are told that the subroutine is <span class="code">private</span>,
                            so we don't have much choice about the first line of the subroutine
                            definition. The task in this case is pretty simple, so the body of the
                            subroutine is easy to write. The complete subroutine is given by</p>


                        <pre><code class="java">/**
 * Write one line of output containing N copies of the
 * character ch.  If N &lt;= 0, an empty line is output.
 */
private static void printRow( char ch, int N ) {
    int i;  // Loop-control variable for counting off the copies.
    for ( i = 1; i &lt;= N; i++ ) {
        System.out.print( ch );
    }
    System.out.println();
}</code></pre>


                        <p>Note that in this case, the contract makes no assumption about <span class="code">N</span>,
                            but it makes it clear what will happen in all cases, including the unexpected
                            case that <span class="code">N&nbsp;&lt;=&nbsp;0</span>.</p>


                        <p>Finally, let's do an example that shows how one subroutine can build on
                            another. Let's write a subroutine that takes a <span class="classname">String</span> as a parameter.
                            For each character in the string, it should print a line of output containing 25
                            copies of that character. It should use the <span class="code">printRow()</span> subroutine defined above to
                            produce the output.</p>


                        <p>Again, we get to choose a name for the subroutine and a name for the
                            parameter. I'll call the subroutine <span class="code">printRowsFromString</span> and the
                            parameter <span class="code">str</span>. The algorithm is pretty clear: For each position
                            <span class="code">i</span> in the string <span class="code">str</span>, call <span class="code">printRow(str.charAt(i),25)</span>
                            to print one line of the output that contains 25 copies of character number <span class="code">i</span>
                            from the string. So, we get:</p>


                        <pre><code class="java">/**
 * For each character in str, write a line of output
 * containing 25 copies of that character.
 */
private static void printRowsFromString( String str ) {
    int i;  // Loop-control variable for counting off the chars.
    for ( i = 0; i &lt; str.length(); i++ ) {
        printRow( str.charAt(i), 25 );
    }
}</code></pre>


                        <p>We could then use <span class="code">printRowsFromString</span> in a <span class="code">main()</span> routine such
                            as</p>


                        <pre><code class="java">public static void main(String[] args) {
    String inputLine;  // Line of text input by user.
    System.out.print("Enter a line of text: ");
    inputLine = TextIO.getln();
    System.out.println();
    printRowsFromString( inputLine );
}</code></pre>


                        <p>Of course, the three routines, <span class="code">main()</span>,
                            <span class="code">printRowsFromString()</span>, and <span class="code">printRow()</span>, would have to be
                            collected together inside the same class. The program is rather useless, but it
                            does demonstrate the use of subroutines. You'll find the program in the file
                            <span class="sourceref"><a href="./source/chapter4/RowsOfChars.java">RowsOfChars.java</a></span>, if you want to take a
                            look.</p>

                       <h3 id="Array Parameters"><a class="header" href="#Array Parameters">Array Parameters</a></h3>

                        <p>It's possible for the type of a parameter to be an array type.  This means that
                            an entire array of values can be passed to the subroutine as a single parameter.
                            For example, we might want a subroutine to print all the values in an integer array
                            in a neat format, separated by commas and enclosed in a pair of square brackets.
                            To tell it which array to print, the subroutine would have a parameter of
                            type <span class="atype">int[]</span>:</p>


                        <pre><code class="java">static void printValuesInList( int[] list ) {
    System.out.print('[');
    int i;
    for ( i = 0; i &lt; list.length; i++ ) {
        if ( i &gt; 0 )
            System.out.print(','); // No comma in front of list[0]
        System.out.print(list[i]);
    }
    System.out.println(']');
}</code></pre>


                        <p>To use this subroutine, you need an actual array.  Here is a legal, though not very
                            realistic, code segment that creates an array just to pass it as an argument to
                            the subroutine:</p>


                        <pre><code class="java">int[] numbers;
numbers = new int[3];
numbers[0] = 42;
numbers[1] = 17;
numbers[2] = 256;
printValuesInList( numbers );</code></pre>


                        <p>The output produced by the last statement would be <span class="code">[42,17,256]</span>.</p>

                       <h3 id="Command-line Arguments"><a class="header" href="#Command-line Arguments">Command-line Arguments</a></h3>

                        <p>The <span class="code">main</span> routine of a program has a parameter of type
                            <span class="atype">String[]</span>.  When the main routine is called, some actual array
                            of <span class="classname">String</span> must be passed to <span class="code">main()</span> as the value
                            of the parameter.  The system provides the actual parameter when it calls <span class="code">main()</span>,
                            so the values come from outside the program.  Where do the strings in the array
                            come from, and what do they mean?  The
                            strings in the array are <span class="newword">command-line arguments</span> from the
                            command that was used to run the program.
                            When using a command-line interface, the user types a
                            command to tell the system to execute a program. The user can include extra
                            input in this command, beyond the name of the program. This extra input becomes
                            the command-line arguments.   The system takes the command-line arguments,
                            puts them into an array of strings, and passes that array to <span class="code">main()</span>.</p>


                        <p>For example, if the name of the program is <span class="code">myProg</span>, then the user can type
                            "<span class="code">java&nbsp;myProg</span>" to execute the program. In this case, there are no
                            command-line arguments. But if the user types the command</p>


                        <pre><code class="console">$ java myProg one two three</code></pre>


                        <p>then the command-line arguments are the strings "one", "two",
                            and "three". The system puts these strings into an array of <span class="classname">Strings</span>
                            and passes that array as a parameter to the <span class="code">main()</span> routine. Here, for
                            example, is a short program that simply prints out any command line arguments
                            entered by the user:</p>


                        <pre><code class="java">public class CLDemo {
   
   public static void main(String[] args) {
      System.out.println("You entered " + args.length
                                  + " command-line arguments");
      if (args.length &gt; 0) {
         System.out.println("They were:");
         int i;
         for ( i = 0; i &lt; args.length; i++ )
            System.out.println("   " + args[i]);
      }
   } // end main()
   
} // end class CLDemo</code></pre>


                        <p>Note that the parameter, <span class="code">args</span>, can be an array of length
                            zero.  This just means that the user did not include any command-line arguments
                            when running the program. </p>


                        <p>In practice, command-line arguments are often used to pass the names of
                            files to a program.  For example, consider the following program for making
                            a copy of a text file.  It does this by copying one line at a time from
                            the original file to the copy, using TextIO.  The function
                            <span class="code">TextIO.eof()</span> is a <span class="ptype">boolean</span>-valued function that
                            is <span class="code">true</span> if the end of the input file has been reached.</p>


                        <pre><code class="java">input textio.TextIO;

/**
 *  Requires two command line arguments, which must be file names.  The
 *  first must be the name of an existing file.  The second is the name
 *  of a file to be created by the program.  The contents of the first file
 *  are copied into the second.  WARNING:  If the second file already 
 *  exists when the program is run, its previous contents will be lost!
 *  This program only works for plain text files.
 */
public class CopyTextFile {

    public static void main( String[] args ) {
        if (args.length &lt; 2 ) {
            System.out.println("Two command-line arguments are required!");
            System.exit(1);
        }
        TextIO.readFile( args[0] );   // Open the original file for reading.
        TextIO.writeFile( args[1] );  // Open the copy file for writing.
        int lineCount;  // Number of lines copied
        lineCount = 0;
        while ( TextIO.eof() == false ) {
            // Read one line from the original file and write it to the copy.
            String line;
            line = TextIO.getln();
            TextIO.putln(line);
            lineCount++;
        }
        System.out.printf( "%d lines copied from %s to %s%n",
                                lineCount, args[0], args[1] );
    }

}</code></pre>


                        <p>Since most programs are run in a GUI environment these days, command-line arguments
                            aren't as important as they used to be.  But at least they provide a nice example
                            of how array parameters can be used.</p>
                        
                       <h3 id="Throwing Exceptions"><a class="header" href="#Throwing Exceptions">Throwing Exceptions</a></h3>


                        <p>I have been talking about the "contract" of a subroutine.  The contract says
                            what the subroutine will do, provided that the caller of the subroutine
                            provides acceptable values for the subroutine's parameters.  The question
                            arises, though, what should the subroutine do when the caller violates
                            the contract by providing bad parameter values?</p>


                        <p>We've already seen that some subroutines respond to bad parameter
                            values by throwing exceptions.  (See <a href="ch03-07-ExceptionsTryCatch.html">Section&nbsp;3.7</a>.)
                            For example, the contract of the built-in subroutine
                            <span class="code">Double.parseDouble</span> says that the parameter should be
                            a string representation of a number of type <span class="ptype">double</span>;
                            if this is true, then the subroutine will convert the string into the
                            equivalent numeric value.  If the caller violates the contract by
                            passing an invalid string as the actual parameter, the subroutine responds by
                            throwing an exception of type <span class="classname">NumberFormatException</span>.</p>


                        <p>Many subroutines throw <span class="classname">IllegalArgumentExceptions</span>
                            in response to bad parameter values.  You might want to do the same
                            in your own subroutines.  This can be done with a <span class="newword">throw statement</span>.
                            An exception is an object, and in order to throw an exception, you must
                            create an exception object.  You won't officially learn how to do this until <a href="ch05-00-ObjectsClasses.html">Chapter&nbsp;5</a>,
                            but for now, you can use the following syntax for a <span class="code">throw</span>
                            statement that throws an <span class="classname">IllegalArgumentException</span>:</p>


                        <pre><code class="java">throw  new  IllegalArgumentException( <span class="bnf">error-message</span> );</code></pre>


                        <p>where <span class="bnf">error-message</span> is a string that describes the error that
                            has been detected.   (The word "new" in this statement is what creates the object.)
                            To use this statement in a subroutine, you would check whether the values
                            of the parameters are legal.  If not, you would throw the exception. For
                            example, consider the <span class="code">print3NSequence</span> subroutine from
                            the beginning of this section.  The parameter of <span class="code">print3NSequence</span>
                            is supposed to be a positive integer.  We can modify the subroutine definition
                            to make it throw an exception when this condition is violated:</p>


                        <pre><code class="java">static void print3NSequence(int startingValue) {
   
   <span class="newcode">if (startingValue &lt;= 0)  // The contract is violated!
      throw new IllegalArgumentException( "Starting value must be positive." );</span>
   .
   .  // (The rest of the subroutine is the same as before.)
   .</code></pre>


                        <p>If the start value is bad, the computer executes the <span class="code">throw</span> statement.
                            This will immediately terminate the subroutine, without executing the rest of the
                            body of the subroutine.  Furthermore, the program as a whole will crash unless
                            the exception is "caught" and handled elsewhere in the program by a
                            <span class="code">try..catch</span> statement, as discussed in <a href="ch03-07-ExceptionsTryCatch.html">Section&nbsp;3.7</a>.
                            For this to work, the subroutine call would have to be in the "try" part of
                            the statement.</p>
                        
                       <h3 id="Global and Local Variables"><a class="header" href="#Global and Local Variables">Global and Local Variables</a></h3>

                        <p>I'll finish this section on parameters by noting that we now have three
                            different sorts of variables that can be used inside a subroutine: local
                            variables declared in the subroutine, formal parameter names, and static member
                            variables that are declared outside the subroutine.</p>


                        <p>Local variables have no connection to the outside world; they are purely
                            part of the internal working of the subroutine.</p>


                        <p>Parameters are used to "drop"
                            values into the subroutine when it is called, but once the subroutine starts
                            executing, parameters act much like local variables. Changes made inside a
                            subroutine to a formal parameter have no effect on the rest of the program (at
                            least if the type of the parameter is one of the primitive types&mdash;things are
                            more complicated in the case of arrays and objects, as we'll see later).</p>


                        <p>Things are different when a subroutine uses a variable that is defined
                            outside the subroutine. That variable exists independently of the subroutine,
                            and it is accessible to other parts of the program as well.
                            Such a variable is said to be <span class="newword">global</span>
                            to the subroutine, as opposed to the local variables defined inside the
                            subroutine. A global variable can be used in the entire class in which
                            it is defined and, if it is not <span class="code">private</span>, in other classes as well.
                            Changes made to a global variable can have effects that extend
                            outside the subroutine where the changes are made. You've seen how this works
                            in the last example in the <a href="ch04-02-StaticSubroutines.html">previous section</a>, where the
                            values of the global variables, <span class="code">gamesPlayed</span>
                            and <span class="code">gamesWon</span>, are computed inside a
                            subroutine and are used in the <span class="code">main()</span> routine.</p>


                        <p>It's not always bad to use global variables in subroutines, but you should
                            realize that the global variable then has to be considered part of the
                            subroutine's interface. The subroutine uses the global variable to communicate
                            with the rest of the program. This is a kind of sneaky, back-door communication
                            that is less visible than communication done through parameters, and it risks
                            violating the rule that the interface of a black box should be straightforward
                            and easy to understand. So before you use a global variable in a subroutine,
                            you should consider whether it's really necessary.</p>


                        <p>I don't advise you to take an absolute stand against using global variables
                            inside subroutines. There is at least one good reason to do it: If you think of
                            the class as a whole as being a kind of black box, it can be very reasonable to
                            let the subroutines inside that box be a little sneaky about communicating with
                            each other, if that will make the class as a whole look simpler from the
                            outside.</p>
                        
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch04-02-StaticSubroutines.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch04-04-ReturnValues.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch04-02-StaticSubroutines.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch04-04-ReturnValues.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </body>
</html>
