<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>A Simple Recursive Descent Parser - Introduction to Programming Using Java</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

<link rel="stylesheet" href="code-class.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html" >Introduction to Programming Using Java</a></li><li class="chapter-item expanded affix "><a href="preface.html">Preface</a></li><li class="chapter-item expanded "><a href="ch01-00-Overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-FetchExecuteCycle.html"><strong aria-hidden="true">1.1.</strong> Fetch and Execute Cycle</a></li><li class="chapter-item expanded "><a href="ch01-02-AsynchronousEvents.html"><strong aria-hidden="true">1.2.</strong> Asynchronous Events</a></li><li class="chapter-item expanded "><a href="ch01-03-JavaVirtualMachine.html"><strong aria-hidden="true">1.3.</strong> The Java Virtual Machine</a></li><li class="chapter-item expanded "><a href="ch01-04-FundamentalBuildingBlocks.html"><strong aria-hidden="true">1.4.</strong> Fundamentals</a></li><li class="chapter-item expanded "><a href="ch01-05-OOP.html"><strong aria-hidden="true">1.5.</strong> Object Oriented Programming</a></li><li class="chapter-item expanded "><a href="ch01-06-ModernUserInterface.html"><strong aria-hidden="true">1.6.</strong> Modern User Interface</a></li><li class="chapter-item expanded "><a href="ch01-07-InternetAndBeyond.html"><strong aria-hidden="true">1.7.</strong> Internet and Beyond</a></li><li class="chapter-item expanded "><a href="ch01-08-Quiz.html"><strong aria-hidden="true">1.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-NameAndThings.html"><strong aria-hidden="true">2.</strong> Name and Things</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-BasicJavaApplication.html"><strong aria-hidden="true">2.1.</strong> Basic Java Application</a></li><li class="chapter-item expanded "><a href="ch02-02-VariablesAndTypes.html"><strong aria-hidden="true">2.2.</strong> Variables and Types</a></li><li class="chapter-item expanded "><a href="ch02-03-ObjectsAndSubroutines.html"><strong aria-hidden="true">2.3.</strong> Objects and Subroutines</a></li><li class="chapter-item expanded "><a href="ch02-04-TextInputAndOutput.html"><strong aria-hidden="true">2.4.</strong> Text Input and Output</a></li><li class="chapter-item expanded "><a href="ch02-05-DetailsOfExpressions.html"><strong aria-hidden="true">2.5.</strong> Details of Expressions</a></li><li class="chapter-item expanded "><a href="ch02-06-ProgrammingEnvironments.html"><strong aria-hidden="true">2.6.</strong> Programming and Environments</a></li><li class="chapter-item expanded "><a href="ch02-07-Exercises.html"><strong aria-hidden="true">2.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch02-08-Quiz.html"><strong aria-hidden="true">2.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-Control.html"><strong aria-hidden="true">3.</strong> Control</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-BlocksLoopsBranches.html"><strong aria-hidden="true">3.1.</strong> Blocks, Loops and Branches</a></li><li class="chapter-item expanded "><a href="ch03-02-AlgorithmDevelopment.html"><strong aria-hidden="true">3.2.</strong> Algorithm Development</a></li><li class="chapter-item expanded "><a href="ch03-03-While.html"><strong aria-hidden="true">3.3.</strong> while and do...while</a></li><li class="chapter-item expanded "><a href="ch03-04-For.html"><strong aria-hidden="true">3.4.</strong> The for statement</a></li><li class="chapter-item expanded "><a href="ch03-05-If.html"><strong aria-hidden="true">3.5.</strong> The If Statement</a></li><li class="chapter-item expanded "><a href="ch03-06-Switch.html"><strong aria-hidden="true">3.6.</strong> The Switch Statement</a></li><li class="chapter-item expanded "><a href="ch03-07-ExceptionsTryCatch.html"><strong aria-hidden="true">3.7.</strong> Exceptions and try...catch</a></li><li class="chapter-item expanded "><a href="ch03-08-Arrays.html"><strong aria-hidden="true">3.8.</strong> Arrays: An Introduction</a></li><li class="chapter-item expanded "><a href="ch03-09-GUI.html"><strong aria-hidden="true">3.9.</strong> GUI: An Introduction</a></li><li class="chapter-item expanded "><a href="ch03-10-Exercises.html"><strong aria-hidden="true">3.10.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch03-11-Quiz.html"><strong aria-hidden="true">3.11.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-Subroutines.html"><strong aria-hidden="true">4.</strong> Subroutines</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-BlackBoxes.html"><strong aria-hidden="true">4.1.</strong> Black Boxes</a></li><li class="chapter-item expanded "><a href="ch04-02-StaticSubroutines.html"><strong aria-hidden="true">4.2.</strong> Static Subroutines and Variables</a></li><li class="chapter-item expanded "><a href="ch04-03-Parameters.html"><strong aria-hidden="true">4.3.</strong> Parameters</a></li><li class="chapter-item expanded "><a href="ch04-04-ReturnValues.html"><strong aria-hidden="true">4.4.</strong> Return Values</a></li><li class="chapter-item expanded "><a href="ch04-05-Lambda.html"><strong aria-hidden="true">4.5.</strong> Lambda Expressions</a></li><li class="chapter-item expanded "><a href="ch04-06-APIPackagesModulesJavadoc.html"><strong aria-hidden="true">4.6.</strong> API, Packages, Modules and Javadoc</a></li><li class="chapter-item expanded "><a href="ch04-07-MoreOnProgramDesign.html"><strong aria-hidden="true">4.7.</strong> More on Program Design</a></li><li class="chapter-item expanded "><a href="ch04-08-TruthAboutDeclarations.html"><strong aria-hidden="true">4.8.</strong> Truth about Declarations</a></li><li class="chapter-item expanded "><a href="ch04-09-Exercises.html"><strong aria-hidden="true">4.9.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch04-10-Quiz.html"><strong aria-hidden="true">4.10.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-ObjectsClasses.html"><strong aria-hidden="true">5.</strong> Objects and Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-ObjectsAndInstanceMethods.html"><strong aria-hidden="true">5.1.</strong> Objects and Instance Methods</a></li><li class="chapter-item expanded "><a href="ch05-02-ConstructorObjectInit.html"><strong aria-hidden="true">5.2.</strong> Constructor and Object Initialization</a></li><li class="chapter-item expanded "><a href="ch05-03-ProgrammingWithObjects.html"><strong aria-hidden="true">5.3.</strong> Programming with Objects</a></li><li class="chapter-item expanded "><a href="ch05-04-AnExample.html"><strong aria-hidden="true">5.4.</strong> An Example</a></li><li class="chapter-item expanded "><a href="ch05-05-InheritanceAndPolymorphism.html"><strong aria-hidden="true">5.5.</strong> Inheritance and Polymorphism</a></li><li class="chapter-item expanded "><a href="ch05-06-thisandsuper.html"><strong aria-hidden="true">5.6.</strong> this and super</a></li><li class="chapter-item expanded "><a href="ch05-07-Interfaces.html"><strong aria-hidden="true">5.7.</strong> Interfaces</a></li><li class="chapter-item expanded "><a href="ch05-08-NestedClasses.html"><strong aria-hidden="true">5.8.</strong> Nested Classes</a></li><li class="chapter-item expanded "><a href="ch05-09-Exercises.html"><strong aria-hidden="true">5.9.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch05-10-Quiz.html"><strong aria-hidden="true">5.10.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-GUIProgramming.html"><strong aria-hidden="true">6.</strong> Introduction to GUI Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-BasicJavaFXApp.html"><strong aria-hidden="true">6.1.</strong> A Basic JavaFX Application</a></li><li class="chapter-item expanded "><a href="ch06-02-BasicClasses.html"><strong aria-hidden="true">6.2.</strong> Basic Classes</a></li><li class="chapter-item expanded "><a href="ch06-03-BasicEvents.html"><strong aria-hidden="true">6.3.</strong> Basic Events</a></li><li class="chapter-item expanded "><a href="ch06-04-BasicControls.html"><strong aria-hidden="true">6.4.</strong> Basic Controls</a></li><li class="chapter-item expanded "><a href="ch06-05-BasicLayout.html"><strong aria-hidden="true">6.5.</strong> Basic Layout</a></li><li class="chapter-item expanded "><a href="ch06-06-CompetePrograms.html"><strong aria-hidden="true">6.6.</strong> Complete Programs</a></li><li class="chapter-item expanded "><a href="ch06-07-Exercises.html"><strong aria-hidden="true">6.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch06-08-Quiz.html"><strong aria-hidden="true">6.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-ArraysArraylistsRecords.html"><strong aria-hidden="true">7.</strong> Arrays, ArrayLists and Records</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-ArrayDetails.html"><strong aria-hidden="true">7.1.</strong> Array Details</a></li><li class="chapter-item expanded "><a href="ch07-02-ArrayProcessing.html"><strong aria-hidden="true">7.2.</strong> Array Processing</a></li><li class="chapter-item expanded "><a href="ch07-03-ArrayLists.html"><strong aria-hidden="true">7.3.</strong> ArrayLists</a></li><li class="chapter-item expanded "><a href="ch07-04-Records.html"><strong aria-hidden="true">7.4.</strong> Records</a></li><li class="chapter-item expanded "><a href="ch07-05-SearchingAndSorting.html"><strong aria-hidden="true">7.5.</strong> Searching and Sorting</a></li><li class="chapter-item expanded "><a href="ch07-06-2DArrays.html"><strong aria-hidden="true">7.6.</strong> 2D Arrays</a></li><li class="chapter-item expanded "><a href="ch07-07-Exercises.html"><strong aria-hidden="true">7.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch07-08-Quiz.html"><strong aria-hidden="true">7.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-CorrectnessRobustnessEfficiency.html"><strong aria-hidden="true">8.</strong> Correctness, Robustness, Efficiency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-IntroductionCorrectnessandRobustness.html"><strong aria-hidden="true">8.1.</strong> Introduction to Correctness and Robustness</a></li><li class="chapter-item expanded "><a href="ch08-02-WritingCorrectPrograms.html"><strong aria-hidden="true">8.2.</strong> Writing Correct Programs</a></li><li class="chapter-item expanded "><a href="ch08-03-ExceptionsAndtrycatch.html"><strong aria-hidden="true">8.3.</strong> Exceptions and try..catch</a></li><li class="chapter-item expanded "><a href="ch08-04-AssertionsAnnotations.html"><strong aria-hidden="true">8.4.</strong> Assertions and Annotations</a></li><li class="chapter-item expanded "><a href="ch08-05-AnalysisofAlgorithms.html"><strong aria-hidden="true">8.5.</strong> Analysis of Algorithms</a></li><li class="chapter-item expanded "><a href="ch08-06-Exercises.html"><strong aria-hidden="true">8.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch08-07-Quiz.html"><strong aria-hidden="true">8.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-LinkedDataStructuresRecursion.html"><strong aria-hidden="true">9.</strong> Linked Data Structures and Recursion</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-Recursion.html"><strong aria-hidden="true">9.1.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="ch09-02-LinkedDataStructures.html"><strong aria-hidden="true">9.2.</strong> Linked Data Structures</a></li><li class="chapter-item expanded "><a href="ch09-03-StacksQueuesADTs.html"><strong aria-hidden="true">9.3.</strong> Stacks, Queues and ADTs</a></li><li class="chapter-item expanded "><a href="ch09-04-BinaryTrees.html"><strong aria-hidden="true">9.4.</strong> Binary Trees</a></li><li class="chapter-item expanded "><a class="active" href="ch09-05-SimpleRecursiveDescentParser.html"><strong aria-hidden="true">9.5.</strong> A Simple Recursive Descent Parser</a></li><li class="chapter-item expanded "><a href="ch09-06-Exercises.html"><strong aria-hidden="true">9.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch09-07-Quiz.html"><strong aria-hidden="true">9.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-GenericProgrammingandCollectionClasses.html"><strong aria-hidden="true">10.</strong> Generic Programmingand Collection Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-GenericProgramming.html"><strong aria-hidden="true">10.1.</strong> Generic Programming</a></li><li class="chapter-item expanded "><a href="ch10-02-ListsandSets.html"><strong aria-hidden="true">10.2.</strong> Lists and Sets</a></li><li class="chapter-item expanded "><a href="ch10-03-Maps.html"><strong aria-hidden="true">10.3.</strong> Maps</a></li><li class="chapter-item expanded "><a href="ch10-04-JCF.html"><strong aria-hidden="true">10.4.</strong> Programming with the JCF</a></li><li class="chapter-item expanded "><a href="ch10-05-WritingGenericClassesandMethods.html"><strong aria-hidden="true">10.5.</strong> Writing Generic Classes and Methods</a></li><li class="chapter-item expanded "><a href="ch10-06-StreamAPI.html"><strong aria-hidden="true">10.6.</strong> Stream APIs</a></li><li class="chapter-item expanded "><a href="ch10-07-Exercises.html"><strong aria-hidden="true">10.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch10-08-Quiz.html"><strong aria-hidden="true">10.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-IOStreamsFilesNetworking.html"><strong aria-hidden="true">11.</strong> I/O Streams, Files, and Networking</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-IOStreamsReadersAndWriters.html"><strong aria-hidden="true">11.1.</strong> I/O Streams, Readers, and Writers</a></li><li class="chapter-item expanded "><a href="ch11-02-Files.html"><strong aria-hidden="true">11.2.</strong> Files</a></li><li class="chapter-item expanded "><a href="ch11-03-ProgrammingWithFiles.html"><strong aria-hidden="true">11.3.</strong> Programming With Files</a></li><li class="chapter-item expanded "><a href="ch11-04-Networking.html"><strong aria-hidden="true">11.4.</strong> Networking</a></li><li class="chapter-item expanded "><a href="ch11-05-XML.html"><strong aria-hidden="true">11.5.</strong> A Brief Introduction to XML</a></li><li class="chapter-item expanded "><a href="ch11-06-Exercises.html"><strong aria-hidden="true">11.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch11-07-Quiz.html"><strong aria-hidden="true">11.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-ThreadsandMultiprocessing.html"><strong aria-hidden="true">12.</strong> Threads and Multiprocessing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-IntroductiontoThreads.html"><strong aria-hidden="true">12.1.</strong> Introduction to Threads</a></li><li class="chapter-item expanded "><a href="ch12-02-ProgrammingwithThreads.html"><strong aria-hidden="true">12.2.</strong> Programming with Threads</a></li><li class="chapter-item expanded "><a href="ch12-03-ThreadsandParallelProcessing.html"><strong aria-hidden="true">12.3.</strong> Threads and Networking</a></li><li class="chapter-item expanded "><a href="ch12-04-ThreadsandNetworking.html"><strong aria-hidden="true">12.4.</strong> Threads and Networking</a></li><li class="chapter-item expanded "><a href="ch12-05-NetworkProgrammingExample.html"><strong aria-hidden="true">12.5.</strong> Network Programming Example</a></li><li class="chapter-item expanded "><a href="ch12-06-Exercises.html"><strong aria-hidden="true">12.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch12-07-Quiz.html"><strong aria-hidden="true">12.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-GUIProgrammingContinued.html"><strong aria-hidden="true">13.</strong> GUI Programming Continued</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-PropertiesandBindings.html"><strong aria-hidden="true">13.1.</strong> Properties and Bindings</a></li><li class="chapter-item expanded "><a href="ch13-02-FancierGraphics.html"><strong aria-hidden="true">13.2.</strong> Fancier Graphics</a></li><li class="chapter-item expanded "><a href="ch13-03-ComplexComponentsandMVC.html"><strong aria-hidden="true">13.3.</strong> Complex Components and MVC</a></li><li class="chapter-item expanded "><a href="ch13-04-MostlyWindowsandDialogs.html"><strong aria-hidden="true">13.4.</strong> Mostly Windows and Dialogs</a></li><li class="chapter-item expanded "><a href="ch13-05-FinishingTouches.html"><strong aria-hidden="true">13.5.</strong> Finishing Touches</a></li><li class="chapter-item expanded "><a href="ch13-06-Exercises.html"><strong aria-hidden="true">13.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch13-07-Quiz.html"><strong aria-hidden="true">13.7.</strong> Quiz</a></li></ol><li class="chapter-item expanded "><a href="appendix-00.html"> Appendix</a></li><li class="chapter-item expanded "><a href="glossary-00.html"> Glossary</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="Java">Java</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Introduction to Programming Using Java</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Xayarsh/Java-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="A Simple Recursive Descent Parser"><a class="header" href="#A Simple Recursive Descent Parser">A Simple Recursive Descent Parser</a></h2>
                        <p>
                            I have always been fascinated by language&mdash;both
                            natural languages like English and the artificial languages that are used by
                            computers. There are many difficult questions about how languages can convey
                            information, how they are structured, and how they can be processed. Natural
                            and artificial languages are similar enough that the study of programming
                            languages, which are pretty well understood, can give some insight into the
                            much more complex and difficult natural languages. And programming languages
                            raise more than enough interesting issues to make them worth studying in their
                            own right. How can it be, after all, that computers can be made to "understand"
                            even the relatively simple languages that are used to write programs?
                            Computers can only directly use instructions expressed in very
                            simple machine language. Higher level languages must be translated into machine
                            language. But the translation is done by a compiler, which is just a program.
                            How could such a translation program be written?</p>



                        <h3 id="Backus-Naur Form"><a class="header" href="#Backus-Naur Form">Backus-Naur Form</a></h3>

                        <p>Natural and artificial languages are similar in that they have a structure
                            known as grammar or syntax. Syntax can be expressed by a set of rules that
                            describe what it means to be a legal sentence or program. For programming
                            languages, syntax rules are often expressed in <span class="newword">BNF</span>
                            (Backus-Naur Form), a system that was developed by computer scientists John
                            Backus and Peter Naur in the late 1950s. Interestingly, an equivalent system
                            was developed independently at about the same time by linguist Noam Chomsky to
                            describe the grammar of natural language. BNF cannot express all possible
                            syntax rules. For example, it can't express the fact that a variable must be
                            defined before it is used. Furthermore, it says nothing about the meaning or
                            semantics of the language. The problem of specifying the semantics of a
                            language&mdash;even of an artificial programming language&mdash;is one that is still
                            far from being completely solved. However, BNF does express the basic structure
                            of the language, and it plays a central role in the design of compilers.</p>


                        <p>A variety of different notations are used for BNF.  The one that I will use here is
                            fairly common.  Although other notations are used, they express the same concepts.</p>


                        <p>In English, terms such as "noun", "transitive verb," and "prepositional
                            phrase" are <span class="newword">syntactic categories</span> that describe
                            building blocks of sentences. Similarly, "statement", "number," and "while
                            loop" are syntactic categories that describe building blocks of Java programs.
                            In BNF, a syntactic category is written as a word enclosed between
                            "<span class="code">&lt;</span>" and&nbsp;"<span class="code">&gt;</span>". For example: <span class="code">&lt;noun&gt;</span>,
                            <span class="code">&lt;verb-phrase&gt;</span>, or <span class="code">&lt;while-loop&gt;</span>. A
                            <span class="newword">rule</span> in BNF specifies the structure of an item in a given
                            syntactic category, in terms of other syntactic categories and/or basic symbols
                            of the language. For example, one BNF rule for the English language might
                            be</p>


                        <pre><code class="java">&lt;sentence&gt;  ::=  &lt;noun-phrase&gt; &lt;verb-phrase&gt;</code></pre>


                        <p>The symbol "<span class="code">::=</span>" is read "can be", so this rule says that a
                            <span class="code">&lt;sentence&gt;</span> can be a <span class="code">&lt;noun-phrase&gt;</span> followed by a
                            <span class="code">&lt;verb-phrase&gt;</span>. (The term is "can be" rather than "is" because
                            there might be other rules that specify other possible forms for a sentence.)
                            This rule can be thought of as a recipe for a sentence: If you want to make a
                            sentence, make a noun-phrase and follow it by a verb-phrase. Noun-phrase and
                            verb-phrase must, in turn, be defined by other BNF rules.</p>


                        <p>In BNF, a choice between alternatives is represented by the symbol "<span class="code">|</span>",
                            which is read "or". For example, the rule</p>


                        <pre><code class="java">&lt;verb-phrase&gt;  ::=  &lt;intransitive-verb&gt;  |
                    ( &lt;transitive-verb&gt; &lt;noun-phrase&gt; )</code></pre>


                        <p>says that a <span class="code">&lt;verb-phrase&gt;</span> can be an
                            <span class="code">&lt;intransitive-verb&gt;</span>, or a
                            <span class="code">&lt;transitive-verb&gt;</span> followed by a <span class="code">&lt;noun-phrase&gt;</span>.
                            Note also that parentheses can be used for grouping. To express the fact that
                            an item is optional, it can be enclosed between "<span class="code">[</span>" and "<span class="code">]</span>".
                            An optional item that can be repeated any number of times is enclosed between
                            "<span class="code">[</span>" and "<span class="code">]...</span>". And a symbol that is an actual part of the
                            language that is being described is enclosed in quotes. For example,</p>


                        <pre><code class="java">&lt;noun-phrase&gt;  ::=  &lt;common-noun&gt; [ "that" &lt;verb-phrase&gt; ]  |
                    &lt;common-noun&gt; [ &lt;prepositional-phrase&gt; ]...</code></pre>


                        <p>says that a <span class="code">&lt;noun-phrase&gt;</span> can be a
                            <span class="code">&lt;common-noun&gt;</span>, optionally followed by the literal word
                            "<span class="code">that</span>" and a <span class="code">&lt;verb-phrase&gt;</span>, or it can be a
                            <span class="code">&lt;common-noun&gt;</span> followed by zero or more
                            <span class="code">&lt;prepositional-phrase&gt;'s</span>. Obviously, we can describe very
                            complex structures in this way. The real power comes from the fact that BNF
                            rules can be <b>recursive</b>. In fact, the two preceding rules, taken together, are
                            recursive. A <span class="code">&lt;noun-phrase&gt;</span> is defined partly in terms of
                            <span class="code">&lt;verb-phrase&gt;</span>, while <span class="code">&lt;verb-phrase&gt;</span> is defined
                            partly in terms of <span class="code">&lt;noun-phrase&gt;</span>. For example, a
                            <span class="code">&lt;noun-phrase&gt;</span> might be "the rat that ate the cheese", since "ate
                            the cheese" is a <span class="code">&lt;verb-phrase&gt;</span>. But then we can, recursively,
                            make the more complex <span class="code">&lt;noun-phrase&gt;</span> "the cat that caught the rat
                            that ate the cheese" out of the <span class="code">&lt;common-noun&gt;</span> "the cat", the word "that"
                            and the <span class="code">&lt;verb-phrase&gt;</span> "caught the rat that ate the cheese".
                            Building from there, we can make the <span class="code">&lt;noun-phrase&gt;</span> "the dog that
                            chased the cat that caught the rat that ate the cheese". The recursive
                            structure of language is one of the most fundamental properties of language,
                            and the ability of BNF to express this recursive structure is what makes it so
                            useful.</p>


                        <p>BNF can be used to describe the syntax of a programming language such as
                            Java in a formal and precise way. For example, a <span class="code">&lt;while-loop&gt;</span>
                            can be defined as</p>


                        <pre><code class="java">&lt;while-loop&gt;  ::=  "while" "(" &lt;condition&gt; ")" &lt;statement&gt;</code></pre>


                        <p>This says that a <span class="code">&lt;while-loop&gt;</span> consists of the word "while",
                            followed by a left parenthesis, followed by a <span class="code">&lt;condition&gt;</span>,
                            followed by a right parenthesis, followed by a <span class="code">&lt;statement&gt;</span>. Of
                            course, it still remains to define what is meant by a condition and by a
                            statement. Since a statement can be, among other things, a <span class="code">while</span> loop,
                            we can already see the recursive structure of the Java language. The exact
                            specification of an <span class="code">if</span> statement, which is hard to express clearly in
                            words, can be given as</p>


                        <pre><code class="java">&lt;if-statement&gt;  ::=
             "if" "(" &lt;condition&gt; ")" &lt;statement&gt;
             [ "else" "if" "(" &lt;condition&gt; ")" &lt;statement&gt; ]...
             [ "else" &lt;statement&gt; ]</code></pre>


                        <p>This rule makes it clear that the "<span class="code">else</span>" part is optional and that
                            there can be, optionally, one or more "<span class="code">else if</span>" parts.</p>
                        

                        <h3 id="Recursive Descent Parsing"><a class="header" href="#Recursive Descent Parsing">Recursive Descent Parsing</a></h3>

                        <p>In the rest of this section, I will show how a BNF grammar for a language
                            can be used as a guide for constructing a parser. A parser is a program that
                            determines the grammatical structure of a phrase in the language. This is the
                            first step in determining the meaning of the phrase&mdash;which for a programming
                            language means translating it into machine language. Although we will look at
                            only a simple example, I hope it will be enough to convince you that compilers
                            can in fact be written and understood by mortals and to give you some idea of
                            how that can be done.</p>


                        <p>The parsing method that we will use is called <span class="newword">recursive descent parsing</span>.
                            It is not the only possible parsing
                            method, or the most efficient, but it is the one most suited for writing
                            compilers by hand (rather than with the help of so called "parser generator"
                            programs). In a recursive descent parser, every rule of the BNF grammar is the
                            model for a subroutine. Not every BNF grammar is suitable for recursive descent
                            parsing. The grammar must satisfy a certain property. Essentially, while
                            parsing a phrase, it must be possible to tell what syntactic category is coming
                            up next just by looking at the next item in the input. Many grammars are
                            designed with this property in mind.</p>

                        
                        <p>When we try to parse a phrase that contains a syntax error, we need some way
                            to respond to the error. A convenient way of doing this is to throw an
                            exception. I'll use an exception class called <span class="classname">ParseError</span>, defined as
                            follows:</p>


                        <pre><code class="java">/**
 * An object of type ParseError represents a syntax error found in
 * the user's input.
 */
private static class ParseError extends Exception {
   ParseError(String message) {
      super(message);
   }
} // end nested class ParseError</code></pre>


                        <p>Another general point is that our BNF rules don't say anything about spaces
                            between items, but in reality we want to be able to insert spaces between items
                            at will. To allow for this, I'll always call the routine <span class="code">TextIO.skipBlanks()</span>
                            before trying to look ahead to see what's coming up next in input.
                            <span class="code">TextIO.skipBlanks()</span> skips past any whitespace, such as spaces and tabs, in the input,
                            and stops when the next character in the input is either a non-blank character or the
                            end-of-line character.  (For a discussion of robust handling of <span class="classname">TextIO</span> input, see
                            <a href="ch08-02-WritingCorrectPrograms.html">Subsection&nbsp;8.2.4</a>.)</p>


                        <p>Let's start with a very simple example. A "fully parenthesized expression"
                            can be specified in BNF by the rules</p>


                        <pre><code class="java">&lt;expression&gt;  ::=  &lt;number&gt;  |
                   "(" &lt;expression&gt; &lt;operator&gt; &lt;expression&gt; ")"

&lt;operator&gt;  ::=  "+" | "-" | "*" | "/"</code></pre>


                        <p>where <span class="code">&lt;number&gt;</span> refers to any non-negative real number. An example
                            of a fully parenthesized expression is "<span class="code">(((34-17)*8)+(2*7))</span>". Since
                            every operator corresponds to a pair of parentheses, there is no ambiguity
                            about the order in which the operators are to be applied. Suppose we want a
                            program that will read and evaluate such expressions. We'll read the
                            expressions from standard input, using <span class="classname">TextIO</span>. To apply recursive
                            descent parsing, we need a subroutine for each rule in the grammar.
                            Corresponding to the rule for <span class="code">&lt;operator&gt;</span>, we get a subroutine
                            that reads an operator. The operator can be a choice of any of four things. Any
                            other input will be an error.</p>


                        <pre><code class="java">/**
 * If the next character in input is one of the legal operators,
 * read it and return it.  Otherwise, throw a ParseError.
 */
static char getOperator() throws ParseError {
   TextIO.skipBlanks();
   char op = TextIO.peek(); // look ahead at the next char, without reading it
   if ( op == '+' || op == '-' || op == '*' || op == '/' ) {
      TextIO.getAnyChar();  // read the operator, to remove it from the input
      return op;
   }
   else if (op == '\n')
      throw new ParseError("Missing operator at end of line.");
   else
      throw new ParseError("Missing operator.  Found \"" +
            op + "\" instead of +, -, *, or /.");
} // end getOperator()</code></pre>


                        <p>I've tried to give a reasonable error message, depending on whether the next
                            character is an end-of-line or something else. I use <span class="code">TextIO.peek()</span> to
                            look ahead at the next character before I read it, and I call
                            <span class="code">TextIO.skipBlanks()</span> before testing <span class="code">TextIO.peek()</span> in order to ignore
                            any blanks that separate items. I will follow this same pattern in every
                            case.</p>


                        <p>When we come to the subroutine for <span class="code">&lt;expression&gt;</span>, things are a
                            little more interesting. The rule says that an expression can be either a
                            number or an expression enclosed in parentheses. We can tell which it is by
                            looking ahead at the next character. If the character is a digit, we have to
                            read a number. If the character is a "(", we have to read the "(", followed by
                            an expression, followed by an operator, followed by another expression,
                            followed by a ")". If the next character is anything else, there is an error.
                            Note that we need recursion to read the nested expressions. The routine doesn't
                            just read the expression. It also computes and returns its value. This requires
                            semantical information that is not specified in the BNF rule.</p>


                        <pre><code class="java">/**
 * Read an expression from the current line of input and return its value.
 * @throws ParseError if the input contains a syntax error
 */
private static double expressionValue() throws ParseError {
   TextIO.skipBlanks();
   if ( Character.isDigit(TextIO.peek()) ) {
          // The next item in input is a number, so the expression
          // must consist of just that number.  Read and return
          // the number.
      return TextIO.getDouble();
   }
   else if ( TextIO.peek() == '(' ) {
          // The expression must be of the form
          //         "(" &lt;expression&gt; &lt;operator&gt; &lt;expression&gt; ")"
          // Read all these items, perform the operation, and
          // return the result.
      TextIO.getAnyChar();  // Read the "("
      double leftVal = expressionValue();  // Read and evaluate first operand.
      char op = getOperator();             // Read the operator.
      double rightVal = expressionValue(); // Read and evaluate second operand.
      TextIO.skipBlanks();
      if ( TextIO.peek() != ')' ) {
             // According to the rule, there must be a ")" here.
             // Since it's missing, throw a ParseError.
         throw new ParseError("Missing right parenthesis.");
      }
      TextIO.getAnyChar();  // Read the ")"
      switch (op) {   //  Apply the operator and return the result.
         case '+':  return leftVal + rightVal;
         case '-':  return leftVal - rightVal;
         case '*':  return leftVal * rightVal;
         case '/':  return leftVal / rightVal;
         default:   return 0;  // Can't occur since op is one of the above.
                               // (But Java syntax requires a return value.)
      }
   }
   else {  // No other character can legally start an expression.
      throw new ParseError("Encountered unexpected character, \"" +
            TextIO.peek() + "\" in input.");
   }
} // end expressionValue()</code></pre>


                        <p>I hope that you can see how this routine corresponds to the BNF rule. Where
                            the rule uses "<span class="code">|</span>" to give a choice between alternatives, there is an
                            <span class="code">if</span> statement in the routine to determine which choice to take. Where
                            the rule contains a sequence of items, "(" <span class="code">&lt;expression&gt;</span>
                            <span class="code">&lt;operator&gt;</span> <span class="code">&lt;expression&gt;</span> ")", there is a sequence
                            of statements in the subroutine to read each item in turn.</p>


                        <p>When <span class="code">expressionValue()</span> is called to evaluate the expression
                            <span class="code">(((34-17)*8)+(2*7))</span>, it sees the "(" at the beginning of the input, so
                            the <span class="code">else</span> part of the <span class="code">if</span> statement is executed. The "(" is
                            read. Then the first recursive call to <span class="code">expressionValue()</span> reads and
                            evaluates the subexpression <span class="code">((34-17)*8)</span>, the call to
                            <span class="code">getOperator()</span> reads the "+" operator, and the second recursive call to
                            <span class="code">expressionValue()</span> reads and evaluates the second subexpression
                            <span class="code">(2*7)</span>. Finally, the ")" at the end of the expression is read. Of
                            course, reading the first subexpression, <span class="code">((34-17)*8)</span>, involves further
                            recursive calls to the <span class="code">expressionValue()</span> routine, but it's better not
                            to think too deeply about that! Rely on the recursion to handle the
                            details.</p>


                        <p>You'll find a complete program that uses these routines in the file
                            <span class="sourceref"><a href="./source/chapter9/SimpleParser1.java">SimpleParser1.java</a></span>.</p>





                        <p>Fully parenthesized expressions aren't very natural for people to use. But
                            with ordinary expressions, we have to worry about the question of operator
                            precedence, which tells us, for example, that the "<span class="code">*</span>" in the
                            expression "<span class="code">5+3*7</span>" is applied before the "<span class="code">+</span>". The complex expression
                            "<span class="code">3*6+8*(7+1)/4-24</span>" should be seen as made up of three "terms",
                            <span class="code">3*6</span>, <span class="code">8*(7+1)/4</span>, and <span class="code">24</span>, combined with "<span class="code">+</span>" and "<span class="code">-</span>"
                            operators. A term, on the other hand, can be made up of several factors
                            combined with "<span class="code">*</span>" and "<span class="code">/</span>" operators. For example,
                            <span class="code">8*(7+1)/4</span> contains the factors <span class="code">8</span>, <span class="code">(7+1)</span> and
                            <span class="code">4</span>. This example also shows that a factor can be either a number or an
                            expression in parentheses. To complicate things a bit more, we allow for
                            leading minus signs in expressions, as in "<span class="code">-(3+4)</span>" or "<span class="code">-7</span>".
                            (Since a <span class="code">&lt;number&gt;</span> is a positive number, this is the only way we
                            can get negative numbers. It's done this way to avoid "<span class="code">3&nbsp;*&nbsp;-7</span>", for
                            example.) This structure can be expressed by the BNF rules</p>


                        <pre><code class="java">&lt;expression&gt;  ::=  [ "-" ] &lt;term&gt; [ ( "+" | "-" ) &lt;term&gt; ]...
&lt;term&gt;  ::=  &lt;factor&gt; [ ( "*" | "/" ) &lt;factor&gt; ]...
&lt;factor&gt;  ::=  &lt;number&gt;  |  "(" &lt;expression&gt; ")"</code></pre>


                        <p>The first rule uses the "<span class="code">[&nbsp;]...</span>" notation, which says that the
                            items that it encloses can occur zero, one, two, or more times. The rule means that
                            an <span class="code">&lt;expression&gt;</span> can begin, optionally, with a "-". Then there
                            must be a <span class="code">&lt;term&gt;</span> which can optionally be followed by one of the
                            operators "<span class="code">+</span>" or "<span class="code">-</span>" and another <span class="code">&lt;term&gt;</span>, optionally followed by
                            another operator and <span class="code">&lt;term&gt;</span>, and so on. In a subroutine that
                            reads and evaluates expressions, this repetition is handled by a <span class="code">while</span>
                            loop. An <span class="code">if</span> statement is used at the beginning of the loop to test
                            whether a leading minus sign is present:</p>


                        <pre><code class="java">/**
 * Read an expression from the current line of input and return its value.
 * @throws ParseError if the input contains a syntax error
 */
private static double expressionValue() throws ParseError {
   TextIO.skipBlanks();
   boolean negative;  // True if there is a leading minus sign.
   negative = false;
   if (TextIO.peek() == '-') {
      TextIO.getAnyChar();  // Read the minus sign.
      negative = true;
   }
   double val;  // Value of the expression.
   val = termValue();  // Read and evaluate the first term.
   if (negative)
      val = -val;  // Apply the leading minus sign to the first term.
   TextIO.skipBlanks();
   while ( TextIO.peek() == '+' || TextIO.peek() == '-' ) {
          // Read the next term and add it to or subtract it from
          // the value of previous terms in the expression.
      char op = TextIO.getAnyChar();  // Read the operator.
      double nextVal = termValue();    // Read and evaluate the next term.
      if (op == '+')
         val += nextVal;
      else
         val -= nextVal;
      TextIO.skipBlanks();
   }
   return val;
} // end expressionValue()</code></pre>


                        <p>The subroutine for <span class="code">&lt;term&gt;</span> is very similar to this, and the
                            subroutine for <span class="code">&lt;factor&gt;</span> is similar to the example given above
                            for fully parenthesized expressions. A complete program that reads and
                            evaluates expressions based on the above BNF rules can be found in the file
                            <span class="sourceref"><a href="./source/chapter9/SimpleParser2.java">SimpleParser2.java</a></span>.</p>

                        
                        <h3 id="Building an Expression Tree"><a class="header" href="#Building an Expression Tree">Building an Expression Tree</a></h3>
                        

                        <p>Now, so far, we've only evaluated expressions. What does that have to do
                            with translating programs into machine language? Well, instead of actually
                            evaluating the expression, it would be almost as easy to generate the machine
                            language instructions that are needed to evaluate the expression. If we are
                            working with a "stack machine," these instructions would be stack operations
                            such as "push a number" or "apply a <span class="code">+</span> operation". The program
                            <span class="sourceref"><a href="./source/chapter9/SimpleParser3.java">SimpleParser3.java</a></span> can both evaluate the
                            expression and print a list of stack machine operations for evaluating the
                            expression.</p>



                        <p>It's quite a jump from this program to a recursive descent parser that can
                            read a program written in Java and generate the equivalent machine language
                            code&mdash;but the conceptual leap is not huge.</p>


                        <p>The <span class="code">SimpleParser3</span> program doesn't actually generate the stack
                            operations directly as it parses an expression. Instead, it builds an
                            expression tree, as discussed in <a href="ch09-04-BinaryTrees.html">Subsection&nbsp;9.4.3</a>, to
                            represent the expression. The expression tree is then used to find the value
                            and to generate the stack operations. The tree is made up of nodes belonging to
                            classes <span class="classname">ConstNode</span> and <span class="classname">BinOpNode</span> that are similar to those
                            given in <a href="ch09-04-BinaryTrees.html">Subsection&nbsp;9.4.3</a>. Another subclass of <span class="classname">ExpNote</span>,
                            <span class="classname">UnaryMinusNode</span>, has been
                            introduced to represent the unary minus operation. I've added a method,
                            <span class="code">printStackCommands()</span>, to each class. This method is responsible for
                            printing out the stack operations that are necessary to evaluate an expression.
                            Here for example is the new <span class="code">BinOpNode</span> class from <span class="sourceref"><a href="./source/chapter9/SimpleParser3.java">SimpleParser3.java</a></span>:</p>


                        <pre><code class="java">private static class BinOpNode extends ExpNode {
   char op;        // The operator.
   ExpNode left;   // The expression for its left operand.
   ExpNode right;  // The expression for its right operand.
   BinOpNode(char op, ExpNode left, ExpNode right) {
          // Construct a BinOpNode containing the specified data.
      assert op == '+' || op == '-' || op == '*' || op == '/';
      assert left != null &amp;&amp; right != null;
           // (for assert statements, see <a href="ch08-04-AssertionsAnnotations.html">Subsection&nbsp;8.4.1</a>)
      this.op = op;
      this.left = left;
      this.right = right;
   }
   double value() {
          // The value is obtained by evaluating the left and right
          // operands and combining the values with the operator.
      double x = left.value();
      double y = right.value();
      switch (op) {
      case '+':
         return x + y;
      case '-':
         return x - y;
      case '*':
         return x * y;
      case '/':
         return x / y;
      default:
         return Double.NaN;  // Bad operator! Should not be possible.
      }
   }
   void  printStackCommands() {
          // To evaluate the expression on a stack machine, first do
          // whatever is necessary to evaluate the left operand, leaving
          // the answer on the stack.  Then do the same thing for the
          // second operand.  Then apply the operator (which means popping
          // the operands, applying the operator, and pushing the result).
      left.printStackCommands();
      right.printStackCommands();
      System.out.println("  Operator " + op);
   }
}</code></pre>


                        <p>It's also interesting to look at the new parsing subroutines. Instead of
                            computing a value, each subroutine builds an expression tree. For example, the
                            subroutine corresponding to the rule for <span class="code">&lt;expression&gt;</span>
                            becomes</p>


                        <pre><code class="java">
    static ExpNode expressionTree() throws ParseError {
           // Read an expression from the current line of input and
           // return an expression tree representing the expression.
           // (The return value is a pointer to the root of the tree.)
       TextIO.skipBlanks();
       boolean negative;  // True if there is a leading minus sign.
       negative = false;
       if (TextIO.peek() == '-') {
          TextIO.getAnyChar();
          negative = true;
       }
       ExpNode exp;   // The expression tree for the expression.
       exp = termTree();  // Start with a tree for first term.
       if (negative) {
              // Build the tree that corresponds to applying a
              // unary minus operator to the term we've
              // just read.
          exp = new UnaryMinusNode(exp);
       }
       TextIO.skipBlanks();
       while ( TextIO.peek() == '+' || TextIO.peek() == '-' ) {
                // Read the next term and combine it with the
                // previous terms into a bigger expression tree.
           char op = TextIO.getAnyChar();
           ExpNode nextTerm = termTree();
                // Create a tree that applies the binary operator
                // to the previous tree and the term we just read.
           exp = new BinOpNode(op, exp, nextTerm);
           TextIO.skipBlanks();
       }
       return exp;
    } // end expressionTree()

</code></pre>


                        <p>In some real compilers, the parser creates a tree to represent the program
                            that is being parsed. This tree is called a <span class="newword">parse tree</span>
                            or <span class="newword">abstract syntax tree</span>.
                            Parse trees are somewhat different in form from expression trees,
                            but the purpose is the same. Once you have the tree, there are a number of
                            things you can do with it. For one thing, it can be used to generate machine
                            language code. But there are also techniques for examining the tree and
                            detecting certain types of programming errors, such as an attempt to reference
                            a local variable before it has been assigned a value. (The Java compiler, of
                            course, will reject the program if it contains such an error.) It's also
                            possible to manipulate the tree to <span class="newword">optimize</span> the
                            program. In optimization, the tree is transformed to make the program more
                            efficient before the code is generated.</p>


                        <p>And so we are back where we started in <a href="ch01-00-Overview.html">Chapter&nbsp;1</a>, looking at programming
                            languages, compilers, and machine language. But looking at them, I hope, with a
                            lot more understanding and a much wider perspective.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch09-04-BinaryTrees.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch09-06-Exercises.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch09-04-BinaryTrees.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch09-06-Exercises.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </body>
</html>
