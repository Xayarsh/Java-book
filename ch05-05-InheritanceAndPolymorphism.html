<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Inheritance and Polymorphism - Introduction to Programming Using Java</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

<link rel="stylesheet" href="code-class.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html" >Introduction to Programming Using Java</a></li><li class="chapter-item expanded affix "><a href="preface.html">Preface</a></li><li class="chapter-item expanded "><a href="ch01-00-Overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-FetchExecuteCycle.html"><strong aria-hidden="true">1.1.</strong> Fetch and Execute Cycle</a></li><li class="chapter-item expanded "><a href="ch01-02-AsynchronousEvents.html"><strong aria-hidden="true">1.2.</strong> Asynchronous Events</a></li><li class="chapter-item expanded "><a href="ch01-03-JavaVirtualMachine.html"><strong aria-hidden="true">1.3.</strong> The Java Virtual Machine</a></li><li class="chapter-item expanded "><a href="ch01-04-FundamentalBuildingBlocks.html"><strong aria-hidden="true">1.4.</strong> Fundamentals</a></li><li class="chapter-item expanded "><a href="ch01-05-OOP.html"><strong aria-hidden="true">1.5.</strong> Object Oriented Programming</a></li><li class="chapter-item expanded "><a href="ch01-06-ModernUserInterface.html"><strong aria-hidden="true">1.6.</strong> Modern User Interface</a></li><li class="chapter-item expanded "><a href="ch01-07-InternetAndBeyond.html"><strong aria-hidden="true">1.7.</strong> Internet and Beyond</a></li><li class="chapter-item expanded "><a href="ch01-08-Quiz.html"><strong aria-hidden="true">1.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-NameAndThings.html"><strong aria-hidden="true">2.</strong> Name and Things</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-BasicJavaApplication.html"><strong aria-hidden="true">2.1.</strong> Basic Java Application</a></li><li class="chapter-item expanded "><a href="ch02-02-VariablesAndTypes.html"><strong aria-hidden="true">2.2.</strong> Variables and Types</a></li><li class="chapter-item expanded "><a href="ch02-03-ObjectsAndSubroutines.html"><strong aria-hidden="true">2.3.</strong> Objects and Subroutines</a></li><li class="chapter-item expanded "><a href="ch02-04-TextInputAndOutput.html"><strong aria-hidden="true">2.4.</strong> Text Input and Output</a></li><li class="chapter-item expanded "><a href="ch02-05-DetailsOfExpressions.html"><strong aria-hidden="true">2.5.</strong> Details of Expressions</a></li><li class="chapter-item expanded "><a href="ch02-06-ProgrammingEnvironments.html"><strong aria-hidden="true">2.6.</strong> Programming and Environments</a></li><li class="chapter-item expanded "><a href="ch02-07-Exercises.html"><strong aria-hidden="true">2.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch02-08-Quiz.html"><strong aria-hidden="true">2.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-Control.html"><strong aria-hidden="true">3.</strong> Control</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-BlocksLoopsBranches.html"><strong aria-hidden="true">3.1.</strong> Blocks, Loops and Branches</a></li><li class="chapter-item expanded "><a href="ch03-02-AlgorithmDevelopment.html"><strong aria-hidden="true">3.2.</strong> Algorithm Development</a></li><li class="chapter-item expanded "><a href="ch03-03-While.html"><strong aria-hidden="true">3.3.</strong> while and do...while</a></li><li class="chapter-item expanded "><a href="ch03-04-For.html"><strong aria-hidden="true">3.4.</strong> The for statement</a></li><li class="chapter-item expanded "><a href="ch03-05-If.html"><strong aria-hidden="true">3.5.</strong> The If Statement</a></li><li class="chapter-item expanded "><a href="ch03-06-Switch.html"><strong aria-hidden="true">3.6.</strong> The Switch Statement</a></li><li class="chapter-item expanded "><a href="ch03-07-ExceptionsTryCatch.html"><strong aria-hidden="true">3.7.</strong> Exceptions and try...catch</a></li><li class="chapter-item expanded "><a href="ch03-08-Arrays.html"><strong aria-hidden="true">3.8.</strong> Arrays: An Introduction</a></li><li class="chapter-item expanded "><a href="ch03-09-GUI.html"><strong aria-hidden="true">3.9.</strong> GUI: An Introduction</a></li><li class="chapter-item expanded "><a href="ch03-10-Exercises.html"><strong aria-hidden="true">3.10.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch03-11-Quiz.html"><strong aria-hidden="true">3.11.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-Subroutines.html"><strong aria-hidden="true">4.</strong> Subroutines</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-BlackBoxes.html"><strong aria-hidden="true">4.1.</strong> Black Boxes</a></li><li class="chapter-item expanded "><a href="ch04-02-StaticSubroutines.html"><strong aria-hidden="true">4.2.</strong> Static Subroutines and Variables</a></li><li class="chapter-item expanded "><a href="ch04-03-Parameters.html"><strong aria-hidden="true">4.3.</strong> Parameters</a></li><li class="chapter-item expanded "><a href="ch04-04-ReturnValues.html"><strong aria-hidden="true">4.4.</strong> Return Values</a></li><li class="chapter-item expanded "><a href="ch04-05-Lambda.html"><strong aria-hidden="true">4.5.</strong> Lambda Expressions</a></li><li class="chapter-item expanded "><a href="ch04-06-APIPackagesModulesJavadoc.html"><strong aria-hidden="true">4.6.</strong> API, Packages, Modules and Javadoc</a></li><li class="chapter-item expanded "><a href="ch04-07-MoreOnProgramDesign.html"><strong aria-hidden="true">4.7.</strong> More on Program Design</a></li><li class="chapter-item expanded "><a href="ch04-08-TruthAboutDeclarations.html"><strong aria-hidden="true">4.8.</strong> Truth about Declarations</a></li><li class="chapter-item expanded "><a href="ch04-09-Exercises.html"><strong aria-hidden="true">4.9.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch04-10-Quiz.html"><strong aria-hidden="true">4.10.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-ObjectsClasses.html"><strong aria-hidden="true">5.</strong> Objects and Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-ObjectsAndInstanceMethods.html"><strong aria-hidden="true">5.1.</strong> Objects and Instance Methods</a></li><li class="chapter-item expanded "><a href="ch05-02-ConstructorObjectInit.html"><strong aria-hidden="true">5.2.</strong> Constructor and Object Initialization</a></li><li class="chapter-item expanded "><a href="ch05-03-ProgrammingWithObjects.html"><strong aria-hidden="true">5.3.</strong> Programming with Objects</a></li><li class="chapter-item expanded "><a href="ch05-04-AnExample.html"><strong aria-hidden="true">5.4.</strong> An Example</a></li><li class="chapter-item expanded "><a class="active" href="ch05-05-InheritanceAndPolymorphism.html"><strong aria-hidden="true">5.5.</strong> Inheritance and Polymorphism</a></li><li class="chapter-item expanded "><a href="ch05-06-thisandsuper.html"><strong aria-hidden="true">5.6.</strong> this and super</a></li><li class="chapter-item expanded "><a href="ch05-07-Interfaces.html"><strong aria-hidden="true">5.7.</strong> Interfaces</a></li><li class="chapter-item expanded "><a href="ch05-08-NestedClasses.html"><strong aria-hidden="true">5.8.</strong> Nested Classes</a></li><li class="chapter-item expanded "><a href="ch05-09-Exercises.html"><strong aria-hidden="true">5.9.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch05-10-Quiz.html"><strong aria-hidden="true">5.10.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-GUIProgramming.html"><strong aria-hidden="true">6.</strong> Introduction to GUI Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-BasicJavaFXApp.html"><strong aria-hidden="true">6.1.</strong> A Basic JavaFX Application</a></li><li class="chapter-item expanded "><a href="ch06-02-BasicClasses.html"><strong aria-hidden="true">6.2.</strong> Basic Classes</a></li><li class="chapter-item expanded "><a href="ch06-03-BasicEvents.html"><strong aria-hidden="true">6.3.</strong> Basic Events</a></li><li class="chapter-item expanded "><a href="ch06-04-BasicControls.html"><strong aria-hidden="true">6.4.</strong> Basic Controls</a></li><li class="chapter-item expanded "><a href="ch06-05-BasicLayout.html"><strong aria-hidden="true">6.5.</strong> Basic Layout</a></li><li class="chapter-item expanded "><a href="ch06-06-CompetePrograms.html"><strong aria-hidden="true">6.6.</strong> Complete Programs</a></li><li class="chapter-item expanded "><a href="ch06-07-Exercises.html"><strong aria-hidden="true">6.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch06-08-Quiz.html"><strong aria-hidden="true">6.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-ArraysArraylistsRecords.html"><strong aria-hidden="true">7.</strong> Arrays, ArrayLists and Records</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-ArrayDetails.html"><strong aria-hidden="true">7.1.</strong> Array Details</a></li><li class="chapter-item expanded "><a href="ch07-02-ArrayProcessing.html"><strong aria-hidden="true">7.2.</strong> Array Processing</a></li><li class="chapter-item expanded "><a href="ch07-03-ArrayLists.html"><strong aria-hidden="true">7.3.</strong> ArrayLists</a></li><li class="chapter-item expanded "><a href="ch07-04-Records.html"><strong aria-hidden="true">7.4.</strong> Records</a></li><li class="chapter-item expanded "><a href="ch07-05-SearchingAndSorting.html"><strong aria-hidden="true">7.5.</strong> Searching and Sorting</a></li><li class="chapter-item expanded "><a href="ch07-06-2DArrays.html"><strong aria-hidden="true">7.6.</strong> 2D Arrays</a></li><li class="chapter-item expanded "><a href="ch07-07-Exercises.html"><strong aria-hidden="true">7.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch07-08-Quiz.html"><strong aria-hidden="true">7.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-CorrectnessRobustnessEfficiency.html"><strong aria-hidden="true">8.</strong> Correctness, Robustness, Efficiency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-IntroductionCorrectnessandRobustness.html"><strong aria-hidden="true">8.1.</strong> Introduction to Correctness and Robustness</a></li><li class="chapter-item expanded "><a href="ch08-02-WritingCorrectPrograms.html"><strong aria-hidden="true">8.2.</strong> Writing Correct Programs</a></li><li class="chapter-item expanded "><a href="ch08-03-ExceptionsAndtrycatch.html"><strong aria-hidden="true">8.3.</strong> Exceptions and try..catch</a></li><li class="chapter-item expanded "><a href="ch08-04-AssertionsAnnotations.html"><strong aria-hidden="true">8.4.</strong> Assertions and Annotations</a></li><li class="chapter-item expanded "><a href="ch08-05-AnalysisofAlgorithms.html"><strong aria-hidden="true">8.5.</strong> Analysis of Algorithms</a></li><li class="chapter-item expanded "><a href="ch08-06-Exercises.html"><strong aria-hidden="true">8.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch08-07-Quiz.html"><strong aria-hidden="true">8.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-LinkedDataStructuresRecursion.html"><strong aria-hidden="true">9.</strong> Linked Data Structures and Recursion</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-Recursion.html"><strong aria-hidden="true">9.1.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="ch09-02-LinkedDataStructures.html"><strong aria-hidden="true">9.2.</strong> Linked Data Structures</a></li><li class="chapter-item expanded "><a href="ch09-03-StacksQueuesADTs.html"><strong aria-hidden="true">9.3.</strong> Stacks, Queues and ADTs</a></li><li class="chapter-item expanded "><a href="ch09-04-BinaryTrees.html"><strong aria-hidden="true">9.4.</strong> Binary Trees</a></li><li class="chapter-item expanded "><a href="ch09-05-SimpleRecursiveDescentParser.html"><strong aria-hidden="true">9.5.</strong> A Simple Recursive Descent Parser</a></li><li class="chapter-item expanded "><a href="ch09-06-Exercises.html"><strong aria-hidden="true">9.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch09-07-Quiz.html"><strong aria-hidden="true">9.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-GenericProgrammingandCollectionClasses.html"><strong aria-hidden="true">10.</strong> Generic Programmingand Collection Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-GenericProgramming.html"><strong aria-hidden="true">10.1.</strong> Generic Programming</a></li><li class="chapter-item expanded "><a href="ch10-02-ListsandSets.html"><strong aria-hidden="true">10.2.</strong> Lists and Sets</a></li><li class="chapter-item expanded "><a href="ch10-03-Maps.html"><strong aria-hidden="true">10.3.</strong> Maps</a></li><li class="chapter-item expanded "><a href="ch10-04-JCF.html"><strong aria-hidden="true">10.4.</strong> Programming with the JCF</a></li><li class="chapter-item expanded "><a href="ch10-05-WritingGenericClassesandMethods.html"><strong aria-hidden="true">10.5.</strong> Writing Generic Classes and Methods</a></li><li class="chapter-item expanded "><a href="ch10-06-StreamAPI.html"><strong aria-hidden="true">10.6.</strong> Stream APIs</a></li><li class="chapter-item expanded "><a href="ch10-07-Exercises.html"><strong aria-hidden="true">10.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch10-08-Quiz.html"><strong aria-hidden="true">10.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-IOStreamsFilesNetworking.html"><strong aria-hidden="true">11.</strong> I/O Streams, Files, and Networking</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-IOStreamsReadersAndWriters.html"><strong aria-hidden="true">11.1.</strong> I/O Streams, Readers, and Writers</a></li><li class="chapter-item expanded "><a href="ch11-02-Files.html"><strong aria-hidden="true">11.2.</strong> Files</a></li><li class="chapter-item expanded "><a href="ch11-03-ProgrammingWithFiles.html"><strong aria-hidden="true">11.3.</strong> Programming With Files</a></li><li class="chapter-item expanded "><a href="ch11-04-Networking.html"><strong aria-hidden="true">11.4.</strong> Networking</a></li><li class="chapter-item expanded "><a href="ch11-05-XML.html"><strong aria-hidden="true">11.5.</strong> A Brief Introduction to XML</a></li><li class="chapter-item expanded "><a href="ch11-06-Exercises.html"><strong aria-hidden="true">11.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch11-07-Quiz.html"><strong aria-hidden="true">11.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-ThreadsandMultiprocessing.html"><strong aria-hidden="true">12.</strong> Threads and Multiprocessing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-IntroductiontoThreads.html"><strong aria-hidden="true">12.1.</strong> Introduction to Threads</a></li><li class="chapter-item expanded "><a href="ch12-02-ProgrammingwithThreads.html"><strong aria-hidden="true">12.2.</strong> Programming with Threads</a></li><li class="chapter-item expanded "><a href="ch12-03-ThreadsandParallelProcessing.html"><strong aria-hidden="true">12.3.</strong> Threads and Networking</a></li><li class="chapter-item expanded "><a href="ch12-04-ThreadsandNetworking.html"><strong aria-hidden="true">12.4.</strong> Threads and Networking</a></li><li class="chapter-item expanded "><a href="ch12-05-NetworkProgrammingExample.html"><strong aria-hidden="true">12.5.</strong> Network Programming Example</a></li><li class="chapter-item expanded "><a href="ch12-06-Exercises.html"><strong aria-hidden="true">12.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch12-07-Quiz.html"><strong aria-hidden="true">12.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-GUIProgrammingContinued.html"><strong aria-hidden="true">13.</strong> GUI Programming Continued</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-PropertiesandBindings.html"><strong aria-hidden="true">13.1.</strong> Properties and Bindings</a></li><li class="chapter-item expanded "><a href="ch13-02-FancierGraphics.html"><strong aria-hidden="true">13.2.</strong> Fancier Graphics</a></li><li class="chapter-item expanded "><a href="ch13-03-ComplexComponentsandMVC.html"><strong aria-hidden="true">13.3.</strong> Complex Components and MVC</a></li><li class="chapter-item expanded "><a href="ch13-04-MostlyWindowsandDialogs.html"><strong aria-hidden="true">13.4.</strong> Mostly Windows and Dialogs</a></li><li class="chapter-item expanded "><a href="ch13-05-FinishingTouches.html"><strong aria-hidden="true">13.5.</strong> Finishing Touches</a></li><li class="chapter-item expanded "><a href="ch13-06-Exercises.html"><strong aria-hidden="true">13.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch13-07-Quiz.html"><strong aria-hidden="true">13.7.</strong> Quiz</a></li></ol><li class="chapter-item expanded "><a href="appendix-00.html"> Appendix</a></li><li class="chapter-item expanded "><a href="glossary-00.html"> Glossary</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="Java">Java</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Introduction to Programming Using Java</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Xayarsh/Java-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Inheritance and Polymorphism"><a class="header" href="#Inheritance and Polymorphism">Inheritance and Polymorphism</a></h2>

                        <p>
                            A class represents a set of objects which share the
                            same structure and behaviors. The class determines the structure of objects by
                            specifying variables that are contained in each instance of the class, and it
                            determines behavior by providing the instance methods that express the behavior
                            of the objects. This is a powerful idea. However, something like this can be
                            done in most programming languages. The central new idea in object-oriented
                            programming&mdash;the idea that really distinguishes it from traditional
                            programming&mdash;is to allow classes to express the similarities among objects
                            that share <b>some</b>, but not all, of their structure and behavior.
                            Such similarities can be expressed using <span class="newword">inheritance</span>
                            and <span class="newword">polymorphism</span>.</p>

                       <h3 id="Extending Existing Classes"><a class="header" href="#Extending Existing Classes">Extending Existing Classes</a></h3>


                        <p>Any programmer should know what is meant by
                            subclass, inheritance, and polymorphism. However, it will probably be a while
                            before you actually do anything with inheritance except for extending classes
                            that already exist.  In the first part of this section, we look at how that
                            is done.</p>


                        <p>In day-to-day programming, especially for programmers who are just beginning
                            to work with objects, subclassing is used mainly in one situation: There is an
                            existing class that can be adapted with a few changes or additions. This is
                            much more common than designing groups of classes and subclasses from scratch.
                            The existing class can be <span class="newword">extended</span> to make a
                            subclass. The syntax for this is</p>


                        <pre><code class="java">public class <span class="bnf">subclass-name</span> extends <span class="bnf">existing-class-name</span> {
   .
   .   // Changes and additions.
   .
}</code></pre>



                        <p>As an example, suppose you want to write a program that plays the card game,
                            Blackjack. You can use the <span class="classname">Card</span>,
                            <span class="classname">Hand</span>, and <span class="classname">Deck</span>
                            classes developed in <a href="ch05-04-AnExample.html">Section&nbsp;5.4</a>. However, a hand in the
                            game of Blackjack is a little different from a hand of cards in general, since
                            it must be possible to compute the "value" of a Blackjack hand according to the
                            rules of the game. The rules are as follows: The value of a hand is obtained by
                            adding up the values of the cards in the hand. The value of a numeric card such
                            as a three or a ten is its numerical value. The value of a Jack, Queen, or King
                            is 10. The value of an Ace can be either 1 or 11. An Ace should be counted as
                            11 unless doing so would put the total value of the hand over 21. Note that
                            this means that the second, third, or fourth Ace in the hand will always be
                            counted as 1.</p>


                        <p>One way to handle this is to extend the existing <span class="classname">Hand</span> class by
                            adding a method that computes the Blackjack value of the hand. Here's the
                            definition of such a class:</p>


                        <pre><code class="java">public class BlackjackHand <span class="newcode">extends Hand</span> {

    /**
     * Computes and returns the value of this hand in the game
     * of Blackjack.
     */
    public int getBlackjackValue() {

        int val;      // The value computed for the hand.
        boolean ace;  // This will be set to true if the
                      //   hand contains an ace.
        int cards;    // Number of cards in the hand.

        val = 0;
        ace = false;
        cards = getCardCount();  // (method defined in class Hand.)

        for ( int i = 0;  i &lt; cards;  i++ ) {
                // Add the value of the i-th card in the hand.
            Card card;    // The i-th card;
            int cardVal;  // The blackjack value of the i-th card.
            card = getCard(i);
            cardVal = card.getValue();  // The normal value, 1 to 13.
            if (cardVal &gt; 10) {
                cardVal = 10;   // For a Jack, Queen, or King.
            }
            if (cardVal == 1) {
                ace = true;     // There is at least one ace.
            }
            val = val + cardVal;
         }

         // Now, val is the value of the hand, counting any ace as 1.
         // If there is an ace, and if changing its value from 1 to
         // 11 would leave the score less than or equal to 21,
         // then do so by adding the extra 10 points to val.

         if ( ace == true  &amp;&amp;  val + 10 &lt;= 21 )
             val = val + 10;

         return val;

    }  // end getBlackjackValue()

} // end class BlackjackHand</code></pre>


                        <p>Since <span class="classname">BlackjackHand</span> is a subclass of <span class="classname">Hand</span>, an object of
                            type <span class="classname">BlackjackHand</span> contains all the instance variables and instance
                            methods defined in <span class="classname">Hand</span>, plus the new instance method named
                            <span class="code">getBlackjackValue()</span>. For example, if <span class="code">bjh</span> is a variable of
                            type <span class="code">BlackjackHand</span>, then the following are all legal:
                            <span class="code">bjh.getCardCount()</span>, <span class="code">bjh.removeCard(0)</span>, and
                            <span class="code">bjh.getBlackjackValue()</span>.  The first two methods are defined in <span class="classname">Hand</span>,
                            but are inherited by <span class="classname">BlackjackHand</span>.</p>


                        <p>Variables and methods from the <span class="classname">Hand</span> class  are
                            inherited by <span class="classname">BlackjackHand</span>, and they can be used
                            in the definition of <span class="classname">BlackjackHand</span> just as if they
                            were actually defined in that class&mdash;except for any that are
                            declared to be <span class="code">private</span>, which prevents access even by subclasses. The statement "<span class="code">cards&nbsp;=
getCardCount();</span>" in the above definition of <span class="code">getBlackjackValue()</span>
                            calls the instance method <span class="code">getCardCount()</span>, which was defined in
                            <span class="classname">Hand</span>.</p>


                        <p>Extending existing classes is an easy way to build on previous work. We'll
                            see that many standard classes have been written specifically to be used as the
                            basis for making subclasses.</p>





                        <p>Access modifiers such as <span class="code">public</span> and <span class="code">private</span> are used
                            to control access to members of a class.  There is one more access modifier,
                            <span class="newword">protected</span>, that comes into the picture when subclasses are taken
                            into consideration.  When <span class="code">protected</span> is applied as an access modifier
                            to a method or member variable in a class,
                            that member can be used in subclasses&mdash;direct or indirect&mdash;of the class in which
                            it is defined, but it cannot be used in non-subclasses.  (There is an exception: A <span class="code">protected</span> member
                            can also be accessed by any class in the same package as the class that contains the protected member.
                            Recall that using no access modifier makes a member accessible to classes in the same package, and nowhere
                            else.  Using the <span class="code">protected</span> modifier is strictly more liberal than using no modifier
                            at all:  It allows access from classes in the same package and from <b>subclasses</b> that are not
                            in the same package.)</p>


                        <p>When you declare a method or member variable to be <span class="code">protected</span>, you are saying
                            that it is part of the implementation of the class, rather than part of the public interface of
                            the class.  However, you are allowing subclasses to use and modify that part of the implementation.</p>


                        <p>For example, consider a <span class="classname">PairOfDice</span> class that has instance
                            variables <span class="code">die1</span> and <span class="code">die2</span>
                            to represent the numbers appearing on the two dice.  We could make those variables
                            <span class="code">private</span> to make it impossible to change their values from outside the
                            class, while still allowing read access through getter methods.  However, if we think
                            it possible that <span class="classname">PairOfDice</span> will be used to create subclasses,
                            we might want to make it possible for subclasses to change the numbers on the dice.
                            For example, a <span class="classname">GraphicalDice</span> subclass that draws the dice might
                            want to change the numbers at other times besides when the dice are rolled.
                            In that case, we could make <span class="code">die1</span> and <span class="code">die2</span>
                            <span class="code">protected</span>, which would allow the
                            subclass to change their values without making them public to the rest of the world.
                            (An even better idea would be to define <span class="code">protected</span> setter methods for
                            the variables.  A setter method could, for example, ensure that the value that is
                            being assigned to the variable is in the legal range 1 through&nbsp;6.)</p>

                       <h3 id="Inheritance and Class Hierarchy"><a class="header" href="#Inheritance and Class Hierarchy">Inheritance and Class Hierarchy</a></h3>


                        <p>The term <span class="newword">inheritance</span> refers to the fact that
                            one class can inherit part or all of its structure and behavior from another
                            class.  The class that does the inheriting is said to be a <span class="newword">subclass</span>
                            of the class from which it inherits. If class B is a
                            subclass of class A, we also say that class A is a <span class="newword">superclass</span> of
                            class B. (Sometimes the terms <span class="newword">derived class</span> and <span class="newword">base class</span> are
                            used instead of subclass and superclass; this is the common terminology in&nbsp;C++.)
                            A subclass can add to the structure
                            and behavior that it inherits. It can also replace or modify inherited behavior
                            (though not inherited structure). The relationship between subclass and
                            superclass is sometimes shown by a diagram in which the subclass is shown
                            below, and connected to, its superclass, as shown on the left below:</p>



                        <p align="center">
                            <img src="./images/subclass-superclass.png" width="552" height="223" alt="two class hierarchy diagrams"></p>


                        <p>In Java, to create a class named "B" as a subclass of a class named "A",
                            you would write</p>


                        <pre><code class="java">class B extends A {
    .
    .  // additions to, and modifications of,
    .  // stuff inherited from class A
    .
}</code></pre>



                        <p>Several classes
                            can be declared as subclasses of the same superclass. The subclasses, which
                            might be referred to as "sibling classes," share some structures and behaviors&mdash;namely,
                            the ones they inherit from their common superclass. The superclass
                            expresses these shared structures and behaviors. In the diagram shown
                            on the right above,
                            classes B, C, and D are sibling classes. Inheritance can also extend over
                            several "generations" of classes. This is shown in the diagram, where class E
                            is a subclass of class D which is itself a subclass of class A. In this case,
                            class E is considered to be a subclass of class A, even though it is not a
                            direct subclass.  This whole set of classes forms a small
                            <span class="newword">class hierarchy</span>.</p>


                        <br clear="all">


                       <h3 id="Example: Vehicles"><a class="header" href="#Example: Vehicles">Example: Vehicles</a></h3>


                        <p>Let's look at
                            an example. Suppose that a program has to deal with motor vehicles, including
                            cars, trucks, and motorcycles. (This might be a program used by a Department of
                            Motor Vehicles to keep track of registrations.) The program could use a class
                            named <span class="classname">Vehicle</span> to represent all types of vehicles.  Since cars, trucks,
                            and motorcycles are types of vehicles, they would be represented by subclasses
                            of the <span class="classname">Vehicle</span> class, as shown in this class hierarchy diagram:</p>


                        <p align="center">
                            <img src="./images/vehicle-hierarchy.png" alt=""></p>


                        <p>The <span class="classname">Vehicle</span>
                            class would include instance variables such as <span class="code">registrationNumber</span> and
                            <span class="code">owner</span> and instance methods such as <span class="code">transferOwnership()</span>. These
                            are variables and methods common to all vehicles. The three subclasses of
                            <span class="classname">Vehicle</span>&mdash;<span class="classname">Car</span>,
                            <span class="classname">Truck</span>, and <span class="classname">Motorcycle</span>&mdash;could
                            then be used to hold variables and methods specific to particular types
                            of vehicles. The <span class="classname">Car</span> class might add an instance variable
                            <span class="code">numberOfDoors</span>, the <span class="classname">Truck</span> class might have
                            <span class="code">numberOfAxles</span>, and the <span class="classname">Motorcycle</span> class could have a boolean
                            variable <span class="code">hasSidecar</span>. (Well, it <u>could</u> in theory at least, even
                            if it might give a chuckle to the people at the Department of Motor Vehicles.)
                            The declarations of these classes in a Java program would look, in outline, like
                            this (although they are likely to be  defined
                            in separate files and declared as <span class="code">public</span> classes):</p>


                        <pre><code class="java">class Vehicle {
   int registrationNumber;
   Person owner;  // (Assuming that a Person class has been defined!)
   void transferOwnership(Person newOwner) {
       . . .
   }
   . . .
}

class Car extends Vehicle {
   int numberOfDoors;
   . . .
}

class Truck extends Vehicle {
   int numberOfAxles;
   . . .
}

class Motorcycle extends Vehicle {
   boolean hasSidecar;
   . . .
}</code></pre>


                        <p>Suppose that <span class="code">myCar</span> is a variable of type <span class="classname">Car</span> that has been
                            declared and initialized with the statement</p>


                        <pre><code class="java">Car myCar = new Car();</code></pre>


                        <p>Given this declaration, a program could refer to
                            <span class="code">myCar.numberOfDoors</span>, since <span class="code">numberOfDoors</span> is an instance
                            variable in the class <span class="code">Car</span>. But since class <span class="classname">Car</span> extends class
                            <span class="classname">Vehicle</span>, a car also has all the structure and behavior of a vehicle.
                            This means that <span class="code">myCar.registrationNumber</span>, <span class="code">myCar.owner</span>, and
                            <span class="code">myCar.transferOwnership()</span> also exist.</p>


                        <p>Now, in the real world, cars, trucks, and motorcycles are in fact vehicles.
                            The same is true in a program. That is, an object of type <span class="classname">Car</span> or
                            <span class="classname">Truck</span> or <span class="classname">Motorcycle</span> is automatically an object of type
                            <span class="classname">Vehicle</span> too. This brings us to the following Important Fact:</p>


                        <blockquote>
                            <p>
                                <b>A variable that can hold a reference<br>
                                    to an object of class A can also hold a reference<br>
                                    to an object belonging to any subclass of A.</b>
                            </p>

                        </blockquote>


                        <p>The practical effect of this in our example is that an object of type
                            <span class="classname">Car</span> can be assigned to a variable of type <span class="classname">Vehicle</span>. That is,
                            it would be legal to say</p>


                        <pre><code class="java">Vehicle myVehicle = myCar;</code></pre>


                        <p>or even</p>


                        <pre><code class="java">Vehicle myVehicle = new Car();</code></pre>


                        <p>After either of these statements, the variable <span class="code">myVehicle</span> holds a
                            reference to a <span class="classname">Vehicle</span> object that happens to be an instance of the
                            subclass, <span class="classname">Car</span>. The object "remembers" that it is in fact a
                            <span class="classname">Car</span>, and not <b>just</b> a <span class="classname">Vehicle</span>. Information about the
                            actual class of an object is stored as part of that object. It is even possible
                            to test whether a given object belongs to a given class, using the
                            <span class="code">instanceof</span> operator. The test:</p>


                        <pre><code class="java">if (myVehicle instanceof Car) ...</code></pre>


                        <p>determines whether the object referred to by <span class="code">myVehicle</span> is in fact a
                            car.</p>


                        <p>On the other hand, the assignment statement</p>


                        <pre><code class="java">myCar = myVehicle;  // ERROR!</code></pre>


                        <p>would be illegal because <span class="code">myVehicle</span> could potentially refer to other
                            types of vehicles that are not cars. This is similar to a problem we saw
                            previously in <a href="ch02-05-DetailsOfExpressions.html">Subsection&nbsp;2.5.6</a>: The computer will not
                            allow you to assign an <span class="ptype">int</span> value to a variable of type <span class="ptype">short</span>,
                            because not every <span class="ptype">int</span> is a <span class="ptype">short</span>. Similarly, it will not
                            allow you to assign a value of type <span class="classname">Vehicle</span> to a variable of type
                            <span class="classname">Car</span> because not every vehicle is a car. As in the case of
                            <span class="ptype">ints</span> and <span class="ptype">shorts</span>, the solution here is to use type-casting.
                            If, for some reason, you happen to know that <span class="code">myVehicle</span> does in fact
                            refer to a <span class="classname">Car</span>, you can use the type cast <span class="code">(Car)myVehicle</span> to
                            tell the computer to treat <span class="code">myVehicle</span> as if it were actually of type
                            <span class="classname">Car</span>. So, you could say</p>


                        <pre><code class="java">myCar = (Car)myVehicle;</code></pre>


                        <p>and you could even refer to <span class="code">((Car)myVehicle).numberOfDoors</span>.
                            (The parentheses are necessary because of precedence.  The "<span class="code">.</span>"
                            has higher precedence than the type-cast, so
                            <span class="code">(Car)myVehicle.numberOfDoors</span> would be read as <span class="code">(Car)(myVehicle.numberOfDoors)</span>,
                            an attempt to type-cast the <span class="ptype">int</span>
                            <span class="code">myVehicle.numberOfDoors</span> into a <span class="classname">Vehicle</span>,
                            which is impossible.)
                        </p>


                        <p>As an
                            example of how this could be used in a program, suppose that you want to print
                            out relevant data about the <span class="classname">Vehicle</span> referred to by
                            <span class="code">myVehicle</span>.  If it's a <span class="classname">Car</span>, you will want
                            to print out the car's <span class="code">numberOfDoors</span>, but you can't
                            say <span class="code">myVehicle.numberOfDoors</span>, since there is no <span class="code">numberOfDoors</span>
                            in the <span class="classname">Vehicle</span> class.  But you could say:</p>


                        <pre><code class="java">System.out.println("Vehicle Data:");
System.out.println("Registration number:  "
                              + myVehicle.registrationNumber);
if (myVehicle instanceof Car) {
   System.out.println("Type of vehicle:  Car");
   Car myCar;
   myCar = (Car)myVehicle;  // Type-cast to get access to numberOfDoors!
   System.out.println("Number of doors:  " + myCar.numberOfDoors);
}
else if (myVehicle instanceof Truck) {
   System.out.println("Type of vehicle:  Truck");
   Truck myTruck;
   myTruck = (Truck)myVehicle;  // Type-cast to get access to numberOfAxles!
   System.out.println("Number of axles:  " + myTruck.numberOfAxles);
}
else if (myVehicle instanceof Motorcycle) {
   System.out.println("Type of vehicle:  Motorcycle");
   Motorcycle myCycle;
   myCycle = (Motorcycle)myVehicle;  // Type-cast to get access to hasSidecar!
   System.out.println("Has a sidecar:    " + myCycle.hasSidecar);
}</code></pre>


                        <p>Note that for object types, when the computer executes a program, it checks
                            whether type-casts are valid. So, for example, if <span class="code">myVehicle</span> refers to
                            an object of type <span class="classname">Truck</span>, then the type cast <span class="code">(Car)myVehicle</span>
                            would be an error.  When this happens, an exception of type
                            <span class="classname">ClassCastException</span> is thrown.  This check is done at run time,
                            not compile time, because the actual type of the object referred to by <span class="code">myVehicle</span>
                            is not known when the program is compiled.  The code above avoids <span class="classname">ClassCastExceptions</span>
                            by using <span class="code">instanceof</span> to test the type of the variable before doing a type cast.</p>





                        <p>In Java 17, the previous example can also be written using one of the more obscure new
                            language features, known as <span class="newword">pattern matching</span> for <span class="code">instanceof</span>.
                            Pattern matching makes it possible to include declaration and initialization of a variable in
                            an <span class="code">instanceof</span> test.  For example,</p>


                        <pre><code class="java">if (myVehicle instanceof Car <span class="newcode">myCar</span>) {
    System.out.println("Type of vehicle: Car");
    System.out.println(Number of doors: " + myCar.numberOfDoors);
}</code></pre>


                        <p>If the test succeeds, then the variable <span class="code">myCar</span> is created and
                            automatically assigned the value <span class="code">(Car)myVehicle</span>. The scope of
                            the variable is limited to the body of the <span class="code">if</span> statement.</p>


                       <h3 id="Polymorphism"><a class="header" href="#Polymorphism">Polymorphism</a></h3>


                        <p>As another example, consider a program that deals with shapes drawn on the
                            screen. Let's say that the shapes include rectangles, ovals, and roundrects of
                            various colors.  (A "roundrect" is just a rectangle with rounded corners.)</p>


                        <p align="center">
                            <img src="./images/various-shapes.png" width="494" height="164" alt="(illustration showing various shapes)" class="bordered"></p>


                        <p>Three classes, <span class="classname">Rectangle</span>, <span class="classname">Oval</span>,
                            and <span class="classname">RoundRect</span>,
                            could be used to represent the three types of shapes. These three classes would
                            have a common superclass, <span class="classname">Shape</span>, to represent features that all three
                            shapes have in common. The <span class="classname">Shape</span> class could include instance
                            variables to represent the color, position, and size of a shape, and it could
                            include instance methods for changing the values of those properties.
                            Changing the color, for example, might involve changing the value of an
                            instance variable, and then redrawing the shape in its new color:</p>


                        <pre><code class="java">class Shape {

    Color color; // (must be imported from package javafx.scene.paint)

    void setColor(Color newColor) {
          // Method to change the color of the shape.
       color = newColor; // change value of instance variable
       redraw(); // redraw shape, which will appear in new color
    }

    void redraw() {
          // method for drawing the shape
       ? ? ?  // what commands should go here?
    }

    . . .          // more instance variables and methods

} // end of class Shape</code></pre>


                        <p>Now, you might see a problem here with the method <span class="code">redraw()</span>. The
                            problem is that each different type of shape is drawn differently. The method
                            <span class="code">setColor()</span> can be called for any type of shape. How does the computer
                            know which shape to draw when it executes the <span class="code">redraw()</span>  command in
                            the <span class="code">setColor()</span> method? Informally, we
                            can answer the question like this: The computer executes <span class="code">redraw()</span> by
                            asking the shape to redraw <b>itself</b>. Every shape object knows
                            what it has to do to redraw itself.</p>


                        <p>In practice, this means that each of the specific shape classes has its own
                            <span class="code">redraw()</span> method:</p>


                        <pre><code class="java">class Rectangle extends Shape {
   void redraw() {
      . . .  // commands for drawing a rectangle
   }
   . . . // possibly, more methods and variables
}

class Oval extends Shape {
   void redraw() {
      . . .  // commands for drawing an oval
   }
   . . . // possibly, more methods and variables
}

class RoundRect extends Shape {
   void redraw() {
      . . .  // commands for drawing a rounded rectangle
   }
   . . . // possibly, more methods and variables
}</code></pre>


                        <p>Suppose that <span class="code">someShape</span> is a variable of type <span class="classname">Shape</span>.
                            Then it could refer to
                            an object of any of the types <span class="classname">Rectangle</span>, <span class="classname">Oval</span>, or
                            <span class="classname">RoundRect</span>. As a program executes, and the value of <span class="code">someShape</span>
                            changes, it could even refer to objects of different types at different times!
                            Whenever the statement</p>


                        <pre><code class="java">someShape.redraw();</code></pre>


                        <p>is executed, the redraw method that is actually called is the one
                            appropriate for the type of object to which <span class="code">someShape</span> actually refers.
                            There may be no way of telling, from looking at the text of the program, what
                            shape this statement will draw, since it depends on the value that
                            <span class="code">someShape</span> happens to have when the program is executed. Even more is
                            true. Suppose the statement is in a loop and gets executed many times. If the
                            value of <span class="code">someShape</span> changes as the loop is executed, it is possible that
                            the very same statement "<span class="code">someShape.redraw();</span>" will call different
                            methods and draw different kinds of shapes as it is executed several times. We say that
                            the <span class="code">redraw()</span> method is <span class="newword">polymorphic</span>. A
                            method is polymorphic if the action performed by the method depends on the
                            actual type of the object to which the method is applied at run time. Polymorphism is one
                            of the major distinguishing features of object-oriented programming.  This can be
                            seen most vividly, perhaps, if we have an array of shapes.  Suppose that
                            <span class="code">shapelist</span> is a variable of type <span class="atype">Shape[]</span>,
                            and that the array has already been created and filled with data.  Some of
                            the elements in the array might be <span class="classname">Rectangles</span>,
                            some might be <span class="classname">Ovals</span>, and some might be <span class="classname">RoundRects</span>.
                            We can draw all the shapes in the array by saying</p>


                        <pre><code class="java">for (int i = 0; i &lt; shapelist.length; i++ ) {
    Shape shape = shapelist[i];
    shape.redraw();
}</code></pre>


                        <p>As the computer goes through this loop, the statement <span class="code">shape.redraw()</span>
                            will sometimes draw a rectangle, sometimes an oval, and sometimes a roundrect,
                            depending on the type of object to which array element number <span class="code">i</span> refers.</p>


                        <p>Perhaps this becomes more understandable if we change our terminology a bit:
                            In object-oriented programming, calling a method is often referred to as
                            sending a <span class="newword">message</span> to an object. The object
                            responds to the message by executing the appropriate method. The statement
                            "<span class="code">someShape.redraw();</span>" is a message to the object referred to by
                            <span class="code">someShape</span>. Since that object knows what type of object it is, it knows
                            how it should respond to the message. From this point of view, the computer
                            always executes "<span class="code">someShape.redraw();</span>" in the same way: by sending a
                            message. The response to the message depends, naturally, on who receives it.
                            From this point of view, objects are active entities that send and receive
                            messages, and polymorphism is a natural, even necessary, part of this view.
                            Polymorphism just means that different objects can respond to the same message
                            in different ways.</p>


                        <p> One of the
                            most beautiful things about polymorphism is that it lets code that you write do
                            things that you didn't even conceive of, at the time you wrote it. Suppose that
                            I decide to add beveled rectangles to the types of shapes my program can deal
                            with.  A beveled rectangle has a triangle cut off each corner:</p>


                        <p align="center">
                            <img src="./images/beveled-rects.png" width="185" height="220" alt="some examples of beveled rects" class="bordered"></p>



                        <p>To implement beveled rectangles, I can write a new subclass, <span class="classname">BeveledRect</span>, of
                            class <span class="classname">Shape</span> and give it its own <span class="code">redraw()</span> method.
                            Automatically, code that I wrote previously&mdash;such as the statement
                            <span class="code">someShape.redraw()</span>&mdash;can now suddenly start drawing beveled
                            rectangles, even though the beveled rectangle class didn't exist when I wrote
                            the statement!</p>





                        <p>In the statement "<span class="code">someShape.redraw();</span>", the <span class="code">redraw</span> message
                            is sent to the object <span class="code">someShape</span>. Look back at the method in the
                            <span class="classname">Shape</span> class for changing the color of a shape:</p>


                        <pre><code class="java">void setColor(Color newColor) {
   color = newColor; // change value of instance variable
   redraw(); // redraw shape, which will appear in new color
}</code></pre>


                        <p>A <span class="code">redraw</span> message is sent here, but which object is it sent to?
                            Well, the <span class="code">setColor</span> method is itself a message that was sent to some
                            object. The answer is that the <span class="code">redraw</span> message is sent to that <b>same
                                object</b>, the one that received the <span class="code">setColor</span> message. If that object is
                            a rectangle, then it contains a <span class="code">redraw()</span> method for drawing rectangles,
                            and that is the one that is executed.  If the object is an oval, then
                            the <span class="code">redraw()</span> method from the <span class="classname">Oval</span> class is executed. This is what you
                            should expect, but it means that the "<span class="code">redraw();</span>" statement in the
                            <span class="code">setColor()</span> method does <b>not</b> necessarily call the
                            <span class="code">redraw()</span> method in the <span class="classname">Shape</span> class! The <span class="code">redraw()</span>
                            method that is executed could be in any subclass of <span class="classname">Shape</span>.
                            This is just another case of polymorphism.</p>


                       <h3 id="Abstract Classes"><a class="header" href="#Abstract Classes">Abstract Classes</a></h3>


                        <p>Whenever a <span class="classname">Rectangle</span>, <span class="classname">Oval</span>,
                            or <span class="classname">RoundRect</span> object
                            has to draw itself, it is the <span class="code">redraw()</span> method in the appropriate class
                            that is executed. This leaves open the question, What does the
                            <span class="code">redraw()</span> method in the <span class="classname">Shape</span> class do? How should it be
                            defined?</p>


                        <p>The answer may be surprising: We should leave it blank! The fact is that the
                            class <span class="classname">Shape</span> represents the abstract idea of a shape, and there is no
                            way to draw such a thing. Only particular, concrete shapes like rectangles and
                            ovals can be drawn. So, why should there even be a <span class="code">redraw()</span> method in
                            the <span class="classname">Shape</span> class? Well, it has to be there, or it would be illegal to
                            call it in the <span class="code">setColor()</span> method of the <span class="classname">Shape</span> class, and it
                            would be illegal to write "<span class="code">someShape.redraw()</span>;". The compiler would
                            complain that <span class="code">someShape</span> is a variable of type <span class="classname">Shape</span> and
                            there's no <span class="code">redraw()</span> method in the <span class="classname">Shape</span> class.</p>


                        <p>Nevertheless the version of <span class="code">redraw()</span> in the <span class="classname">Shape</span> class itself
                            will never actually be called. In fact, if you think about it, there can never be any
                            reason to construct an actual object of type <span class="classname">Shape</span>! You can have
                            <b>variables</b> of type <span class="classname">Shape</span>, but the objects they refer
                            to will always belong to one of the subclasses of <span class="classname">Shape</span>. We say that
                            <span class="classname">Shape</span> is an <span class="newword">abstract class</span>. An abstract
                            class is one that is not used to construct objects, but only as a basis for
                            making subclasses. An abstract class exists <b>only</b> to express
                            the common properties of all its subclasses.  A class that is not abstract
                            is said to be <span class="newword">concrete</span>.  You can create objects belonging to
                            a concrete class, but not to an abstract class.  A variable whose type is given
                            by an abstract class can only refer to objects that belong to concrete subclasses
                            of the abstract class.</p>


                        <p>Similarly, we say that the <span class="code">redraw()</span> method in class <span class="classname">Shape</span>
                            is an <span class="newword">abstract method</span>, since it is never meant to
                            be called. In fact, there is nothing for it to do&mdash;any actual redrawing is
                            done by <span class="code">redraw()</span> methods in the subclasses of <span class="classname">Shape</span>. The
                            <span class="code">redraw()</span> method in <span class="classname">Shape</span> has to be there. But it is there
                            only to tell the computer that <b>all</b> <span class="code">Shapes</span> understand the
                            <span class="code">redraw</span> message. As an abstract method, it exists merely to specify the
                            common interface of all the actual, concrete versions of <span class="code">redraw()</span> in
                            the subclasses. There is no reason for the abstract
                            <span class="code">redraw()</span> in class <span class="classname">Shape</span> to contain any code at all.</p>


                        <p>
                            <span class="classname">Shape</span> and its <span class="code">redraw()</span> method are semantically abstract.
                            You can also tell the computer, syntactically, that they are abstract by adding
                            the modifier "<span class="code">abstract</span>" to their definitions. For an abstract method,
                            the block of code that gives the implementation of an ordinary method is
                            replaced by a semicolon. An implementation must then be provided for the abstract
                            method in any concrete subclass of the abstract class. Here's what the
                            <span class="classname">Shape</span> class would look like as an abstract class:</p>


                        <pre><code class="java">public abstract class Shape {

    Color color;   // color of shape.

    void setColor(Color newColor) {
          // method to change the color of the shape
       color = newColor; // change value of instance variable
       redraw(); // redraw shape, which will appear in new color
    }

    abstract void redraw();
          // abstract method&mdash;must be defined in
          // concrete subclasses

    . . .  // more instance variables and methods

} // end of class Shape</code></pre>


                        <p>Once you have declared the class to be <span class="code">abstract</span>, it becomes illegal to try to create actual objects
                            of type <span class="classname">Shape</span>, and the computer will report a syntax error if you try to do
                            so.</p>


                        <p>Note, by the way, that the <span class="classname">Vehicle</span> class discussed above would probably
                            also be an abstract class.  There is no way to own a vehicle as such&mdash;the actual vehicle has
                            to be a car or a truck or a motorcycle, or some other "concrete" type of vehicle.</p>





                        <p>Recall from <a href="ch05-03-ProgrammingWithObjects.html">Subsection&nbsp;5.3.2</a> that a class that is not explicitly declared to be a subclass
                            of some other class is automatically made a subclass of the standard class <span class="classname">Object</span>.
                            That is, a class declaration with no "<span class="code">extends</span>" part such as</p>


                        <pre><code class="java">public class myClass { . . .</code></pre>


                        <p>is exactly equivalent to</p>


                        <pre><code class="java">public class myClass extends Object { . . .</code></pre>


                        <p>This means that class <span class="classname">Object</span> is at the top of a huge class hierarchy that
                            includes every other class.  (Semantically, <span class="classname">Object</span> is an abstract class, in fact
                            the most abstract class of all.  Curiously, however, it is not declared to be <span class="code">abstract</span>
                            syntactically, which means that you can create objects of type <span class="classname">Object</span>.
                            However, there is not much that you can do with them.)</p>


                        <p>Since every class is a subclass of <span class="classname">Object</span>, a variable of type
                            <span class="classname">Object</span> can refer to any object whatsoever, of any type.
                            Similarly, an array of
                            type <span class="atype">Object[]</span> can hold objects of any type. </p>





                        <p>The sample source code file <span class="sourceref"><a href="./source/chapter5/ShapeDraw.java">ShapeDraw.java</a></span> uses an abstract
                            <span class="classname">Shape</span> class and an array of type <span class="atype">Shape[]</span>
                            to hold a list of shapes.
                            You might want to look at this file, even though you won't be able to
                            understand all of it at this time. Even the definitions of the shape classes
                            are somewhat different from those that I have described in this section. (For example,
                            the <span class="code">draw()</span> method has a parameter of type
                            <span class="classname">GraphicsContext&gt;</span>.
                            This parameter is required because all drawing in
                            Java requires a graphics context.) I'll return to similar examples in later chapters when you know more
                            about GUI programming. However, it would still be worthwhile to look at the definition
                            of the <span class="classname">Shape</span> class and its subclasses in the source code.
                            You might also check how an array is used to hold the list of shapes.  Here is a scaled-down screenshot
                            from the program:</p>


                        <p align="center">
                            <img src="./images/shapedraw-screenshot.png" width="500" height="415" alt="screenshot from ShapeDraw, showing several shapes in its drawing area"></p>


                        <p>If you run the <span class="code">ShapeDraw</span> program,
                            you can click one of the buttons along the bottom to add a shape to the picture.
                            The new shape will appear in the upper left corner of the drawing area. The color
                            of the shape is given by the "pop-up menu" of colors below the drawing area. Once a shape is
                            on the screen, you can drag it around with the mouse. A shape will maintain the
                            same front-to-back order with respect to other shapes on the screen, even while
                            you are dragging it. However, you can move a shape out in front of all the
                            other shapes if you hold down the shift key as you click on it.</p>


                        <p>In the program, the only time when the actual class of a shape is used is
                            when that shape is added to the screen. Once the shape has been created, it is
                            manipulated entirely as an abstract shape. The routine that implements
                            dragging, for example, works with variables of type <span class="classname">Shape</span> and
                            makes no reference to any of its subclasses. As the
                            shape is being dragged, the dragging routine just calls the
                            shape's draw method each time the shape has to be drawn, so it doesn't
                            have to know how to draw the shape or even what type of shape it is. The object
                            is responsible for drawing itself. If I wanted to add a new type of shape to
                            the program, I would define a new subclass of <span class="classname">Shape</span>, add another
                            button, and program the button to add the correct type of shape
                            to the screen. No other changes in the programming would be necessary.</p>



                       <h3 id="Final Methods and Classes"><a class="header" href="#Final Methods and Classes">Final Methods and Classes</a></h3>

                        <p>We have seen how the <span class="code">final</span> modifier applies to variables: It makes it impossible
                            to assign a new value to the variable after it has been initialized.  (For a <span class="code">final</span>
                            instance variable, the initialization can take place in the constructors for the class that
                            contains the variable.)  However, the <span class="code">final</span> modifier can also be applied to
                            classes and to method definitions.</p>


                        <p>A <span class="code">final</span> class cannot be used be used as a basis for making subclasses.  That is,
                            if a class is defined as "<span class="code">final class A...</span>", then it is a syntax error to
                            try to extend <span class="classname">A</span> with "class B extends A...".</p>


                        <p>If a method is declared <span class="code">final</span> in a class, then it is not possible for a subclass
                            to contain a method with the same signature.  That is, the method cannot be "overridden".
                            This is true both for <span class="code">static</span> methods and for instance methods.
                            Note that in a <span class="code">final</span> class, all methods are implicitly final since it is
                            not even possible to make a subclass of that class.</p>


                        <p>The idea is that a <span class="code">final</span> class or method is in its final form&mdash;it cannot
                            be modified or replaced by a subclass.  With <span class="code">final</span>, it is possible to make a guarantee
                            about the behavior of a method.  For example, suppose that a <span class="classname">Rectangle</span> class has
                            an instance method <span class="code">draw()</span> that draws a rectangle, and that <span class="code">rect</span>
                            is a variable of type <span class="classname">Rectangle</span>.  If <span class="code">draw()</span> is a <span class="code">final</span>
                            method, then we are guaranteed that a call to <span class="code">rect.draw()</span> will draw a rectangle.  But
                            if <span class="code">draw()</span> is <b>not</b> <span class="code">final</span>, then it could draw anything, or nothing!
                            The problem is that <span class="code">rect</span> could actually refer to an object belonging to some subclass
                            of <span class="classname">Rectangle</span>, and that subclass could define its own <span class="code">draw()</span>
                            method that overrides the <span class="code">draw()</span> method from class <span class="classname">Rectangle</span>.
                            Using <span class="code">final</span> can make it easier to reason about the behavior of a program.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch05-04-AnExample.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch05-06-thisandsuper.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch05-04-AnExample.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch05-06-thisandsuper.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </body>
</html>
