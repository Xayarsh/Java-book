<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Exceptions and try..catch - Introduction to Programming Using Java</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

<link rel="stylesheet" href="code-class.css">

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html" >Introduction to Programming Using Java</a></li><li class="chapter-item expanded affix "><a href="preface.html">Preface</a></li><li class="chapter-item expanded "><a href="ch01-00-Overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-FetchExecuteCycle.html"><strong aria-hidden="true">1.1.</strong> Fetch and Execute Cycle</a></li><li class="chapter-item expanded "><a href="ch01-02-AsynchronousEvents.html"><strong aria-hidden="true">1.2.</strong> Asynchronous Events</a></li><li class="chapter-item expanded "><a href="ch01-03-JavaVirtualMachine.html"><strong aria-hidden="true">1.3.</strong> The Java Virtual Machine</a></li><li class="chapter-item expanded "><a href="ch01-04-FundamentalBuildingBlocks.html"><strong aria-hidden="true">1.4.</strong> Fundamentals</a></li><li class="chapter-item expanded "><a href="ch01-05-OOP.html"><strong aria-hidden="true">1.5.</strong> Object Oriented Programming</a></li><li class="chapter-item expanded "><a href="ch01-06-ModernUserInterface.html"><strong aria-hidden="true">1.6.</strong> Modern User Interface</a></li><li class="chapter-item expanded "><a href="ch01-07-InternetAndBeyond.html"><strong aria-hidden="true">1.7.</strong> Internet and Beyond</a></li><li class="chapter-item expanded "><a href="ch01-08-Quiz.html"><strong aria-hidden="true">1.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-NameAndThings.html"><strong aria-hidden="true">2.</strong> Name and Things</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-BasicJavaApplication.html"><strong aria-hidden="true">2.1.</strong> Basic Java Application</a></li><li class="chapter-item expanded "><a href="ch02-02-VariablesAndTypes.html"><strong aria-hidden="true">2.2.</strong> Variables and Types</a></li><li class="chapter-item expanded "><a href="ch02-03-ObjectsAndSubroutines.html"><strong aria-hidden="true">2.3.</strong> Objects and Subroutines</a></li><li class="chapter-item expanded "><a href="ch02-04-TextInputAndOutput.html"><strong aria-hidden="true">2.4.</strong> Text Input and Output</a></li><li class="chapter-item expanded "><a href="ch02-05-DetailsOfExpressions.html"><strong aria-hidden="true">2.5.</strong> Details of Expressions</a></li><li class="chapter-item expanded "><a href="ch02-06-ProgrammingEnvironments.html"><strong aria-hidden="true">2.6.</strong> Programming and Environments</a></li><li class="chapter-item expanded "><a href="ch02-07-Exercises.html"><strong aria-hidden="true">2.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch02-08-Quiz.html"><strong aria-hidden="true">2.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-Control.html"><strong aria-hidden="true">3.</strong> Control</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-BlocksLoopsBranches.html"><strong aria-hidden="true">3.1.</strong> Blocks, Loops and Branches</a></li><li class="chapter-item expanded "><a href="ch03-02-AlgorithmDevelopment.html"><strong aria-hidden="true">3.2.</strong> Algorithm Development</a></li><li class="chapter-item expanded "><a href="ch03-03-While.html"><strong aria-hidden="true">3.3.</strong> while and do...while</a></li><li class="chapter-item expanded "><a href="ch03-04-For.html"><strong aria-hidden="true">3.4.</strong> The for statement</a></li><li class="chapter-item expanded "><a href="ch03-05-If.html"><strong aria-hidden="true">3.5.</strong> The If Statement</a></li><li class="chapter-item expanded "><a href="ch03-06-Switch.html"><strong aria-hidden="true">3.6.</strong> The Switch Statement</a></li><li class="chapter-item expanded "><a href="ch03-07-ExceptionsTryCatch.html"><strong aria-hidden="true">3.7.</strong> Exceptions and try...catch</a></li><li class="chapter-item expanded "><a href="ch03-08-Arrays.html"><strong aria-hidden="true">3.8.</strong> Arrays: An Introduction</a></li><li class="chapter-item expanded "><a href="ch03-09-GUI.html"><strong aria-hidden="true">3.9.</strong> GUI: An Introduction</a></li><li class="chapter-item expanded "><a href="ch03-10-Exercises.html"><strong aria-hidden="true">3.10.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch03-11-Quiz.html"><strong aria-hidden="true">3.11.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-Subroutines.html"><strong aria-hidden="true">4.</strong> Subroutines</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-BlackBoxes.html"><strong aria-hidden="true">4.1.</strong> Black Boxes</a></li><li class="chapter-item expanded "><a href="ch04-02-StaticSubroutines.html"><strong aria-hidden="true">4.2.</strong> Static Subroutines and Variables</a></li><li class="chapter-item expanded "><a href="ch04-03-Parameters.html"><strong aria-hidden="true">4.3.</strong> Parameters</a></li><li class="chapter-item expanded "><a href="ch04-04-ReturnValues.html"><strong aria-hidden="true">4.4.</strong> Return Values</a></li><li class="chapter-item expanded "><a href="ch04-05-Lambda.html"><strong aria-hidden="true">4.5.</strong> Lambda Expressions</a></li><li class="chapter-item expanded "><a href="ch04-06-APIPackagesModulesJavadoc.html"><strong aria-hidden="true">4.6.</strong> API, Packages, Modules and Javadoc</a></li><li class="chapter-item expanded "><a href="ch04-07-MoreOnProgramDesign.html"><strong aria-hidden="true">4.7.</strong> More on Program Design</a></li><li class="chapter-item expanded "><a href="ch04-08-TruthAboutDeclarations.html"><strong aria-hidden="true">4.8.</strong> Truth about Declarations</a></li><li class="chapter-item expanded "><a href="ch04-09-Exercises.html"><strong aria-hidden="true">4.9.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch04-10-Quiz.html"><strong aria-hidden="true">4.10.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-ObjectsClasses.html"><strong aria-hidden="true">5.</strong> Objects and Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-ObjectsAndInstanceMethods.html"><strong aria-hidden="true">5.1.</strong> Objects and Instance Methods</a></li><li class="chapter-item expanded "><a href="ch05-02-ConstructorObjectInit.html"><strong aria-hidden="true">5.2.</strong> Constructor and Object Initialization</a></li><li class="chapter-item expanded "><a href="ch05-03-ProgrammingWithObjects.html"><strong aria-hidden="true">5.3.</strong> Programming with Objects</a></li><li class="chapter-item expanded "><a href="ch05-04-AnExample.html"><strong aria-hidden="true">5.4.</strong> An Example</a></li><li class="chapter-item expanded "><a href="ch05-05-InheritanceAndPolymorphism.html"><strong aria-hidden="true">5.5.</strong> Inheritance and Polymorphism</a></li><li class="chapter-item expanded "><a href="ch05-06-thisandsuper.html"><strong aria-hidden="true">5.6.</strong> this and super</a></li><li class="chapter-item expanded "><a href="ch05-07-Interfaces.html"><strong aria-hidden="true">5.7.</strong> Interfaces</a></li><li class="chapter-item expanded "><a href="ch05-08-NestedClasses.html"><strong aria-hidden="true">5.8.</strong> Nested Classes</a></li><li class="chapter-item expanded "><a href="ch05-09-Exercises.html"><strong aria-hidden="true">5.9.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch05-10-Quiz.html"><strong aria-hidden="true">5.10.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-GUIProgramming.html"><strong aria-hidden="true">6.</strong> Introduction to GUI Programming</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-BasicJavaFXApp.html"><strong aria-hidden="true">6.1.</strong> A Basic JavaFX Application</a></li><li class="chapter-item expanded "><a href="ch06-02-BasicClasses.html"><strong aria-hidden="true">6.2.</strong> Basic Classes</a></li><li class="chapter-item expanded "><a href="ch06-03-BasicEvents.html"><strong aria-hidden="true">6.3.</strong> Basic Events</a></li><li class="chapter-item expanded "><a href="ch06-04-BasicControls.html"><strong aria-hidden="true">6.4.</strong> Basic Controls</a></li><li class="chapter-item expanded "><a href="ch06-05-BasicLayout.html"><strong aria-hidden="true">6.5.</strong> Basic Layout</a></li><li class="chapter-item expanded "><a href="ch06-06-CompetePrograms.html"><strong aria-hidden="true">6.6.</strong> Complete Programs</a></li><li class="chapter-item expanded "><a href="ch06-07-Exercises.html"><strong aria-hidden="true">6.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch06-08-Quiz.html"><strong aria-hidden="true">6.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-ArraysArraylistsRecords.html"><strong aria-hidden="true">7.</strong> Arrays, ArrayLists and Records</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-ArrayDetails.html"><strong aria-hidden="true">7.1.</strong> Array Details</a></li><li class="chapter-item expanded "><a href="ch07-02-ArrayProcessing.html"><strong aria-hidden="true">7.2.</strong> Array Processing</a></li><li class="chapter-item expanded "><a href="ch07-03-ArrayLists.html"><strong aria-hidden="true">7.3.</strong> ArrayLists</a></li><li class="chapter-item expanded "><a href="ch07-04-Records.html"><strong aria-hidden="true">7.4.</strong> Records</a></li><li class="chapter-item expanded "><a href="ch07-05-SearchingAndSorting.html"><strong aria-hidden="true">7.5.</strong> Searching and Sorting</a></li><li class="chapter-item expanded "><a href="ch07-06-2DArrays.html"><strong aria-hidden="true">7.6.</strong> 2D Arrays</a></li><li class="chapter-item expanded "><a href="ch07-07-Exercises.html"><strong aria-hidden="true">7.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch07-08-Quiz.html"><strong aria-hidden="true">7.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-CorrectnessRobustnessEfficiency.html"><strong aria-hidden="true">8.</strong> Correctness, Robustness, Efficiency</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-IntroductionCorrectnessandRobustness.html"><strong aria-hidden="true">8.1.</strong> Introduction to Correctness and Robustness</a></li><li class="chapter-item expanded "><a href="ch08-02-WritingCorrectPrograms.html"><strong aria-hidden="true">8.2.</strong> Writing Correct Programs</a></li><li class="chapter-item expanded "><a class="active" href="ch08-03-ExceptionsAndtrycatch.html"><strong aria-hidden="true">8.3.</strong> Exceptions and try..catch</a></li><li class="chapter-item expanded "><a href="ch08-04-AssertionsAnnotations.html"><strong aria-hidden="true">8.4.</strong> Assertions and Annotations</a></li><li class="chapter-item expanded "><a href="ch08-05-AnalysisofAlgorithms.html"><strong aria-hidden="true">8.5.</strong> Analysis of Algorithms</a></li><li class="chapter-item expanded "><a href="ch08-06-Exercises.html"><strong aria-hidden="true">8.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch08-07-Quiz.html"><strong aria-hidden="true">8.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-LinkedDataStructuresRecursion.html"><strong aria-hidden="true">9.</strong> Linked Data Structures and Recursion</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-Recursion.html"><strong aria-hidden="true">9.1.</strong> Recursion</a></li><li class="chapter-item expanded "><a href="ch09-02-LinkedDataStructures.html"><strong aria-hidden="true">9.2.</strong> Linked Data Structures</a></li><li class="chapter-item expanded "><a href="ch09-03-StacksQueuesADTs.html"><strong aria-hidden="true">9.3.</strong> Stacks, Queues and ADTs</a></li><li class="chapter-item expanded "><a href="ch09-04-BinaryTrees.html"><strong aria-hidden="true">9.4.</strong> Binary Trees</a></li><li class="chapter-item expanded "><a href="ch09-05-SimpleRecursiveDescentParser.html"><strong aria-hidden="true">9.5.</strong> A Simple Recursive Descent Parser</a></li><li class="chapter-item expanded "><a href="ch09-06-Exercises.html"><strong aria-hidden="true">9.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch09-07-Quiz.html"><strong aria-hidden="true">9.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-GenericProgrammingandCollectionClasses.html"><strong aria-hidden="true">10.</strong> Generic Programmingand Collection Classes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-GenericProgramming.html"><strong aria-hidden="true">10.1.</strong> Generic Programming</a></li><li class="chapter-item expanded "><a href="ch10-02-ListsandSets.html"><strong aria-hidden="true">10.2.</strong> Lists and Sets</a></li><li class="chapter-item expanded "><a href="ch10-03-Maps.html"><strong aria-hidden="true">10.3.</strong> Maps</a></li><li class="chapter-item expanded "><a href="ch10-04-JCF.html"><strong aria-hidden="true">10.4.</strong> Programming with the JCF</a></li><li class="chapter-item expanded "><a href="ch10-05-WritingGenericClassesandMethods.html"><strong aria-hidden="true">10.5.</strong> Writing Generic Classes and Methods</a></li><li class="chapter-item expanded "><a href="ch10-06-StreamAPI.html"><strong aria-hidden="true">10.6.</strong> Stream APIs</a></li><li class="chapter-item expanded "><a href="ch10-07-Exercises.html"><strong aria-hidden="true">10.7.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch10-08-Quiz.html"><strong aria-hidden="true">10.8.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-IOStreamsFilesNetworking.html"><strong aria-hidden="true">11.</strong> I/O Streams, Files, and Networking</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-IOStreamsReadersAndWriters.html"><strong aria-hidden="true">11.1.</strong> I/O Streams, Readers, and Writers</a></li><li class="chapter-item expanded "><a href="ch11-02-Files.html"><strong aria-hidden="true">11.2.</strong> Files</a></li><li class="chapter-item expanded "><a href="ch11-03-ProgrammingWithFiles.html"><strong aria-hidden="true">11.3.</strong> Programming With Files</a></li><li class="chapter-item expanded "><a href="ch11-04-Networking.html"><strong aria-hidden="true">11.4.</strong> Networking</a></li><li class="chapter-item expanded "><a href="ch11-05-XML.html"><strong aria-hidden="true">11.5.</strong> A Brief Introduction to XML</a></li><li class="chapter-item expanded "><a href="ch11-06-Exercises.html"><strong aria-hidden="true">11.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch11-07-Quiz.html"><strong aria-hidden="true">11.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-ThreadsandMultiprocessing.html"><strong aria-hidden="true">12.</strong> Threads and Multiprocessing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-IntroductiontoThreads.html"><strong aria-hidden="true">12.1.</strong> Introduction to Threads</a></li><li class="chapter-item expanded "><a href="ch12-02-ProgrammingwithThreads.html"><strong aria-hidden="true">12.2.</strong> Programming with Threads</a></li><li class="chapter-item expanded "><a href="ch12-03-ThreadsandParallelProcessing.html"><strong aria-hidden="true">12.3.</strong> Threads and Parallel Processing</a></li><li class="chapter-item expanded "><a href="ch12-04-ThreadsandNetworking.html"><strong aria-hidden="true">12.4.</strong> Threads and Networking</a></li><li class="chapter-item expanded "><a href="ch12-05-NetworkProgrammingExample.html"><strong aria-hidden="true">12.5.</strong> Network Programming Example</a></li><li class="chapter-item expanded "><a href="ch12-06-Exercises.html"><strong aria-hidden="true">12.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch12-07-Quiz.html"><strong aria-hidden="true">12.7.</strong> Quiz</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-GUIProgrammingContinued.html"><strong aria-hidden="true">13.</strong> GUI Programming Continued</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-PropertiesandBindings.html"><strong aria-hidden="true">13.1.</strong> Properties and Bindings</a></li><li class="chapter-item expanded "><a href="ch13-02-FancierGraphics.html"><strong aria-hidden="true">13.2.</strong> Fancier Graphics</a></li><li class="chapter-item expanded "><a href="ch13-03-ComplexComponentsandMVC.html"><strong aria-hidden="true">13.3.</strong> Complex Components and MVC</a></li><li class="chapter-item expanded "><a href="ch13-04-MostlyWindowsandDialogs.html"><strong aria-hidden="true">13.4.</strong> Mostly Windows and Dialogs</a></li><li class="chapter-item expanded "><a href="ch13-05-FinishingTouches.html"><strong aria-hidden="true">13.5.</strong> Finishing Touches</a></li><li class="chapter-item expanded "><a href="ch13-06-Exercises.html"><strong aria-hidden="true">13.6.</strong> Exercises</a></li><li class="chapter-item expanded "><a href="ch13-07-Quiz.html"><strong aria-hidden="true">13.7.</strong> Quiz</a></li></ol><li class="chapter-item expanded "><a href="appendix-00.html"> Appendix</a></li><li class="chapter-item expanded "><a href="glossary-00.html"> Glossary</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="Java">Java</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Introduction to Programming Using Java</h1>

                    <div class="right-buttons">

                        <a href="https://github.com/Xayarsh/Java-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="Exceptions and try..catch"><a class="header" href="#Exceptions and try..catch">Exceptions and try..catch</a></h2>
                        <p>
                            Getting a program to work under ideal circumstances
                            is usually a lot easier than making the program <span class="newword">robust</span>.
                            A robust program can survive unusual or "exceptional"
                            circumstances without crashing. One approach to writing robust programs is to
                            anticipate the problems that might arise and to include tests in the program
                            for each possible problem. For example, a program will crash if it tries to use
                            an array element <span class="code">A[i]</span>, when <span class="code">i</span> is not within the declared
                            range of indices for the array <span class="code">A</span>. A robust program must anticipate the
                            possibility of a bad index and guard against it.  One way to do this is to
                            write the program in a way that ensures (as a postcondition of the code that
                            precedes the array reference) that the index is in the legal range.
                            Another way is to test whether the index value is legal before using it in the array.
                            This could be done with an <span class="code">if</span> statement:</p>


                        <pre><code class="java">if (i &lt; 0 || i &gt;= A.length) {
   ...  // Do something to handle the out-of-range index, i
}
else {
   ...  // Process the array element, A[i]
}</code></pre>


                        <p>There are some problems with this approach. It is difficult and sometimes
                            impossible to anticipate all the possible things that might go wrong. It's not
                            always clear what to do when an error is detected. Furthermore, trying to
                            anticipate all the possible problems can turn what would otherwise be a
                            straightforward algorithm into a messy tangle of <span class="code">if</span> statements.</p>



                        <h3 id="Exceptions and Exception Classes"><a class="header" href="#Exceptions and Exception Classes">Exceptions and Exception Classes</a></h3>


                        <p>We have already seen in <a href="ch03-07-ExceptionsTryCatch.html">Section&nbsp;3.7</a>
                            that Java provides a neater, more structured alternative
                            technique for dealing with errors that can occur while a program is running. The
                            technique is referred to as <span class="newword">exception handling</span>.  The
                            word "exception" is meant to be more general than "error." It includes any
                            circumstance that arises as the program is executed which is meant to be
                            treated as an exception to the normal flow of control of the program. An
                            exception might be an error, or it might just be a special case that you would
                            rather not have clutter up your elegant algorithm.</p>


                        <p>When an exception occurs during the execution of a program, we say that the
                            exception is <span class="newword">thrown</span>. When this happens, the normal
                            flow of the program is thrown off-track, and the program is in danger of
                            crashing. However, the crash can be avoided if the exception is
                            <span class="newword">caught</span> and handled in some way.  An exception can be thrown in
                            one part of a program and caught in a different part. An exception that is not
                            caught will generally cause the program to crash. (More exactly, the thread
                            that throws the exception will crash. In a multithreaded program, it is
                            possible for other threads to continue even after one crashes.  We will
                            cover threads in <a href="ch12-00-ThreadsandMultiprocessing.html">Chapter&nbsp;12</a>. In particular, GUI
                            programs are multithreaded, and parts of the program might continue to
                            function even while other parts are non-functional because of exceptions.)</p>


                        <p>By the way, since Java programs are executed by a Java interpreter, having a
                            program crash simply means that it terminates abnormally and prematurely. It
                            doesn't mean that the Java interpreter will crash. In effect, the interpreter
                            catches any exceptions that are not caught by the program. The interpreter
                            responds by terminating the program. In many other programming languages, a
                            crashed program will sometimes crash the entire system and freeze the computer
                            until it is restarted. With Java, such system crashes should be impossible&mdash;which
                            means that when they happen, you have the satisfaction of blaming the
                            system rather than your own program.</p>


                        <p>Exceptions were introduced in <a href="ch03-07-ExceptionsTryCatch.html">Section&nbsp;3.7</a>, along with the
                            <span class="code">try..catch</span> statement, which is used to catch and handle exceptions.
                            However, that section did not cover the complete syntax of <span class="code">try..catch</span>
                            or the full complexity of exceptions.  In this section, we cover these topics in
                            full detail.</p>


                        <p>When an exception occurs, the thing that is actually "thrown" is an object.
                            This object can carry information (in its instance variables) from the point
                            where the exception occurs to the point where it is caught and handled. This
                            information always includes the <span class="newword">subroutine call stack</span>,
                            which is a list of the subroutines that were being executed when
                            the exception was thrown. (Since one subroutine can call another, several
                            subroutines can be active at the same time.) Typically, an exception object
                            also includes an error message describing what happened to cause the exception,
                            and it can contain other data as well.   All exception objects must belong to
                            a subclass of the standard class <span class="code">java.lang.Throwable</span>.
                            In general, each different type of exception is represented by
                            its own subclass of <span class="classname">Throwable</span>, and these subclasses
                            are arranged in a fairly complex class hierarchy that shows the relationship
                            among various types of exception.
                            <span class="classname">Throwable</span> has two direct
                            subclasses, <span class="classname">Error</span> and <span class="classname">Exception</span>.
                            These two subclasses in turn
                            have many other predefined subclasses. In addition, a programmer can create new
                            exception classes to represent new types of exception.</p>


                        <p>Most of the subclasses of the class <span class="classname">Error</span> represent serious errors
                            within the Java virtual machine that should ordinarily cause program
                            termination because there is no reasonable way to handle them. In general, you should not
                            try to catch and handle such errors.  An example is a
                            <span class="classname">ClassFormatError</span>, which occurs when the Java virtual machine finds
                            some kind of illegal data in a file that is supposed to contain a compiled Java
                            class. If that class was being loaded as part of the program, then there is
                            really no way for the program to proceed.</p>


                        <p>On the other hand, subclasses of the class <span class="classname">Exception</span> represent
                            exceptions that are meant to be caught. In many cases, these are exceptions
                            that might naturally be called "errors," but they are errors in the program or
                            in input data that a programmer can anticipate and possibly respond to in some
                            reasonable way. (However, you should avoid the temptation of saying, "Well,
                            I'll just put a thing here to catch all the errors that might occur, so my
                            program won't crash." If you don't have a reasonable way to respond to the
                            error, it's best just to let the program crash, because trying to go on
                            will probably only lead to worse things down the road&mdash;in the worst case, a
                            program that gives an incorrect answer without giving you any indication that
                            the answer might be wrong!)</p>


                        <p>The class <span class="classname">Exception</span> has its own subclass,
                            <span class="classname">RuntimeException</span>. This class groups together many common exceptions,
                            including all those that have been covered in previous sections.  For example,
                            <span class="classname">IllegalArgumentException</span> and <span class="classname">NullPointerException</span>
                            are subclasses of <span class="classname">RuntimeException</span>.
                            A <span class="classname">RuntimeException</span> generally
                            indicates a bug in the program, which the programmer should fix.
                            <span class="classname">RuntimeExceptions</span> and <span class="classname">Errors</span> share the property that a
                            program can simply ignore the possibility that they might occur. ("Ignoring"
                            here means that you are content to let your program crash if the exception
                            occurs.) For example, a program does this every time it uses an array reference
                            like <span class="code">A[i]</span> without making arrangements to catch a possible
                            <span class="classname">ArrayIndexOutOfBoundsException</span>. For all other exception classes
                            besides <span class="classname">Error</span>, <span class="classname">RuntimeException</span>, and their subclasses,
                            exception-handling is "mandatory" in a sense that I'll discuss below.</p>


                        <p>The following diagram is a class hierarchy showing the class
                            <span class="code">Throwable</span> and just a few of its subclasses. Classes that require
                            mandatory exception-handling are shown in red:</p>


                        <p align="center">
                            <img src="./images/exception-hierarchy.png" width="561" height="347" alt="Partial class hierarchy for Throwable objects" class="bordered"></p>


                        <p>The class <span class="classname">Throwable</span> includes several instance methods that can
                            be used with any exception object.  If <span class="code">e</span> is of type <span class="classname">Throwable</span>
                            (or one of its subclasses), then <span class="code">e.getMessage()</span> is a function that returns a
                            <span class="classname">String</span> that describes the exception.  The function <span class="code">e.toString()</span>,
                            which is used by the system whenever it needs a string representation of the object,
                            returns a <span class="classname">String</span> that contains the name of the class to which the
                            exception belongs as well as the same string that would be returned by <span class="code">e.getMessage()</span>.
                            And the method <span class="code">e.printStackTrace()</span> writes a stack trace to standard output that tells
                            which subroutines were active when the exception occurred.
                            A stack trace can be very useful when you
                            are trying to determine the cause of the problem.  Information in the stack trace can
                            tell you exactly where in the program the exception occurred.
                            (Note that if an exception is <b>not</b>
                            caught by the program, then the default response to the exception  prints the stack trace to standard output.)</p>
                        

                        <h3 id="The try Statement"><a class="header" href="#The try Statement">The try Statement</a></h3>

                        <p>To catch exceptions in a Java program, you need a <span class="code">try</span> statement.
                            We have been using such statements since <a href="ch03-07-ExceptionsTryCatch.html">Section&nbsp;3.7</a>, but the
                            full syntax of the <span class="code">try</span> statement is more complicated than what
                            was presented there.  The <span class="code">try</span> statements that we have used so
                            far had a syntax similar to the following example:</p>


                        <pre><code class="java">try {
    double determinant = M[0][0]*M[1][1] - M[0][1]*M[1][0];
    System.out.println("The determinant of M is " + determinant);
}
catch ( ArrayIndexOutOfBoundsException e ) {
   System.out.println("M is the wrong size to have a determinant.");
   e.printStackTrace();
}</code></pre>


                        <p>Here, the computer tries to execute the block of statements following the word
                            "<span class="code">try</span>". If no exception occurs during the execution of this block, then
                            the "<span class="code">catch</span>" part of the statement is simply ignored. However, if an
                            exception of type
                            <span class="classname">ArrayIndexOutOfBoundsException</span> occurs, then the computer jumps
                            immediately to the <span class="code">catch</span> clause of the <span class="code">try</span> statement.
                            This block of statements is said to be an <span class="newword">exception handler</span> for
                            <span class="classname">ArrayIndexOutOfBoundsException</span>. By handling the exception in this way,
                            you prevent it from crashing the program.  Before the body of the <span class="code">catch</span> clause
                            is executed, the object that represents the exception is assigned to the variable <span class="code">e</span>,
                            which is used in this example to print a stack trace.</p>


                        <p>However, the full syntax of the <span class="code">try</span> statement has many options.
                            It will take a while to go through them.  For one thing, a <span class="code">try..catch</span>
                            statement can have more than one
                            <span class="code">catch</span> clause.  This makes it possible to catch several different types
                            of exception with one <span class="code">try</span> statement.  In the above example, in addition
                            to the possible <span class="classname">ArrayIndexOutOfBoundsException</span>, there is a
                            possible <span class="classname">NullPointerException</span> which will occur if the value
                            of <span class="code">M</span> is <span class="code">null</span>.  We can handle both possible exceptions by
                            adding a second <span class="code">catch</span> clause to the <span class="code">try</span> statement:</p>


                        <pre><code class="java">try {
    double determinant = M[0][0]*M[1][1] - M[0][1]*M[1][0];
    System.out.println("The determinant of M is " + determinant);
}
catch ( ArrayIndexOutOfBoundsException e ) {
   System.out.println("M is the wrong size to have a determinant.");
}
catch ( NullPointerException e ) {
   System.out.print("Programming error!  M doesn't exist." + );
}</code></pre>


                        <p>Here, the computer tries to execute the statements in the <span class="code">try</span> clause.
                            If no error occurs, both of the <span class="code">catch</span> clauses are skipped.  If an
                            <span class="classname">ArrayIndexOutOfBoundsException</span> occurs, the computer executes
                            the body of the first <span class="code">catch</span> clause and skips the second one.  If a
                            <span class="classname">NullPointerException</span> occurs, it jumps to the second
                            <span class="code">catch</span> clause and executes that.</p>


                        <p>Note that both <span class="classname">ArrayIndexOutOfBoundsException</span> and
                            <span class="classname">NullPointerException</span> are subclasses of <span class="classname">RuntimeException</span>. It's
                            possible to catch all <span class="classname">RuntimeExceptions</span> with a single <span class="code">catch</span>
                            clause. For example:</p>


                        <pre><code class="java">try {
    double determinant = M[0][0]*M[1][1] - M[0][1]*M[1][0];
    System.out.println("The determinant of M is " + determinant);
}
catch ( RuntimeException err ) {
   System.out.println("Sorry, an error has occurred.");
   System.out.println("The error was: " + err);
}</code></pre>


                        <p>The <span class="code">catch</span> clause in this <span class="code">try</span> statement will catch
                            any exception belonging to class <span class="classname">RuntimeException</span> or to
                            any of its subclasses.  This shows why exception classes are organized into a
                            class hierarchy. It allows you the option of casting your net narrowly to catch
                            only a specific type of exception. Or you can cast your net widely to catch a
                            wide class of exceptions.  Because of subclassing, when there are multiple <span class="code">catch</span> clauses
                            in a <span class="code">try</span> statement, it is possible that a given exception might
                            match several of those <span class="code">catch</span> clauses.  For example, an exception of
                            type <span class="classname">NullPointerException</span> would match <span class="code">catch</span>
                            clauses for <span class="classname">NullPointerException</span>, <span class="classname">RuntimeException</span>,
                            <span class="classname">Exception</span>, or <span class="classname">Throwable</span>.  In this
                            case, only the <b>first</b> <span class="code">catch</span> clause that matches the exception
                            is executed.</p>


                        <p>Of course, catching <span class="classname">RuntimeException</span> would catch many more
                            types of exception than the two that we are interested in.  It is possible to
                            combine several specific exception types in a single <span class="code">catch</span> clause.
                            For example,</p>


                        <pre><code class="java">try {
    double determinant = M[0][0]*M[1][1] - M[0][1]*M[1][0];
    System.out.println("The determinant of M is " + determinant);
}
catch ( <span class="newcode">NullPointerException</span> | <span class="newcode">ArrayIndexOutOfBoundsException</span> err ) {
   System.out.println("Sorry, an error has occurred.");
   System.out.println("The error was: " + err);
}</code></pre>


                        <p>Here, the two exception types are combined with a&nbsp;"<span class="code">|</span>", the vertical line
                            character that is also used in the boolean <b>or</b> operator.  This example
                            will catch errors of type <span class="classname">NullPointerException</span>
                            or <span class="classname">ArrayIndexOutOfBoundsException</span>, and no other types.</p>


                        <p>The example I've been using here is not realistic, because you are not very
                            likely to use exception-handling to guard against null pointers and bad array
                            indices. This is a case where careful programming is better than exception
                            handling: Just be sure that your program assigns a reasonable,
                            non-<span class="code">null</span> value to the array <span class="code">M</span>. You would certainly resent it
                            if the designers of Java forced you to set up a <span class="code">try..catch</span>
                            statement every time you wanted to use an array! This is why handling of
                            potential <span class="classname">RuntimeExceptions</span> is not mandatory. There are just too many
                            things that might go wrong! (This also shows that exception-handling does not
                            solve the problem of program robustness. It just gives you a tool that will in
                            many cases let you approach the problem in a more organized way.)</p>





                        <p>I have still not completely specified the syntax of the <span class="code">try</span> statement.
                            The next variation is the possibility of a <span class="newword">finally clause</span>
                            at the end of a <span class="code">try</span> statement.  With this addition, the syntax of the <span class="code">try</span>
                            statement can be described as:</p>


                        <pre><code class="java">try {
   <span class="bnf">statements</span>
}
<span class="bnf">optional-catch-clauses</span>
<span class="bnf">optional-finally-clause</span>
</code></pre>


                        <p>Note that the <span class="code">catch</span> clauses are also listed as optional.
                            The <span class="code">try</span> statement can include zero or more <span class="code">catch</span> clauses and,
                            optionally, a <span class="code">finally</span> clause.  The <span class="code">try</span> statement <b>must</b> include
                            one or the other.  That is, a <span class="code">try</span> statement can have
                            either a <span class="code">finally</span> clause, or one or more <span class="code">catch</span> clauses, or both.  The
                            syntax for a <span class="code">catch</span> clause is</p>


                        <pre><code class="java">catch ( <span class="bnf">exception-class-names</span> <span class="bnf">variable-name</span> ) {
   <span class="bnf">statements</span>
}</code></pre>


                        <p>where <span class="bnf">exception-class-names</span> can be a single exception class or several classes separated
                            by&nbsp;"<span class="code">|</span>".
                            The syntax for a <span class="code">finally</span> clause is</p>


                        <pre><code class="java">finally {
   <span class="bnf">statements</span>
}</code></pre>


                        <p>The semantics of the <span class="code">finally</span> clause is that the block of statements
                            in the <span class="code">finally</span> clause is guaranteed to be executed as the last step in
                            the execution of the try statement, whether or not any exception occurs and
                            whether or not any exception that does occur is caught and handled. The
                            <span class="code">finally</span> clause is meant for doing essential cleanup that under no
                            circumstances should be omitted.  One example of this type of cleanup is
                            closing a network connection.  Although you don't yet know enough about networking
                            to look at the actual programming in this case, we can consider some pseudocode:</p>


                        <pre><code class="java">try {
   open a network connection
   communicate over the connection
}
catch ( IOException e ) {
   report the error
}
finally {
   if the connection was successfully opened
      close the connection
}</code></pre>


                        <p>The <span class="code">finally</span> clause
                            ensures that the network connection will definitely be closed, whether or
                            not an error occurs during the communication.  The pseudocode in this
                            example follows a general pattern that can be used to robustly obtain a resource,
                            use the resource, and then release the resource.</p>





                        <p>The pattern of obtaining a resource, then using the resource, and then releasing
                            the resource is very common.  Note that the resource can only be released if no error occurred
                            while obtaining it.  And, if it was successfully obtained, then it should be
                            closed whether or not an error occurs while using it.  This pattern is so common
                            that it leads to one last option in the <span class="code">try</span> statement syntax.
                            With this option, you only need code to obtain the resource, and you don't need
                            to worry about releasing it.  That will happen automatically at the end of the
                            <span class="code">try</span> statement.</p>


                        <p>In order for this to work, the resource must be represented by an object that
                            implements an interface named <span class="classname">AutoCloseable</span>, which defines
                            a single method named <span class="code">close()</span>, with no parameters.  Standard Java
                            classes that represent things like files and network connections already implement
                            <span class="classname">AutoClosable</span>.  So does the <span class="classname">Scanner</span>
                            class, which was introduced in <a href="ch02-04-TextInputAndOutput.html">Subsection&nbsp;2.4.6</a>.  In that section,
                            I showed how to use a Scanner to read from <span class="code">System.in</span>.  Although
                            I didn't do it in that section, it's considered good form to close a Scanner
                            after using it.  Here is an example that uses the  pattern in a
                            <span class="code">try</span> statement to make sure that the Scanner is closed automatically:</p>


                        <pre><code class="java">try( Scanner in = new Scanner(System.in) ) {
    // Use the Scanner to read from standard input
}
catch (Exception e) {
    // ... some error occurred while using the Scanner
}</code></pre>


                        <p>The statement that allocates the <span class="classname">Scanner</span> goes in parentheses after
                            the word "try".  The statement must have the form of a variable declaration
                            that includes an initialization of the variable.  The variable is
                            local to the <span class="code">try</span> statement.  (You can actually declare several
                            variables in the parentheses, separated by semicolons.)  In this
                            example, we can be sure that <span class="code">in.close()</span> will definitely be
                            called by the system at the end of the <span class="code">try</span> statement, as long
                            as the Scanner was successfully initialized.</p>


                        <p>This is all getting quite complicated, and I won't continue the discussion
                            here.  The sample program <span class="sourceref"><a href="./source/chapter8/TryStatementDemo.java">TryStatementDemo.java</a></span> demonstrates
                            a <span class="code">try</span> statement with all its options, and it includes a lot of comments
                            to help you understand what can happen when you run the program.</p>
                        

                        <h3 id="Throwing Exceptions"><a class="header" href="#Throwing Exceptions">Throwing Exceptions</a></h3>

                        <p>There are times when it makes sense for a program to deliberately throw an
                            exception. This is the case when the program discovers some sort of exceptional
                            or error condition, but there is no reasonable way to handle the error at the
                            point where the problem is discovered. The program can throw an exception in
                            the hope that some other part of the program will catch and handle the
                            exception.  This can be done with a <span class="newword">throw statement</span>.
                            You have already seen an example of this in <a href="ch04-03-Parameters.html">Subsection&nbsp;4.3.8</a>.
                            In this section, we cover the <span class="code">throw</span> statement more fully.
                            The syntax of the <span class="code">throw</span> statement is:</p>


                        <pre><code class="java">throw  <span class="bnf">exception-object</span> ;</code></pre>


                        <p>The <span class="bnf">exception-object</span> must be an object
                            belonging to one of the subclasses of <span class="code">Throwable</span>. Usually, it will in
                            fact belong to one of the subclasses of <span class="code">Exception</span>. In most cases, it
                            will be a newly constructed object created with the <span class="code">new</span> operator. For
                            example:</p>


                        <pre><code class="java">throw new ArithmeticException("Division by zero");</code></pre>


                        <p>The parameter in the constructor becomes the error message in the exception
                            object; if <span class="code">e</span> refers to the object, the error message can be retrieved
                            by calling <span class="code">e.getMessage()</span>.
                            (You might find this example a bit odd, because you might expect the
                            system itself to throw an <span class="classname">ArithmeticException</span> when an attempt is made
                            to divide by zero. So why should a programmer bother to throw the exception?
                            Recall that if the numbers that are being divided are of
                            type <span class="ptype">int</span>, then division by zero will indeed throw an
                            <span class="classname">ArithmeticException</span>. However, no arithmetic operations with
                            floating-point numbers will ever produce an exception. Instead, the special
                            value <span class="code">Double.NaN</span> is used to represent the result of an illegal
                            operation.  In some situations, you might prefer to throw an
                            <span class="classname">ArithmeticException</span> when a real number is divided by zero.)</p>


                        <p>An exception can be thrown either by the system or by a <span class="code">throw</span>
                            statement. The exception is processed in exactly the same way in either case.
                            Suppose that the exception is thrown inside a <span class="code">try</span> statement. If that
                            <span class="code">try</span> statement has a <span class="code">catch</span> clause that handles that type of
                            exception, then the computer jumps to the <span class="code">catch</span> clause and executes
                            it. The exception has been <span class="newword">handled</span>. After handling
                            the exception, the computer executes the <span class="code">finally</span> clause of the
                            <span class="code">try</span> statement, if there is one. It then continues normally with the
                            rest of the program, which follows the <span class="code">try</span> statement. If the exception
                            is not immediately caught and handled, the processing of the exception will
                            continue.</p>


                        <p>When an exception is thrown during the execution of a subroutine and the
                            exception is not handled in the same subroutine, then that subroutine is
                            terminated (after the execution of any pending <span class="code">finally</span> clauses). Then
                            the routine that called that subroutine gets a chance to handle the exception.
                            That is, if the subroutine was called inside a <span class="code">try</span> statement that has
                            an appropriate <span class="code">catch</span> clause, then <b>that</b> <span class="code">catch</span> clause will be
                            executed and the program will continue on normally from there. Again, if the second
                            routine does not handle the exception, then it also is terminated and the
                            routine that called <b>it</b> (if any) gets the next shot at the exception. The
                            exception will crash the program only if it passes up through the entire chain
                            of subroutine calls without being handled.  This is called "unwinding the call stack."</p>


                        <p>A subroutine that might generate an exception can announce this fact by
                            adding a clause "<span class="code">throws</span> <span class="bnf">exception-class-name</span>"
                            to the header of the routine. For example:</p>


                        <pre><code class="java">/**
 * Returns the larger of the two roots of the quadratic equation
 * A*x*x + B*x + C = 0, provided it has any roots.  If A == 0 or
 * if the discriminant, B*B - 4*A*C, is negative, then an exception
 * of type IllegalArgumentException is thrown.
 */
static public double root( double A, double B, double C )
                              <span class="newcode">throws IllegalArgumentException</span> {
    if (A == 0) {
      throw new IllegalArgumentException("A can't be zero.");
    }
    else {
       double disc = B*B - 4*A*C;
       if (disc &lt; 0)
          throw new IllegalArgumentException("Discriminant &lt; zero.");
       return  (-B + Math.sqrt(disc)) / (2*A);
    }
}</code></pre>


                        <p>As discussed in the <a href="ch08-02-WritingCorrectPrograms.html">previous section</a>,
                            the computation
                            in this subroutine has the preconditions that <span class="code">A&nbsp;!=&nbsp;0</span> and <span class="code">B*B-4*A*C
&gt;=&nbsp;0</span>. The subroutine throws an exception of type
                            <span class="classname">IllegalArgumentException</span> when either of these preconditions is
                            violated. When an illegal condition is found in a subroutine, throwing an
                            exception is often a reasonable response.  If the program that called the
                            subroutine knows some good way to handle the error, it can catch the exception.
                            If not, the program will crash&mdash;and the programmer will know that the program
                            needs to be fixed.</p>


                        <p>A <span class="code">throws</span> clause in a subroutine heading can declare several different
                            types of exception, separated by commas.  For example:</p>


                        <pre><code class="java">void processArray(int[] A) throws NullPointerException,
                                         ArrayIndexOutOfBoundsException { ...</code></pre>
                        

                        <h3 id="Mandatory Exception Handling"><a class="header" href="#Mandatory Exception Handling">Mandatory Exception Handling</a></h3>


                        <p>In the preceding example, declaring that the subroutine <span class="code">root()</span> can
                            throw an <span class="classname">IllegalArgumentException</span> is just a courtesy to potential
                            readers of this routine. This is because handling of
                            <span class="classname">IllegalArgumentExceptions</span> is not "mandatory." A routine can throw an
                            <span class="classname">IllegalArgumentException</span> without announcing the possibility. And a
                            program that calls that routine is free either to catch or to ignore the
                            exception, just as a programmer can choose either to catch or to ignore an
                            exception of type <span class="classname">NullPointerException</span>.</p>


                        <p>For those exception classes that require mandatory handling, the situation
                            is different. If a subroutine can throw such an exception, that fact
                            <b>must</b> be announced in a <span class="code">throws</span> clause in the routine definition.
                            Failing to do so is a syntax error that will be reported by the compiler.
                            Exceptions that require mandatory handling are called <span class="newword">checked exceptions</span>.
                            The compiler will check that such exceptions are handled by the program.</p>


                        <p>Suppose that some statement in the body of a subroutine can generate a
                            checked exception, one that requires mandatory handling. The statement could be a
                            <span class="code">throw</span> statement, which throws the exception directly, or it could be a
                            call to a subroutine that can throw the exception. In either case, the
                            exception <b>must</b> be handled. This can be done in one of two ways: The first way
                            is to place the statement in a <span class="code">try</span> statement that has a <span class="code">catch</span>
                            clause that handles the exception; in this case, the exception is handled within the
                            subroutine, so that no caller of the subroutine can ever see the exception.
                            The second way is to declare that the subroutine can throw the exception. This is done by
                            adding a "<span class="code">throws</span>" clause to the subroutine heading, which alerts any callers
                            to the possibility that the exception might be generated when the subroutine is executed.
                            The caller will, in turn, be forced either to handle the exception in a <span class="code">try</span>
                            statement or to declare the exception in a <span class="code">throws</span> clause in its own
                            header.</p>


                        <p>Exception-handling is mandatory for any exception class that is <b>not</b> a
                            subclass of either <span class="classname">Error</span> or <span class="classname">RuntimeException</span>.
                            These checked exceptions generally represent conditions that are outside the
                            control of the programmer. For example, they might represent bad input or an
                            illegal action taken by the user.  There is no way to <b>avoid</b> such errors,
                            so a robust program has to be prepared to handle them.  The design of Java makes it
                            impossible for programmers to ignore the possibility of such errors.</p>


                        <p>Among the checked exceptions are several that can
                            occur when using Java's input/output routines. This means that you can't even
                            use these routines unless you understand something about exception-handling.
                            <a href="ch11-00-IOStreamsFilesNetworking.html">Chapter&nbsp;11</a> deals with input/output and uses checked exceptions
                            extensively.</p>

                        
                        <h3 id="Programming with Exceptions"><a class="header" href="#Programming with Exceptions">Programming with Exceptions</a></h3>

                        <p>Exceptions can be used to help write robust
                            programs. They provide an organized and structured approach to robustness.
                            Without exceptions, a program can become cluttered with <span class="code">if</span> statements
                            that test for various possible error conditions. With exceptions, it becomes
                            possible to write a clean implementation of an algorithm that will handle all
                            the normal cases. The exceptional cases can be handled elsewhere, in a
                            <span class="code">catch</span> clause of a <span class="code">try</span> statement.</p>


                        <p>When a program encounters an exceptional condition and has no way of
                            handling it immediately, the program can throw an exception. In some cases, it
                            makes sense to throw an exception belonging to one of Java's predefined
                            classes, such as <span class="classname">IllegalArgumentException</span> or <span class="classname">IOException</span>.
                            However, if there is no standard class that adequately represents the
                            exceptional condition, the programmer can define a new exception class. The new
                            class must extend the standard class <span class="classname">Throwable</span> or one of its
                            subclasses. In general, if the programmer does <b>not</b> want to require
                            mandatory exception handling,
                            the new class will extend <span class="classname">RuntimeException</span> (or
                            one of its subclasses).  To create a new checked exception class, which <b>does</b> require
                            mandatory handling, the programmer can extend one of the other subclasses of
                            <span class="classname">Exception</span> or can extend <span class="classname">Exception</span> itself.</p>


                        <p>Here, for example, is a class that extends <span class="classname">Exception</span>, and therefore
                            requires mandatory exception handling when it is used:</p>


                        <pre><code class="java">public class ParseError extends Exception {
   public ParseError(String message) {
         // Create a ParseError object containing
         // the given message as its error message.
      super(message);
   }
}</code></pre>


                        <p>The class contains only a constructor that makes it possible to create a
                            <span class="classname">ParseError</span> object containing a given error message. (The statement
                            "<span class="code">super(message)</span>" calls a constructor in the superclass,
                            <span class="classname">Exception</span>. See <a href="ch05-06-thisandsuper.html">Subsection&nbsp;5.6.3</a>.) Of course the
                            class inherits the <span class="code">getMessage()</span> and <span class="code">printStackTrace()</span>
                            routines from its superclass. If <span class="code">e</span> refers to an object of type
                            <span class="classname">ParseError</span>, then the function call <span class="code">e.getMessage()</span> will
                            retrieve the error message that was specified in the constructor. But the main
                            point of the <span class="classname">ParseError</span> class is simply to exist. When an object of
                            type <span class="classname">ParseError</span> is thrown, it indicates that a certain type of error
                            has occurred. (<span class="newword">Parsing</span>, by the way, refers to
                            figuring out the syntax of a string. A <span class="classname">ParseError</span> would indicate,
                            presumably, that some string that is being processed by the program does not have the
                            expected form.)</p>


                        <p>A <span class="code">throw</span> statement can be used in a program to throw an error of
                            type <span class="classname">ParseError</span>. The constructor for the <span class="classname">ParseError</span> object
                            must specify an error message. For example:</p>


                        <pre><code class="java">throw new ParseError("Encountered an illegal negative number.");</code></pre>


                        <p>or</p>


                        <pre><code class="java">throw new ParseError("The word '" + word
                               + "' is not a valid file name.");</code></pre>


                        <p>Since <span class="classname">ParseError</span> is defined as a subclass of <span class="classname">Exception</span>,
                            it is a checked exception.
                            If the <span class="code">throw</span> statement does not occur in a <span class="code">try</span> statement
                            that catches the error, then the subroutine that contains the <span class="code">throw</span>
                            must declare that it can throw a <span class="classname">ParseError</span> by
                            adding the clause "<span class="code">throws ParseError</span>" to the subroutine heading. For
                            example,</p>


                        <pre><code class="java">void getUserData() throws ParseError {
   . . .
}</code></pre>


                        <p>This would not be required if <span class="classname">ParseError</span> were defined as a subclass
                            of <span class="classname">RuntimeException</span> instead of <span class="classname">Exception</span>, since in that case
                            <span class="classname">ParseErrors</span> would not be checked exceptions.</p>


                        <p>A routine that wants to handle <span class="classname">ParseErrors</span> can use a <span class="code">try</span>
                            statement with a <span class="code">catch</span> clause that catches <span class="classname">ParseErrors</span>. For
                            example:</p>


                        <pre><code class="java">try {
   getUserData();
   processUserData();
}
catch (ParseError pe) {
   . . .  // Handle the error
}</code></pre>


                        <p>Note that since <span class="classname">ParseError</span> is a subclass of <span class="classname">Exception</span>, a
                            <span class="code">catch</span> clause of the form "<span class="code">catch (Exception e)</span>" would also
                            catch <span class="classname">ParseErrors</span>, along with any other object of type
                            <span class="classname">Exception</span>.</p>


                        <p>Sometimes, it's useful to store extra data in an exception object. For
                            example,</p>


                        <pre><code class="java">class ShipDestroyed extends RuntimeException {
   Ship ship;  // Which ship was destroyed.
   int where_x, where_y;  // Location where ship was destroyed.
   ShipDestroyed(String message, Ship s, int x, int y) {
         // Constructor creates a ShipDestroyed object
         // carrying an error message plus the information
         // that the ship s was destroyed at location (x,y)
         // on the screen.
       super(message);
       ship = s;
       where_x = x;
       where_y = y;
   }
}</code></pre>


                        <p>Here, a <span class="classname">ShipDestroyed</span> object contains an error message and some
                            information about a ship that was destroyed. This could be used, for example,
                            in a statement:</p>


                        <pre><code class="java">if ( userShip.isHit() )
   throw new ShipDestroyed("You've been hit!", userShip, xPos, yPos);</code></pre>


                        <p>Note that the condition represented by a <span class="classname">ShipDestroyed</span> object might
                            not even be considered an error. It could be just an expected interruption to
                            the normal flow of a game. Exceptions can sometimes be used to handle such
                            interruptions neatly.</p>





                        <p>The ability to throw exceptions is particularly useful in writing
                            general-purpose methods and classes that are meant to be used in more than
                            one program. In this case, the person writing the method or class often has
                            no reasonable way of handling the error, since that person has no way of
                            knowing exactly how the method or class will be used. In such
                            circumstances, a novice programmer is often tempted to print an error message
                            and forge ahead, but this is almost never satisfactory since it can lead to
                            unpredictable results down the line. Printing an error message and terminating
                            the program is almost as bad, since it gives the program no chance to handle
                            the error.</p>


                        <p>The program that calls the method or uses the class needs to know that
                            the error has occurred. In languages that do not support exceptions, the only
                            alternative is to return some special value or to set the value of some global
                            variable to indicate that an error has occurred. For example, the
                            <span class="code">readMeasurement()</span> function in <a href="ch08-02-WritingCorrectPrograms.html">Subsection&nbsp;8.2.2</a> returns
                            the value <span class="code">-1</span> if the user's input is illegal. However, this only does any good
                            if the main program bothers to test the return value.  It is very easy to be lazy about
                            checking for special return values every time a subroutine is called.
                            And in this case, using
                            <span class="code">-1</span> as a signal that an error has occurred makes it impossible to allow
                            negative measurements.  Exceptions are a cleaner way for a subroutine to react
                            when it encounters an error.</p>


                        <p>It is easy to modify the <span class="code">readMeasurement()</span> function to use
                            exceptions instead of a special return value to signal an error. My modified
                            subroutine throws a <span class="classname">ParseError</span> when the user's input is illegal, where
                            <span class="classname">ParseError</span> is the subclass of <span class="classname">Exception</span> that was defined
                            above. (Arguably, it might be reasonable to avoid
                            defining a new class by using the standard exception class
                            <span class="classname">IllegalArgumentException</span> instead.) The changes from the original
                            version are shown in red:</p>


                        <pre><code class="java">
/**
 * Reads the user's input measurement from one line of input.
 * Precondition:   The input line is not empty.
 * Postcondition:  If the user's input is legal, the measurement
 *                 is converted to inches and returned.
 <span class="newcode">* @throws ParseError if the user's input is not legal.</span>
 */
static double readMeasurement() <span class="newcode">throws ParseError</span> {

   double inches;  // Total number of inches in user's measurement.

   double measurement;  // One measurement,
                        //   such as the 12 in "12 miles."
   String units;        // The units specified for the measurement,
                        //   such as "miles."

   char ch;  // Used to peek at next character in the user's input.

   inches = 0;  // No inches have yet been read.

   skipBlanks();
   ch = TextIO.peek();

   /* As long as there is more input on the line, read a measurement and
      add the equivalent number of inches to the variable, inches.  If an
      error is detected during the loop, end the subroutine immediately
      by <span class="newcode">throwing a ParseError.</span> */

   while (ch != '\n') {

       /* Get the next measurement and the units.  Before reading
          anything, make sure that a legal value is there to read. */

       if ( ! Character.isDigit(ch) ) {
           <span class="newcode">throw new ParseError("Expected to find a number, but found " + ch);</span>
       }
       measurement = TextIO.getDouble();

       skipBlanks();
       if (TextIO.peek() == '\n') {
          <span class="newcode">throw new ParseError("Missing unit of measure at end of line.");</span>
       }
       units = TextIO.getWord();
       units = units.toLowerCase();

       /* Convert the measurement to inches and add it to the total. */

       if (units.equals("inch")
               || units.equals("inches") || units.equals("in")) {
           inches += measurement;
       }
       else if (units.equals("foot")
                  || units.equals("feet") || units.equals("ft")) {
           inches += measurement * 12;
       }
       else if (units.equals("yard")
                  || units.equals("yards") || units.equals("yd")) {
           inches += measurement * 36;
       }
       else if (units.equals("mile")
                  || units.equals("miles") || units.equals("mi")) {
           inches += measurement * 12 * 5280;
       }
       else {
           <span class="newcode">throw new ParseError("\"" + units
                                + "\" is not a legal unit of measure.");</span>
       }

       /* Look ahead to see whether the next thing on the line is
          the end-of-line. */

       skipBlanks();
       ch = TextIO.peek();

   }  // end while

   return inches;

} // end readMeasurement()</code></pre>


                        <p>In the main program, this subroutine is called in a <span class="code">try</span> statement
                            of the form</p>


                        <pre><code class="java">try {
   inches = readMeasurement();
}
catch (ParseError e) {
   . . .  // Handle the error.
}</code></pre>


                        <p>The complete program can be found in the file <span class="sourceref"><a href="./source/chapter8/LengthConverter3.java">LengthConverter3.java</a></span>.
                            From the user's
                            point of view, this program has exactly the same behavior as the program
                            <span class="sourceref"><a href="./source/chapter8/LengthConverter2.java">LengthConverter2</a></span>
                            from the <a href="ch08-02-WritingCorrectPrograms.html">previous section</a>.
                            Internally, however, the programs are significantly
                            different, since <span class="code">LengthConverter3</span> uses exception handling.</p>



                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch08-02-WritingCorrectPrograms.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ch08-04-AssertionsAnnotations.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch08-02-WritingCorrectPrograms.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ch08-04-AssertionsAnnotations.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </body>
</html>
